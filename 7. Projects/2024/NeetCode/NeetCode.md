---
tags: 
date: 2024-12-09
time: 21:28
---
https://neetcode.io/practice

[[2025-04-02|2025-04-02 Wed, 00:02]]
- [[269. Alien Dictionary]]

[[2025-03-30|2025-03-30 Sun, 16:58]]
- [[332. Reconstruct Itinerary]]
- [[778. Swim in Rising Water]]

[[2025-03-27|2025-03-27 Thu, 23:53]]
- [[127. Word Ladder]]

[[2025-03-25|2025-03-25 Tue, 22:55]]
- [[212. Word Search II]]

[[2025-03-23|2025-03-23 Sun, 21:08]]
- [[295. Find Median from Data Stream]]

[[2025-03-22|2025-03-22 Sat, 23:26]]
- [[297. Serialize and Deserialize Binary Tree]]

[[2025-03-21|2025-03-21 Fri, 23:28]]
- [[124. Binary Tree Maximum Path Sum]]

[[2025-03-20|2025-03-20 Thu, 23:58]]
- [[25. Reverse Nodes in k-Group]]

[[2025-03-19|2025-03-19 Wed, 21:48]]
- [[23. Merge k Sorted Lists]]

[[2025-03-18|2025-03-18 Tue, 00:00]]
- [[84. Largest Rectangle in Histogram]]

[[2025-03-17|2025-03-17 Mon, 00:29]]
- [[76. Minimum Window Substring]]
- [[239. Sliding Window Maximum]]
- [[7. Reverse Integer]]

[[2025-03-12|2025-03-12 Wed, 21:36]]
- [[50. Pow(x, n)]]
- [[43. Multiply Strings]]
- [[2013. Detect Squares]]

[[2025-03-09|2025-03-09 Sun, 20:50]]
- [[1899. Merge Triplets to Form Target Triplet]]
- [[763. Partition Labels]]
- [[253. Meeting Rooms II]]
- [[678. Valid Parenthesis String]]

[[2025-03-08]]
- [[846. Hand of Straights]]

[[2025-03-05|2025-03-05 Wed, 21:12]]
- [[416. Partition Equal Subset Sum]]

[[2025-02-23|2025-02-23 Sun, 21:33]]
- [[647. Palindromic Substrings]]

[[2025-02-22|2025-02-22 Sat, 17:17]]
- [[261. Graph Valid Tree]]
- [[323. Number of Connected Components in an Undirected Graph]]
- [[684. Redundant Connection]]
- [[787. Cheapest Flights Within K Stops]]

[[2025-02-20|2025-02-20 Thu, 23:34]]
- [[211. Design Add and Search Words Data Structure]]

[[2025-02-19|2025-02-19 Wed, 22:24]]
- [[17. Letter Combinations of a Phone Number]]
- [[51. N-Queens]]

[[2025-02-17|2025-02-17 Mon, 23:50]]
- [[5. Longest Palindromic Substring]]

[[2025-02-16|2025-02-16 Sun, 13:30]]
- [[79. Word Search]]
- [[131. Palindrome Partitioning]]

[[2025-02-15|2025-02-15 Sat, 15:57]]
- [[46. Permutations]]
- [[90. Subsets II]]

[[2025-02-13|2025-02-13 Thu, 00:30]]
- [[40. Combination Sum II]]

[[2025-02-09|2025-02-09 Sun, 21:58]]
- [[621. Task Scheduler]]
- [[355. Design Twitter]]

[[2025-02-08|2025-02-08 Sat, 14:29]]
- [[230. Kth Smallest Element in a BST]]
- [[105. Construct Binary Tree from Preorder and Inorder Traversal]]
- [[215. Kth Largest Element in an Array]]

[[2025-02-06|2025-02-06 Thu, 22:30]]
- [[1448. Count Good Nodes in Binary Tree]]
- [[98. Validate Binary Search Tree]]

[[2025-02-04|2025-02-04 Tue, 22:50]]
- [[102. Binary Tree Level Order Traversal]]
- [[199. Binary Tree Right Side View]]

[[2025-02-02|2025-02-02 Sun, 21:42]]
- [[146. LRU Cache]]
- [[235. Lowest Common Ancestor of a Binary Search Tree]]

[[2025-02-01|2025-02-01 Sat, 23:20]]
- [[2. Add Two Numbers]]
- [[287. Find the Duplicate Number]]

[[2025-01-31|2025-01-31 Fri, 20:59]]
- [[19. Remove Nth Node From End of List]]
- [[138. Copy List with Random Pointer]]

[[2025-01-30|2025-01-30 Thu, 22:01]]
- [[33. Search in Rotated Sorted Array]]
- [[981. Time Based Key-Value Store]]

[[2025-01-29|2025-01-29 Wed, 20:30]]
- [[875. Koko Eating Bananas]]
- [[153. Find Minimum in Rotated Sorted Array]]

[[2025-01-24|2025-01-24 Fri, 23:04]]
- [[739. Daily Temperatures]]
- [[853. Car Fleet]]

[[2025-01-23|2025-01-23 Thu, 22:47]]
- [[150. Evaluate Reverse Polish Notation]]
- [[22. Generate Parentheses]]

[[2025-01-22|2025-01-22 Wed, 00:24]]
- [[424. Longest Repeating Character Replacement]]
- [[567. Permutation in String]]

[[2025-01-20|2025-01-20 Mon, 21:40]]
- [[11. Container With Most Water]]
- [[42. Trapping Rain Water]]

[[2025-01-19|2025-01-19 Sun, 14:59]]
- [[36. Valid Sudoku]]
- [[128. Longest Consecutive Sequence]]

[[2025-01-18|2025-01-18 Sat, 16:44]]
- [[271. Encode and Decode Strings]]
- [[238. Product of Array Except Self]]

[[2025-01-17|2025-01-17 Fri, 22:02]]
- [[49. Group Anagrams]]
- [[347. Top K Frequent Elements 1|347. Top K Frequent Elements 1]]

[[2025-01-15|2025-01-15 Wed, 22:33]]
- [[268. Missing Number]]
- [[7. Projects/Leetcode/problems/371. Sum of Two Integers|371. Sum of Two Integers]]


中間漏打了幾天：
- [[[Spiral Matrix](https://neetcode.io/problems/spiral-matrix)]]
- [Set Matrix Zeroes](https://neetcode.io/problems/set-zeroes-in-matrix)
- [Single Number](https://neetcode.io/problems/single-number)
- [Number of 1 Bits](https://neetcode.io/problems/number-of-one-bits)
- [Counting Bits](https://neetcode.io/problems/counting-bits)
- [Reverse Bits](https://neetcode.io/problems/reverse-bits)

[[2025-01-11|2025-01-11 Sat, 15:21]]
- [Plus One](https://neetcode.io/problems/plus-one)
- [[48. Rotate Image]]

[[2025-01-10|2025-01-10 Fri, 22:33]]
- [[202. Happy Number]]

[[2025-01-09|2025-01-09 Thu, 21:48]]
- [[56. Merge Intervals]]
- [[435. Non-overlapping Intervals]]

[[2025-01-07|2025-01-07 Tue, 22:11]]
- [[920. Meeting Rooms]]
- [[57. Insert Interval]]

[[2025-01-06|2025-01-06 Mon, 15:44]]
- [[45. Jump Game II]]
- [[134. Gas Station]]

[[2025-01-05|2025-01-05 Sun, 16:38]]
- [[53. Maximum Subarray]]
- [[55. Jump Game]]

[[2025-01-04|2025-01-04 Sat, 12:42]]
- [[494. Target Sum]]
- [[97.  Interleaving String]]

[[2025-01-03|2025-01-03 Fri, 23:28]]
- [[518. Coin Change II]]

[[2025-01-02|2025-01-02 Thu, 23:35]]
- [[309. Best Time to Buy and Sell Stock with Cooldown]]

[[2025-01-01|2025-01-01 Wed, 13:14]]
- [[213. House Robber II]]	
- [Unique Paths](https://neetcode.io/problems/count-paths)
	這題卡DP該怎麼實踐卡了一陣子。用數學的方式很簡單，用排列組合公式就可以了，但也是實踐上找規律卡住了。算法是`C m - 1 + n - 1 取 n - 1`
	後來我用wave的方式去解二維dp。看了解答發現一維就可以了。
- [[1143. Longest Common Subsequence]]

[[2024-12-31|2024-12-31 Tue, 21:35]]
- [House Robber](https://neetcode.io/problems/house-robber)
	這題因為練習區域我知道要用DP，所以我就將資料結構想成「紀錄目前位置最佳解」或是「包含此房的最佳解」。我想一想覺得後者比較簡單。後來實作時，第一次寫錯了，我用「紀錄目前位置最佳解」的方式存資料，卻用「包含此房的最佳解」邏輯回答問題。後來改成「包含此房的最佳解」後通過了。
	看了解答，應該也是可以將空間小化的（只需紀錄倒數三個？）

[[2024-12-30|2024-12-30 Mon, 21:28]]
- [Climbing Stairs](https://neetcode.io/problems/climbing-stairs)
	這是一題簡單的DP問題。解答影片中是很基本的從題目定義去講解，但我則是直接硬解。題目定義為「有幾種到n階的方式」。
- [[746. Min Cost Climbing Stairs]]

[[2024-12-29|2024-12-29 Sun, 13:58]]
- [Course Schedule II](https://neetcode.io/problems/course-schedule-ii)
	基本上就用[[207. Course Schedule]]的topological sort解就可以了。
	[[2024-12-31|2024-12-31 Tue, 23:04]]
	複習，矩陣粗心出錯`[i for i in range(num) if depended[i] == 0)]`
- [[1584. Min Cost to Connect All Points]]
- [[743. Network Delay Time]]

[[2024-12-28|2024-12-28 Sat, 16:18]]
- [Surrounded Regions](https://neetcode.io/problems/surrounded-regions)
	這題考graph的基本操作與對包圍的定義。因為cell只有可能是O,X，所以沒有被包圍的定義就是，最外圍的O有無碰到牆壁，有碰到牆壁就代表沒有被包圍。
	看了解答，這有更聰明的洞見。承上，有碰到牆壁就代表**沒有被包圍**，所以可以從牆壁往內找所有**沒有被包圍**的。剩下的都是被包圍的了。
	[[2024-12-31|2024-12-31 Tue, 22:53]] 
	複習寫錯了，原因是nr寫成nc。哭。
- [[207. Course Schedule]]


12/27 複習了10題anki。

[[2024-12-26|2024-12-26 Thu, 21:35]]
- [[417. Pacific Atlantic Water Flow]]

[[2024-12-25|2024-12-25 Wed, 21:45]]
- [Rotting Oranges](https://neetcode.io/problems/rotting-fruit)
	這題是Walls And Gates的變形。我目前得做法並不是直接在grid上面標記，而是另外用dict去紀錄從普通橘子到爛橘子所需要的最少步數，因為這題還需要紀錄是否有無法觸及到爛橘子的普通橘子。
	看了解答，我發現如果先一次都把爛橘子加到queue裡面，而不是個別執行bfs的話，就不用再另外紀錄最少步數了

[[2024-12-23|2024-12-23 Mon, 23:04]]
- [[133. Clone Graph]]
- [Walls And Gates](https://neetcode.io/problems/islands-and-treasure)
	這題我用的是dfs，解答給的是bfs，而且是從多個gate並發去搜尋的。這個方式應該會比dfs少掉一些步驟。

[[2024-12-22|2024-12-22 Sun, 14:34]]
- [[200. Number of Islands]]
- [[695. Max Area of Island]]

[[2024-12-21|2024-12-21 Sat, 17:06]]
- [Subsets](https://neetcode.io/problems/subsets)
- [[39. Combination Sum]]
- [[208. Implement Trie (Prefix Tree)]]
	我用了dict去紀錄，並且讓解答本身作為node結構（在leetcode上跑過後，只贏過12%）。在所有使用遞迴的地方，改用迴圈，效率應該會更好？

[[2024-12-20|2024-12-20 Fri, 22:25]]
- [Last Stone Weight](https://neetcode.io/problems/last-stone-weight)
	從題目分類來看，很快就往heap的方向去解了。看了解答之後，發現他用了一個叫「bucket sort」的算法來解，基本上會比較省時，可能會花多一點空間。
	這個sort的原理是：以元素中最大的數值+1作為bucket長度，每個bucket紀錄該元素存在的數量。演算過程是從最大值往最小值去計算。
	[[2024-12-27|2024-12-27 Fri, 23:14]] 複習了一次，下次可以試試bucket sort
- [[973. K Closest Points to Origin]]

[[2024-12-20|2024-12-20 Fri, 00:49]]
- [[703. Kth Largest Element in a Stream]]
	我知道這題要用之前的min heap來解，但是細節忘了。我以為不能從上往下去交換。實際有，這個動作叫做`sink`，相對於從下往上的`swim`。see [[Binary Heap]]

[[2024-12-18|2024-12-18 Wed, 21:32]]
- [Same Tree](https://neetcode.io/problems/same-binary-tree)
- [Subtree of Another Tree](https://neetcode.io/problems/subtree-of-a-binary-tree)
	這題解答給的是暴力解，`O(s*t)`。我想了一個減少不必要比較的版本，在leetcode上測試後，看起來快了很多，但是空間用的也很多
	[[2025-01-12|2025-01-12 Sun, 13:23]]
	複習，遞迴的部分突然搞錯，需要呼叫遞迴地方呼叫到另一個function了，卡了應該有20分鐘

[[2024-12-17|2024-12-17, 22:10]]
- [Diameter of Binary Tree](https://neetcode.io/problems/binary-tree-diameter)
	這題我用了會回傳兩個值的遞迴函式，一個是子樹高度，一個該樹的diameter。但看了解答發現，diameter大可以不用每個遞迴都比較，而是用一個遞迴外的變數存住最大diameter就好了
- [[543. Diameter of Binary Tree]]
- [[110. Balanced Binary Tree]]

[[2024-12-16|2024-12-16, 22:19]]
- [[226. Invert Binary Tree]]
- [[104. Maximum Depth of Binary Tree]]

[[2024-12-15|2024-12-15, 13:21]]
- [[141. Linked List Cycle]]
- [Reorder List](https://neetcode.io/problems/reorder-linked-list)
	這題我一開始有想到要用slow, fast，因為可以快速指到中間，但是後來覺得順序問題就不用了，改用stack。看了解答後，他說你只要把第二段list顛倒就好了。其實意外的單純，但是我沒想到。

[[2024-12-14|2024-12-14, 15:36]]
- [Reverse Linked List](https://neetcode.io/problems/reverse-a-linked-list)
- [[21. Merge Two Sorted Lists]]

[[2024-12-13|2024-12-13, 21:58]]
- [Binary Search](https://neetcode.io/problems/binary-search)
- [Search a 2D Matrix](https://neetcode.io/problems/search-2d-matrix)
	這題基本上就是應用兩次binary search。重點是我不夠熟悉lower_bound的用法

[[2024-12-12|2024-12-12, 21:41]]
- [[20. Valid Parentheses]]
	[[2024-12-17|2024-12-17, 22:40]] 這題常常會錯在stack沒有檢查長度
- [[155. Min Stack]]

[[2024-12-11|2024-12-11, 21:15]]
- [Best Time to Buy And Sell Stock](https://neetcode.io/problems/buy-and-sell-crypto)
	這題我一開始的想法一直傾向two index的方式（就是從頭尾接近），但想一想這行不通，因為index無從移動（index能靠什麼條件判斷去移動？）。後來想一下這是sliding window的題目，搜尋過程會持續關注一段範圍，才想出來。如何判斷題目是屬於這類型的應該會是重點。
	看了一下解題影片，這題**確實是要靠two index來解**，只是指的不是頭尾，而是從`[0, 1]`這樣的範圍開始的sliding window。
- [Longest Substring Without Repeating Characters](https://neetcode.io/problems/longest-substring-without-duplicates)
	[[2024-12-18|2024-12-18 Wed, 22:42]] 忘記字串有0長度的時候了
	[[2024-12-27|2024-12-27 Fri, 21:40]]
	下次可以試試解答的版本，用map去記該文字最後一次出現的位置。


[[2024-12-10|2024-12-10, 22:02]]
- [Valid Palindrome](https://neetcode.io/problems/is-palindrome)
	解這題就遇到一堆問題（用js）
	1. 字串處理  `s.replace(/[^a-z]/g, "")` 花了一些時間才搞懂
	2. 我突然打節，以為會有左右交錯的情況（破壞while的條件），但他們頂多就是重疊而已
	[[2024-12-12|2024-12-12, 23:31]]
	開始嘗試用python解。要注意的是 1. 我又忘記仔細看題目，要包含數字 2. python的倒數index 要多-1，也就是0對應-1
	[[2024-12-18|2024-12-18 Wed, 22:32]]
	python reverse 字串的方式太魔幻了：`s[::-1]`
- [Two Sum II Input Array Is Sorted](https://neetcode.io/problems/two-integer-sum-ii)
	反而沒有上面那題難，不過上面那題遇到的也是技術上的問題
- [[15. 3Sum]]

[[2024-12-09|2024-12-09, 21:30]]
- Contains Duplicate
	[[2024-12-28|2024-12-28 Sat, 17:24]] 複習時看了一下解答，有一個超秋的算法一行解決，比較set, list的長度
- Valid Anagram
- Two Sum
在解Two Sum時還遇到一個雷點，`for in` 的loop方式會使`i`變成字串

> [!NOTE]
> 在 JavaScript 中，`for...in` 是設計用來遍歷物件的可枚舉屬性名稱的語法。**物件的屬性名稱永遠是字串型別**（即使你使用數字作為屬性名稱，JavaScript 也會將它自動轉換為字串）。因此，當你用 `for...in` 來遍歷陣列時，得到的索引也是字串型別。

