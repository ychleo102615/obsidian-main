---
tags:
  - leetcode_easy
date: 2024-08-08
time: 23:09
---
[link](https://leetcode.com/problems/counting-bits/description/)
[Counting Bits](https://neetcode.io/problems/counting-bits)

[[2025-01-14|2025-01-14 Tue, 21:51]]
neetcode複習這一題。
大概因為昨天才解一個只問n有多少個1的問題，我想到「判斷此數是否為`2^n`」的方式就想到`n & (n - 1) == 0`這個方式。
但我還是用了一個額外變數去紀錄目前的`2^n`是誰。這樣還不如乾脆用影片解答的方式來去更新它。





```ts
function countBits(n: number): number[] {
	const ans: number[] = [];
	let leftestOneVal = 0
	for (let i = 0; i <= n; i++) {
		if (i >= leftestOneVal << 1) {
			leftestOneVal = i;
			ans.push(i > 0 ? 1 : 0);
		} else {
			ans.push(1 + ans[i - leftestOneVal]);
		}
	}
	  
	return ans;
};
```
我想的解。但是leetcode上面的[解](https://leetcode.com/problems/counting-bits/solutions/1808016/c-vectors-only-easy-to-understand-full-explanation/)更加單純。

概念上有很相似的地方，差別在：

遇到新的`i`值時，我取的是它從左邊第一個1之後右邊的數字（因為已經算過了）。
而解是直接將`i / 2`，並取 `i % 2`。這少了很多條件判斷。