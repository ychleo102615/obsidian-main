---
tags:
  - leetcode_medium
  - code_practice
  - Sliding-Window
date: 2024-08-24
time: 21:33
---
[link](https://leetcode.com/problems/longest-repeating-character-replacement/description/)
[Longest Repeating Character Replacement](https://neetcode.io/problems/longest-repeating-substring-with-replacement)

[[2025-03-30|2025-03-30 Sun, 15:02]]
為什麼我們可以只更新maxFreq，而不用每次都去找目前window內的maxFreq ？
因為題目只有要求我們找到更長的substring，而更長的substring只有可能在更新maxFreq的情況下找到。
我們會overestimate其他情況（因為maxFreq沒有隨著window變小），這代表l可能會停在原地，但這不影響我們找到更長的substring。
等到更新maxFreq的時候，maxFreq是目前window內正確的值，所以我們只要讓l符合題目條件後，就可以更新longest substring了。

[[2025-02-12|2025-02-12 Wed, 21:07]]
在判斷`l`指摽往右移動時，不需要檢查`l <= r`，因為另外一個檢查`r - l + 1 - maxFreq > k`已經包含這個概念了。


[[2025-01-21|2025-01-21 Tue, 22:22]]
練習neetcode，但是沒有想出來。我寫了一個應該是`O(n^2)`的解，在leetcode上跑會超時。
雖然有被提示是用sliding window，但是我覺得我的思考方向錯了。

我的解在每次輪替的時候，會換一個字母。這樣的做法會很浪費時間。譬如像ABA這樣的順序，輪到第三個A的時候，會重複很多遇到第一個A時做的事情。
我的思考侷限在我一定要確定這一輪的字母是誰，並且去操作。
而解答的定義是從這裡出發的：判定一個子字串是否為合法的 `length - maxFrequencyLengh <= k`。


--------


本來以為一定要用動態規劃來解題，用來發現是想得太多。

我用了這樣的資料格式：
```ts
track = [0, 1, 4, 5, 6]
```
偶數的位置：0, 2, 4代表著目前非字母的持續數
奇數的位置：2, 4 代表目前字母的持續數

實際上就是這樣：
```ts
s = "ABBBBAAAAABBBBBB"
```

但是這樣解出來的速度，遠比leetcode上的多數答案要低。



# [解答](https://leetcode.com/problems/longest-repeating-character-replacement/solutions/91271/java-12-lines-o-n-sliding-window-solution-with-explanation/)


> [!NOTE]- 
> 
> ```ts
> function characterReplacement(s: string, k: number): number {
>    let maxLen = 0;
>    const curCharCount = new Array(26).fill(0); // 目前window內的字母數量
>    const A = 'A'.charCodeAt(0);
> 
>     for (let end = 0, start = 0, maxCount = 0; end < s.length; end++) {
>         let char = s.charCodeAt(end) - A;
> 
>         // 同一個window內，最多的字母數量
>         maxCount = Math.max(maxCount, ++curCharCount[char]);
> 
>         // 如果window內的字母數量 + k < window長度，代表無法全部替換
>         // 這個瞬間，所能獲得的最大長度為 maxCount + k
>         if (end - start + 1 - maxCount > k) {
>             curCharCount[char]--;
>             start++;
>         }
> 
>         maxLen = Math.max(maxLen, end - start + 1);
>     }
> 
>     return maxLen;
> };
> ```

這題解答讓我想到[[300. Longest Increasing Subsequence]]，同樣都是尋找最長長度的問題，而他們的解法，都用到了sliding window的概念。