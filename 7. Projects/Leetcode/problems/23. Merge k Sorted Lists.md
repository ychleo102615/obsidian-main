---
tags: 
date: 2025-03-19
time: 21:34
---
[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
[Merge K Sorted Lists](https://neetcode.io/problems/merge-k-sorted-linked-lists)

### Time & Space Complexity
- Time complexity: $O(nlog⁡k)$
- Space complexity: $O(log⁡k)$
> Where k is the total number of lists and n is the total number of nodes across k lists.

[[2025-04-08|2025-04-08 Tue, 22:24]]
今天嘗試使用heap的版本，卻無意卡了一個無限循環。
這個問題還只會出現heap元素是相同的時候，這讓我苦惱了很久。
有問題的版本是使用heappushpop的時候。因為我希望可以合併這兩個操作。但是在遇到值相同的時候，我們無法保證舊的heap（本來的頂端）一定會被pop出來。最終會形成一個頭尾相連的linked list。

本質的問題，可能就是我錯以為pushPop也是先pop再push的，但他其實是先push再pop。

[[2025-03-23|2025-03-23 Sun, 09:33]]
想記錄一下，heap和divide and conquer的方式，都是O(nlogk)，n是所有linked list的size，k是有幾個linked list。
在leetcode跑過之後，發現divide and conquer跑的比較快

---

這題的概念不難，我是想到可以用heapsort來取最小的node來merge。
比較難的是怎麼使用heapq。

問了gpt，你要讓heap中的元素可以用`<`比較，所以要建立一個class實踐`def __lt__(self, other):`的方法。


看了解答，用的是另一種像是merge sort的方式來合併。
heap, merge這兩種的時間複雜度都是O(nlogk)。

gpt的比較：
- **當 `K` 很大時，`heapq` 仍然是最佳選擇**，因為它能夠維持 `O(log K)` 插入/刪除的效率。
- **當 `K` 較小但 `N` 很大時，Merge Sort 可能會更快**，因為順序存取對 CPU 來說更友善。