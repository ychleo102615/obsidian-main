---
tags:
  - leetcode_medium
date: 2024-01-25
time: 22:24
---
[link](https://leetcode.com/problems/recover-binary-search-tree/)

一開始的想法一直想比較節點本身與其相連的節點（parent, left child, right child），但從Example 2就可以發現，單純比較相連的節點，甚至有可能不會出錯。

現在想到的是用traversal的方式。採用[[Tree traversal#inorder|Inorder]]的方式。
從最左開始找，並持續記著最大的節點，遇到第一個比它小的點時，目前最大的點應該就在錯的位置上。
將最大的點設為剛剛第一個比它小的點，繼續尋找，會再遇到一個比最大的點小的點，該點應就是另一個錯的點了。






有成功解出來，但是忘記中間已經swap後要全部return了。