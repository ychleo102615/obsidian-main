---
tags:
  - Dijkstra
  - SPFA
date: 2025-01-27
time: 17:15
---
[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)
[Network Delay Time](https://neetcode.io/problems/network-delay-time)

[[2025-12-04|2025-12-04 Thu, 12:13]]
使用 ts 解題，卡在一個地方。
我使用 object 來記錄每個節點最快抵達的時間，用法是：
```ts
const arrive = {}
arrive[k] = 0
```

我錯的地方是做 relaxation 時，直接使用  `!arrive[v]`，我想這是因為當 `arrive[v] === 0` 時，也會視為 truthy，所以錯誤 relaxation 了。
```ts
// if (!arrive[v] || arrive[k] + w < arrive[v]) { // 錯誤版本！
if (arrive[v] === undefined || arrive[k] + w < arrive[v]) {
	arrive[v] = arrive[k] + w
}
```

[[2025-07-08|2025-07-08 Tue, 22:24]]
錯了兩次，雖然是錯在細節。
我這次是使用heap來實作dijkstra，不過效率並不好。
看之前提交的狀況，表現最好的SPFA變形的dijkstra，在解[[1584. Min Cost to Connect All Points]]有使用過。

> [!chatGPT]-
> **一、以 binary heap 實作的 Dijkstra（通常也叫 priority-queue Dijkstra）**
> 
> - **時間複雜度**：
>     
> 	   $O((E+V)logV)=O(ElogV+VlogV)=O(ElogV)$
>     
>     （因為通常 $E≥V$，故簡寫為 $O(ElogV)$）
>     
> - **為什麼是這樣算的？**
>     
>     1. **節點彈出（pop）**：總共要把每個頂點從 heap 裡取出一次，共 VV 次，每次皆為 O(log⁡V)O(logV)，合計 O(Vlog⁡V)O(VlogV)。
>         
>     2. **邊鬆弛（relax）**：每條邊在最壞情況下都會嘗試放入 heap 一次（即做一次 push），共 EE 次，每次 O(log⁡V)O(logV)，合計 O(Elog⁡V)O(ElogV)。
>         
>     3. 合併後就是 O((V+E)log⁡V)O((V+E)logV)。
>         
> 
> 你原本的說法「每條邊進 heap 一次，邊數是 EE，每次 heap 操作 O(log⁡V)O(logV)，所以 O(Elog⁡V)O(ElogV)」是對的，但還要加上「每個節點也要 pop 一次 O(Vlog⁡V)O(VlogV)」，合併後才是完整的 O((E+V)log⁡V)O((E+V)logV)。
> 
> ---
> 
> **二、用類似 Bellman-Ford 思路的實作**  
> 這裡有兩個常見的「不使用 heap 的最短路算法」要分清：
> 
> 1. **朴素 Dijkstra（用陣列或線性掃描找最小未處理頂點）**
>     
>     - 每圈要從所有還沒確定最短路徑的頂點中，線性找出距離最小者：O(V)O(V)
>         
>     - 這樣的選擇要做 VV 次，共 O(V2)O(V2)
>         
>     - 然後每次選出一個頂點後，要巡覽它的所有相鄰邊，總邊鬆弛工作為 O(E)O(E)
>         
>     - **總和**：O(V2+E)O(V2+E)，在稠密圖（E≈V2E≈V2）下簡化為 O(V2)O(V2)；在稀疏圖（E≪V2E≪V2）下會略優於 O(V2)O(V2)。
>         
> 2. **Bellman-Ford 演算法**
>     
>     - 不是 Dijkstra，雖然也能算最短路，但它做法是「對所有邊做鬆弛」共 V−1V−1 輪
>         
>     - 每輪鬆弛 EE 條邊，總共 O(VE)O(VE)
>         
>     - 較常用於含有負權邊的圖
>         
> 
> ---
> 
> ### 回顧與建議
> 
> - **正確名稱**：LeetCode 743 是最短路徑問題（Network Delay Time），對應的是 shortest-path tree，而不是 MST。
>     
> - **第一種解法**：精確為 O((E+V)log⁡V)O((E+V)logV)，通常簡寫為 O(Elog⁡V)O(ElogV)。
>     
> - **第二種不使用 heap 的 Dijkstra**：為 O(V2+E)O(V2+E)，簡化時多寫成 O(V2)O(V2)。
>     
> - **Bellman-Ford**：完全不同（O(VE)O(VE)），不建議和 Dijkstra 混用名詞。

[[2025-04-22|2025-04-22 Tue, 22:29]]
這題解了很多次，大部分都是使用Shortest Path Faster Algorithm(SPFA)，Bellman‑Ford 的 queue 優化版本。不過當初neetcode解答與chatGPT都是使用、建議使用Dijkstra 演算法。

| 特徵 / Feature | **SPFA**                  | **Dijkstra**                  |
| ------------ | ------------------------- | ----------------------------- |
| 適用邊權         | 允許負權 (No negative cycles) | 僅限非負權 (positive weights only) |
| 時間複雜度（最壞）    | O(V × E)                  | O((V + E) log V) using heap   |
| 時間複雜度（平均）    | 通常比 O(V × E) 快，但無保證       | 穩定 O(E log V)，特別在稀疏圖（E ≈ V）   |
| 是否保證最快出隊順序   | 否                         | 是（min-heap 保證每次取最短）           |
| 適合圖的類型       | 可能有負權的圖、邊數不太多的圖、稀疏正權圖     | 非負權、稀疏或密集皆可，特別是正權             |
| 是否容易卡無限循環    | 若有負環，會無限加入queue           | 不會（正權保證）                      |
| 簡單程度         | 比 Dijkstra 實作簡單一點         | 略微複雜，需要 heap                  |

這題第一次解是24/12/29。

今天解沒有用到mst，雖然在leetcode上跑起來時間沒有說壞很多，相對來說也少了heap pop O(logN） 的時間雜度吧），但空間上是有省的。