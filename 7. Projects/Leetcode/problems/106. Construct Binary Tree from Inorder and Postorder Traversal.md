---
tags: 
date: 2024-02-12
time: 22:07
---
[link](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)


[[2025-06-14|2025-06-14 Sat, 15:11]]
我會搞錯左子樹數量的計算。他是透過inorder第一個元素所在位置 減去 inorder根節點所在位置 來取得的。

[[2025-06-07|2025-06-07 Sat, 16:51]]
複習，納入 anki。

[[105. Construct Binary Tree from Preorder and Inorder Traversal]] 的**鏡像題**。

依照我的作法，只要順序改為由大至小，先處理右子樹，這樣就好了，程式碼幾乎沒變。

但老實說，一樣很難想像。看過105題的解答之後，我其實很想用那套方式解，畢竟比較好懂。

```ts
let pi = preodder.length - 1;
let ii = inorder.length - 1;
```
所以一樣的道理：
1. `ii, pi` 指到同一個node時，代表他**沒有右子樹**
2. 指到不同node時，`pi--; cur.right = build()`。pi-- 代表往右子樹移動
3. 沒有右子樹之後，要檢查有沒有左子樹。`i++; inorder[ii]` 沒被拜訪過的話，代表有左子樹
4. 有的話`pi--; cur.left = build()`