---
tags:
  - 1D-dp
date: 2025-02-28
time: 22:54
---
[322. Coin Change](https://leetcode.com/problems/coin-change/)
[Coin Change](https://neetcode.io/problems/coin-change)

這題需要找出能總合出目標值的最小的硬幣數量。

[[2025-08-18|2025-08-18 Mon, 22:42]]
嘗試使用dfs，還是錯了。可以說錯了不少次。

##### 第一次（有記錄）：
dfs傳入i, cur兩個參數，但是i是不必要的，我只是因為習慣而傳進去的。
因為題目說，每個數字都可以無限次使用，所以完全沒有必要傳i。

另外我沒有使用到「儲存子答案的解，來解出目前的問題」的這個DP技術，最後超時。

##### 第二次及其之後：
改為只傳cur之後，忘記考慮最基本的邊界，也就是當cur == 0時，要return。
還有一個細節是，就算`cur + coins[i] >= 0`的時候，要能夠往下找。我寫成`>`了。


[[2025-04-01|2025-04-01 Tue, 22:44]]
我發現我可能對這類的題目的了解還是不夠深入。
我看到題目後，沒想太多就想先用2DDP的方式來解，但這其實是1DDP的題目。
用DP table填表我還算得出來，但是用dfs的時候反而錯了。

| 題目             | 方法              | 狀態空間            | 時間複雜度             | 空間複雜度           | 是否可接受 | 備註          |     |
| -------------- | --------------- | --------------- | ----------------- | --------------- | ----- | ----------- | --- |
| Coin Change I  | DP 1D bottom-up | `O(amount)`     | `O(n * amount)`   | `O(amount)`     | ✅     | 最快且穩定       |     |
| Coin Change I  | DFS + memo      | `O(amount)`     | `O(n * amount)`   | `O(amount)`     | ✅     | 和 DP 效能接近   |     |
| Coin Change I  | DFS 無 memo      | `O(amount)`     | `O(n^amount)`     | `O(amount)`     | ❌     | 爆炸，TLE      |     |
| Coin Change II | DP 2D           | `O(n * amount)` | `O(n * amount)`   | `O(n * amount)` | ✅     | 可空間優化為 1D   |     |
| Coin Change II | DFS + memo      | `O(n * amount)` | `O(n * amount)`   | `O(n * amount)` | ✅     | 寫法直覺但需 memo |     |
| Coin Change II | DFS 無 memo      | `O(amount)`     | `O(2^n * amount)` | `O(amount)`     | ❌     | 指數增長，會 TLE  |     |

---

這題馬上讓我想到其他題目：[[518. Coin Change II]] 以及 [[39. Combination Sum]]。

很有趣的是，看了解答之後，演算法是一樣的，但是思路的來源是不同的。
我是因為解了上面那兩題後，才從相仿的算法轉換過來。
但是影片非常完整，他從greedy, backtracking, 再介紹到DP。
其中有個神奇的地方，就是本來是backtracking top-down的演算法，突然就可以轉成bottom-up的解法。

> [!Note]- chatgpt
> Top-down (遞歸 + 記憶化) 轉換成 Bottom-up (迭代 DP) 的方式如下：
> - **自頂向下**：
>     - 每次從 `amount` 開始，遞歸拆分為 `amount - coin`，直到 `0`。
>     - 需要 `memo` 記憶化來避免重複計算。
> - **自底向上**：
>     - 先計算 `dp[0]`，然後逐步計算 `dp[1]`, `dp[2]`, ..., `dp[amount]`，直接從已知狀態推出新狀態。
> 
> 這兩種方法**本質上計算的是同一個遞迴公式**：
> `dp[i]=min⁡(dp[i−coin]+1∣for each coin)`
> 只是：
> - **Top-down** 是從 `amount` 遞歸到 `0`，靠記憶化避免重複計算。
> - **Bottom-up** 則是從 `0` 開始填表到 `amount`，完全避免了遞歸的額外開銷。