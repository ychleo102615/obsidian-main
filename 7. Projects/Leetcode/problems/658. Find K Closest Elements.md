---
tags:
  - leetcode_medium
date: 2024-08-31
time: 15:32
cards-deck: leetcode
---
[link](https://leetcode.com/problems/find-k-closest-elements/description/)

# [658. Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/) #card
Binary Search






[[2026-01-19|2026-01-19 Mon, 17:34]]
## Binary Search 本質討論總結
^1768815575222

### 起點：LeetCode 658

你的解法（BS 找最近點 + 雙指針擴展）已是最優 O(log n + k)。

另一種更簡潔的思路：**直接搜尋窗口左邊界**。


```python
def findClosestElements(arr, k, x):
    left, right = 0, len(arr) - k
    while left < right:
        mid = (left + right) // 2
        if x - arr[mid] > arr[mid + k] - x:
            left = mid + 1
        else:
            right = mid
    return arr[left:left + k]
```

核心決策：「丟掉 `arr[mid]`，換取 `arr[mid+k]`，值得嗎？」

---

### 洞見一：Binary Search 的本質是單調性，不是排序

排序陣列只是單調性的一種實例。
```
Binary Search 真正的前提：
    搜尋空間上存在某種 F F F T T T 的分界

排序陣列 → 值的單調性
這題     → 決策優劣的單調性（窗口越過最優點後，優勢方向翻轉）
````

所以 Binary Search 可以應用在**任何具有單調性的抽象空間**，物理排序只是碰巧。

---

### 洞見二：Lower/Upper Bound 都是找「第一個 T」

差異不在演算法結構，而在 **predicate 的定義**：


```python
lower_bound: arr[mid] >= target  →  [F F F T T T]  → 第一個 T
upper_bound: arr[mid] > target   →  [F F F F T T]  → 第一個 T
```

「反轉」是語義層的調整，不是演算法層的翻轉。

---

### 洞見三：否定式確認

程式慣例是檢查「什麼時候要改變」，而非「什麼時候狀態正確」：
```
問：「是否應該往右移動窗口？」
    是 → 現狀不夠好 → 對應 F
    否 → 現狀可接受 → 對應 T

邏輯一致的問法應該是：
   「現狀是否可接受？」

但程式碼寫成：
    if 要改變:
        left = mid + 1   # 處理 F
    else:
        right = mid      # 處理 T
````

**我們檢查的是 F 的條件，但找的是第一個 T。**

這個語義錯位是 Binary Search 容易寫錯的根源之一。

---

### 兩種思維模型對照

| 條件模型 | 比較模型       |             |
| ---- | ---------- | ----------- |
| 核心問題 | 「這裡符合條件嗎？」 | 「左邊好還是右邊好？」 |
| 適用場景 | 找特定值、找分界點  | 最優化、選擇類問題   |
| 關係   | 基礎         | 條件模型的語義包裝   |

比較模型省去「翻譯成 predicate」的心智負擔，更貼近決策問題的本質。

---

### 一句話總結

> **Binary Search = 在單調性空間上，用否定式確認找第一個 T。**



---

光看題目以為又要使用heap sort了。
但仔細看完題目後，反而覺得題目相當單純，要用的是lower_bound或是upper_bound。


列出幾個例子想一想之後，我覺得可以用左指標跟右指標來尋找。
左指標：
```ts
left = low_bound(x + 1) - 1;
right = left + 1;
```
