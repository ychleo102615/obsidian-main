---
tags:
  - 2D-dp
date: 2025-01-03
time: 22:53
---
https://leetcode.com/problems/coin-change-ii/description/
[Coin Change II](https://neetcode.io/problems/coin-change-ii)

[[2026-01-19|2026-01-19 Mon, 23:28]]

```
dp[i] 代表的是有幾種組合，他們加起來等於 i？
```
為了避免重複計算，每次更新一種幣值。

---

本題要找出能總和出目標值的所有可能性數量。相較於 [[322. Coin Change]] ，這題需要使用二維DP，因為為了分別不同的組合。

[[2025-11-01|2025-11-01 Sat, 12:12]]
這題大概無法使用 top down 解。top down 之前跑成功過，但是同一組演算法不是每次都跑得過。
基本上應該就是 python overhead 太高了，即使 state 數量相同。

另外，我也思考了一下為什麼 i 不能回頭。這是因為要避免重複的組合，例如：
```python
[2,2,5]
[2,5,2]
# 如果開始從 5 找了之後還回頭找 2 ，就會出現重複的組合。
```

道理同樣要套用到 bottom up，也就是下面 10/17 錯的地方。

[[2025-10-17|2025-10-17 Fri, 22:20]]
```python
dp = [0] * (amount + 1)
dp[0] = 1

# 有重複問題
# for i in range(amount + 1):
	# for c in coins:
		# if i >= c:
			# dp[i] += dp[i-c]
			
for c in coins:
	for a in range(amount + 1):
		if a >= c:
			dp[a] += dp[a-c]

return dp[amount
```

我沒有想太多，先想出了上面的算法。
驗算答案不對，想了一下，發現這樣得出來的不是 combination ，是 permutation。


[[2025-03-14|2025-03-14 Fri, 22:21]]
練習試著從暴力解往最佳解演進。
我自己從dfs + while開始發想，但其實這個出發點能做到的優化還是不太好，bigO也是`O(2^n)`，頂多可以dp紀錄下來（這個解是leetcode倒數5%）。

問完gpt後，我覺得是結構問題。
下面的方式就不會重複許多次dp的呼叫了。
```python
def dfs(i, total):
    if total == amount:
        return 1
    if total > amount or i == len(coins):
        return 0
    if (i, total) in dp:
        return dp[(i, total)]
    
    # 兩種選擇：不選這枚硬幣 or 選這枚硬幣
    dp[(i, total)] = dfs(i+1, total) + dfs(i, total + coins[i])
    return dp[(i, total)]
 return dfs(0, 0)
```

---

[[2025-02-12|2025-02-12 Wed, 22:28]]
neetcode複習。
我印象中coins好像有必要由大至小排序來解，不過今天試了一下，好像是沒差的，重要的是每次都只新增一個硬幣，而不再考慮上一輪的硬幣了。

---

這題其實跟[[39. Combination Sum]]是一樣的題型，但是要求不同的output。

這題被歸類在2D DP，但我自己在想的時候，一開始沒有特別覺得是2D。直到感覺到應該要用
coins * amount 的資料來去的時候。
我自己算的方式比普通的2D來得複雜很多，我並不喜歡。我下次複習的時候應該就會忘記怎麼解的了。

解答影片中有畫出用更簡單的表格來表達概念。

| coin\amount | 5   | 4   | 3   | 2   | 1   | 0   |
| ----------- | --- | --- | --- | --- | --- | --- |
| 1           | 4   | 3   | 2   | 2   | 1   | 1   |
| 2           | 1   | 1   | 0   | 1   | 0   | 1   |
| 5           | 1   | 0   | 0   | 0   | 0   | 1   |
表格內的數字代表「**在使用包含大於等於此coin的狀況下，組合成各amount的可能性有幾種**」。
所以最簡單的是從5這個row開始著手，再往上慢慢算。


在下方影片中有個更簡單的演算。但要注意dp的計算時，是用著更上一層的解來計算後更新這一層。
```python
dp=[0]*(amount+1) 
dp[0] = 1 
for coin in coins: 
	for i in range(1, amount+1): 
		if i - coin >=0: 
			dp[i] += dp[i-coin] 
return dp[-1]
```