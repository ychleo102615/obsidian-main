---
tags:
  - 2D-dp
date: 2025-01-03
time: 22:53
---
https://leetcode.com/problems/coin-change-ii/description/
[Coin Change II](https://neetcode.io/problems/coin-change-ii)

本題要找出能總和出目標值的所有可能性數量。相較於 [[322. Coin Change]] ，這題需要使用二維DP，因為為了分別不同的組合。

[[2025-03-14|2025-03-14 Fri, 22:21]]
練習試著從暴力解往最佳解演進。
我自己從dfs + while開始發想，但其實這個出發點能做到的優化還是不太好，bigO也是`O(2^n)`，頂多可以dp紀錄下來（這個解是leetcode倒數5%）。

問完gpt後，我覺得是結構問題。
下面的方式就不會重複許多次dp的呼叫了。
```python
def dfs(i, total):
    if total == amount:
        return 1
    if total > amount or i == len(coins):
        return 0
    if (i, total) in dp:
        return dp[(i, total)]
    
    # 兩種選擇：不選這枚硬幣 or 選這枚硬幣
    dp[(i, total)] = dfs(i+1, total) + dfs(i, total + coins[i])
    return dp[(i, total)]
 return dfs(0, 0)
```

---

[[2025-02-12|2025-02-12 Wed, 22:28]]
neetcode複習。
我印象中coins好像有必要由大至小排序來解，不過今天試了一下，好像是沒差的，重要的是每次都只新增一個硬幣，而不再考慮上一輪的硬幣了。

---

這題其實跟[[39. Combination Sum]]是一樣的題型，但是要求不同的output。

這題被歸類在2D DP，但我自己在想的時候，一開始沒有特別覺得是2D。直到感覺到應該要用
coins * amount 的資料來去的時候。
我自己算的方式比普通的2D來得複雜很多，我並不喜歡。我下次複習的時候應該就會忘記怎麼解的了。

解答影片中有畫出用更簡單的表格來表達概念。

| coin\amount | 5   | 4   | 3   | 2   | 1   | 0   |
| ----------- | --- | --- | --- | --- | --- | --- |
| 1           | 4   | 3   | 2   | 2   | 1   | 1   |
| 2           | 1   | 1   | 0   | 1   | 0   | 1   |
| 5           | 1   | 0   | 0   | 0   | 0   | 1   |
表格內的數字代表「**在使用包含大於等於此coin的狀況下，組合成各amount的可能性有幾種**」。
所以最簡單的是從5這個row開始著手，再往上慢慢算。


在下方影片中有個更簡單的演算。但要注意dp的計算時，是用著更上一層的解來計算後更新這一層。
```python
dp=[0]*(amount+1) 
dp[0] = 1 
for coin in coins: 
	for i in range(1, amount+1): 
		if i - coin >=0: 
			dp[i] += dp[i-coin] 
return dp[-1]
```