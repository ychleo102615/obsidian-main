---
tags:
  - code_practice
date: 2024-04-25
time: 21:43
---
[link](https://leetcode.com/problems/longest-palindromic-substring/description/)
[Longest Palindromic Substring](https://neetcode.io/problems/longest-palindromic-substring)

[[2025-02-17|2025-02-17 Mon, 23:39]]
neetcode複習。前一天有從這個筆記複習一下演算法，但是今天實際上解題的時候還是嘗試先用暴力解。我甚至用另外一種資料結構，先記住所有相同字元的位置，再從這些位置去著手計算。
雖然有成功解出來，但這似乎沒有帶來太大的效率。

後來還是盡量回想這個演算法來解。在細節上錯了許多次：
1. 左右指標的更新錯誤
2. count可套用的範圍只在右界之內

---
# 最長回文字串

我有先靠自己的相法解出來，我怕當面對同樣字元的字串，如"aaaaaaaaaaaaaaaaaaaa"這種類型的測資時，會很浪費時間，我把字串parse一次，記錄成單一文字的`string`以及重複長度的`number[]`。
之後就是單純暴力的用迴圈走到哪，就從那裡中心展開比對。

逛解法時，發現有一個演算法：Manacher's Algorithm

# `Manacher's Algorithm`

這是看來看去，找到我個人比較好理解的[版本](https://cppext.com/?p=1743)

前置：將字串轉為必有奇數長度的回文
在所有字元間插入獨立符號：
```
aaa -> _a_a_a_
bbbb -> _b_b_b_b_
```

3. 建立最長回文長度列表，首個字符最大長度為1，獨立字符視為0。
~~2. 由左至右走訪，計算出最長回文長度的同時，同時可以更新目前位置**右邊**的列表（因為回文，左右對稱）~~
~~3. 當走訪的位置已經有之前算好的數字時，代表你可以跳過這個長度的比較（省略重複計算）~~

4. 由左至右走訪，當計算出目前範圍最大（伸到最右邊）的回文長度時，紀錄其中心及右邊邊界，此範圍內的回文是減去部分運算的
5. 當走訪的點在前述範圍內，可以知道在其右邊邊界內的回文檢測都是已經做完的了（可省略）


**需要再練習**