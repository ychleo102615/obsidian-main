---
tags: []
date: 2025-03-30
time: 16:34
---
[332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/)
[Reconstruct Itinerary](https://neetcode.io/problems/reconstruct-flight-path)

[[2025-08-24|2025-08-24 Sun, 11:53]]
今天解題時，特意不依靠記憶來解。讀過一次題目，從題目語意出發來解。

一直以為很簡單。但應該都是靠記憶。

我依然記得track追蹤的方法是在dfs的最後才加，但是我忘記為什麼要這樣做了。
因此我最一開始的想法還是在「先走這條路看看，如果走回來時，還有其他選項的話，代表走錯路了」。
這麼做很麻煩（相比印象中的解題方式），不但要標記哪個edge是用過了，還有可能要回退。

這麼想的時候，覺得這種做法很浪費時間。

所以想起來，**有沒有什麼方式不要浪費在試錯路線上？**

有的，因為在這題給的情況中，能走到端點的話，那他一定是最後一站。
所以走過的路不用浪費沒錯。
重點在分叉路線的那個點上，因為此時還有其他選項可以走，所以我們不確定該點為已走過。（他不是現在走）。
我們可以現去拜訪其他路線，直到找到另外一個「最後一站」（這應該就是剛剛的分叉點）。
找到最後一站，就可以確定路線了。

從遞迴的角度來說，分岔點會被走過其分岔次數（Y型的分岔就會被走兩次），只是第一次拜訪時，可能不會將之納入track中。

---

我的解法與正規解法的**Hierholzer’s Algorithm**有些落差：
在`track[]`插入目前機場的時機，我是一進來就先插入，演算法則是最後才插入。
他這樣的做法有個好處，他讓幾場順序倒過來（終點最先插入，起點最後），因為這題的演算法，你一定會走到一個終點再回傳，只是有可能你找到終點時，還有其他沒造訪過的點。所以倒敘的好處是，我們只確定從終點往回走的點，這樣即時先找到終點，也不會建立一個需要中途插入的順序。

```
1 - 2 - 3 - 4 - 5 - 6
            |
            -- 7 - 8
```