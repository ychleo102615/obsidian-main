---
tags:
  - 1D-dp
date: 2025-03-04
time: 23:54
---
[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
[Partition Equal Subset Sum](https://neetcode.io/problems/partition-equal-subset-sum)

[[2025-04-04|2025-04-04 Fri, 14:22]]

> [!NOTE]
> ## ✅ DFS 解法（Backtracking）
> DFS 的思路是從每個元素出發，嘗試「選或不選」的遞迴探索。
> ### 🧠 DFS 關鍵思路：
> - 把每個元素當成一個 decision point：「要不要選這個數？」
> - 嘗試所有可能的組合（即所有 subset）
> - 如果某條路徑總和等於 target，提早返回 True
> - 如果總和超過 target 或走到底，返回 False
> 
> ## ✅ DP 解法（0/1 Knapsack）
> DP 則是透過「記憶化」來避免重複計算，屬於 **bottom-up 或 top-down with memoization**。
> ### 🧠 DP 關鍵思路：
> 這是 0/1 Knapsack 的變形，每個數字只能用一次。
> #### 狀態定義：
> - `dp[i][j]`: 是否可以從前 `i` 個數字中挑出某些數，使得總和為 `j`
> #### 遞推公式：
> - 若不選第 i 個數：`dp[i][j] = dp[i-1][j]`
> - 若選第 i 個數：`dp[i][j] = dp[i-1][j - nums[i-1]]`

[[2025-03-15|2025-03-15 Sat, 14:23]]
練習邊自言自語邊寫題目。
我錯在了細節要使用的變數上，這可能是練習說話導致的。
但是逆序遍歷的寫法有對。

---

[[2025-03-08|2025-03-08 Sat, 15:52]]
neetcode複習，逆序遍歷的演算法寫錯了。
我稍微想了一下為什麼逆序能確保不重複，因為我們在做的是加法，如果今天
```
因為dp[2] == True，nums == 2，得以計算dp[4] = True時，
等到走到dp[4]時，又可以重複判定數字2，那就代表2這個數字被重複使用了。
```

---

[[2025-03-05|2025-03-05 Wed, 21:59]]
在翻解答的時候，發現有一個DP的解法，是與我最初嘗試的想法類似，用的是 [[39. Combination Sum]] 那樣的DP來解。但是程式碼結構不一樣，不同之處在於數字取了就不能重複使用，更像是下面的40題。
但我沒想到的是，這個結構調整完後，就能套用在「數字不能重複使用」的題目了。
這個方法是**逆序遍歷**，能確保不重複使用同一個數字。

參考[gpt](https://chatgpt.com/share/67c85a12-aaf8-8008-a1a7-bb6e923124ee)

---

解這題的時候會想到 [[40. Combination Sum II]] ，都是用不可重複的數字來計算目標總和。
後來我自己沒有想出來。

解答是讓我們去計算所有可能合，若有出現目標值則回傳True。
這個解法讓我想到 [[494. Target Sum]] ，都是把可能的合做成map或是set。


