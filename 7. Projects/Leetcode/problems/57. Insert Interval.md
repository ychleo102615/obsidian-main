---
tags: 
date: 2025-01-07
time: 23:24
---
[Insert Interval](https://neetcode.io/problems/insert-new-interval)
[57. Insert Interval](https://leetcode.com/problems/insert-interval/)

[[2025-01-09|2025-01-09 Thu, 00:19]]
```python
class Solution:
	def insert(self, intvls: List[List[int]], newInterval: List[int]) -> List[List[int]]:
		def intersect(a: List[int], b: List[int]) -> bool:
			return a[0] <= b[1] and b[0] <= a[1]

		l, r = 0, len(intvls)
		while l < r:
			m = l + (r-l)//2
			if intersect(intvls[m], newInterval) or intvls[m][0] > newInterval[0]:
				r = m
			else:
				l = m + 1

		while r < len(intvls):
			if intersect(intvls[r], newInterval):
				newInterval[0] = min(intvls[r][0], newInterval[0])
				newInterval[1] = max(intvls[r][1], newInterval[1])
				r += 1
			else:
				break
		# print(newInterval, l, r)
		return intvls[:l] + [newInterval] + intvls[r:]

```
最快的解都是走過每個點，有交叉的話就合併在newInterval，沒有的話就純粹複製。
我總覺得複製是浪費時間跟空間的，總希望用原array和binary search做出一個比較好的解。
上面的版本是有好一點，但是可能沒有最快解好。
intersect是有比解答多比較一個項目，可能是差在這裡？


這題乍看之下很簡單，我遇到了很多細節我想注意：

### 1. binary search 的邊界
`l, r = 0, len(list)` `l, r = 0, len(list) - 1` 的差異在於前者搜尋的範圍是開放的，他容許結果是len(list)，這有可能導致錯誤。

### 2. 合併時的邊界檢查沒處理好