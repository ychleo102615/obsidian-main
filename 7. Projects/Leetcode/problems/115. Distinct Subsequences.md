---
tags:
  - leetcode_hard
date: 2024-02-25
time: 21:38
---
[link](https://leetcode.com/problems/distinct-subsequences/)
[Distinct Subsequences](https://neetcode.io/problems/count-subsequences)

[[1143. Longest Common Subsequence]]

[[2025-10-29|2025-10-29 Wed, 10:01]]
我嘗試先猜測 top down, bottle up 哪種做法比較好。本來先猜 top down ，但是後來覺得這個題目有可能每個子狀態都會去拜訪，就又選了 bottom up。

後來檢查發現是 top down 比較好。我猜我沒想到的地方是：
```
s[i] 中無法找到與 t[j] 相符的字元，或是很晚才找到時，減枝的效果會非常好。
假設 s[k] 才找到，那代表 s[0~k]
```

[[2025-05-13|2025-05-13 Tue, 22:40]]
使用top down的寫法，發現這是最有效率的。我想這是因為：
1. s長度小與t長度時，子問題空間可被剪枝
2. 只有當s, t有字元相同時，才會擴展子問題空間。如果完全沒有相同字元的話，子問題空間甚至會從O(n^2) 降至O(n)

[[2025-04-05|2025-04-05 Sat, 17:51]]
填表的方式卡了挺久，畫圖並且試錯之後才發現DP的狀態轉移公式：
```python
if s[i-1] == t[j-1]:
	dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
else:
	dp[i][j] = dp[i-1][j]
```
DP本身代表的意義是「s的前i個字元中可以組成t前j個字元的組合數」。
所以當目前比對的字元相同時，代表我們可以額外利用 `dp[i-1][j-1]`的組合數，否則就只有`dp[i-1][j]`中記錄的組合數。

> [!NOTE]
> ## ✅ 建議
> - 要學習 DP 的時候，**先從「最原始最暴力」的 DFS 開始思考**
>     - 即使效率不高，也能看出狀態與遞迴轉移
> - 等你掌握轉換邏輯後，再思考：
>     - 可以用剪枝優化（像你現在的 loop）
>     - 或是用一維 / 滾動陣列優化空間

[[2025-04-04|2025-04-04 Fri, 21:51]]
neetcode練習。
解得還算順利，下次可以試試填表，以及思路講解。

---

在處理這題的時候，聯想到之前類似的題目，都是靠動態規劃解決的。
所以想好方向後，解決問題的架構很快就想好了。

卡了一陣子的地方是，ts二維陣列（或是二層map）宣告的不熟悉。我把第一維每個元素都指到同一個第二維陣列去了，所以值都會莫名其妙的被修改了。

一開始是用map來解，發現速度挺差的。看了一下解答，用陣列就可以了。