---
tags: 
date: 2024-02-21
time: 21:48
---
[link](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)

這題好好仔細想想，應該就可以解的出來。
我是畫了一下圖，想到這應該是用Divide & Conquer了。


---

之後看一下leetcode上面其他人的解答，看到了非常[精簡的解](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solutions/36977/my-short-post-order-traversal-java-solution-for-share/)。

這個做法，等於會先將右樹處理好，開始處理左樹時，會得到右樹的頭部。

```java
private TreeNode prev = null;

public void flatten(TreeNode root) {
    if (root == null)
        return;
    flatten(root.right);
    flatten(root.left);
    root.right = prev;
    root.left = null;
    prev = root;
}
```