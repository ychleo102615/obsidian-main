---
tags:
  - leetcode_medium
date: 2024-07-16
time: 23:01
---
[link](https://leetcode.com/problems/course-schedule/description/)
[Course Schedule](https://neetcode.io/problems/course-schedule)

[[2025-04-17|2025-04-17 Thu, 22:30]]
list comprehension 使用錯誤。
我本來ind這個變數常用的是dict，這次改用list寫：
```python
# wrong
q = [c for c in ind if ind[c] == 0]
# correct
q = [c for c in range(numCourses) if ind[c] == 0]
```


[[2024-12-28|2024-12-28 Sat, 16:58]]
用neetcode解題的時候，我直接是用DFS。在檢查這個筆記的時候，發現可以用用看拓樸排序，我已經忘記了。
看了下面貼的yt影片，他的算法是：
1. 找出所有沒有依賴數為0的節點到queue裡面
2. pop它，並將有依賴於它的其他節點減少依賴數
3. 如果有新增依賴數為0的節點，加到queue裡面
4. 重複直到queue清空且沒有節點遺漏

這題可以用DFS解出來，但是這種題目有更適合的解法：[拓撲排序](https://zh.wikipedia.org/wiki/拓撲排序)
[參考yt](https://www.youtube.com/watch?v=cIBFEhD77b4)

值得注意一下的是，拓墣排序中，依賴這個詞的含義，與程式架構的依賴是相反的。

```
1 -> 2 -> 3
```
拓墣排序中，1是沒有依賴的節點（他沒有incoming edges）。
但是以程式架構來說，1 依賴於 2。

拓墣排序常用來舉例現實的例子，如大學修課、穿衣順序等有**時間順序**的關係。
例如：穿鞋的動作依賴於穿襪子的動作。穿襪子要先。
```
穿襪子 -> 穿鞋子
```

但是程式架構就是相反的概念。
```
穿襪子 <- 穿鞋子
```

[leetcode 解答](https://leetcode.com/problems/course-schedule/solutions/3756938/beat-s-100-topo-c-java-python-beginner-friendly/)
解答中，依賴方向好像是搞反了，但是這不影響解題（DAG全部相反還是DAG）