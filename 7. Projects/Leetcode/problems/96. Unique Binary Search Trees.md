---
tags: 
date: 2024-01-14
time: 21:55
link: https://leetcode.com/problems/unique-binary-search-trees/
---
```ts
function numTrees(n: number): number {
    // structCount
    let stCount: number[] = new Array(n);
    stCount[0] = 1;
    let comb = 0;
    for (let i = 1; i < n; i++) {
        // if (i == 0) {
        //     continue;
        // }
        // let count = i + 1;
        // let subTreeSum = count - 1;
        // let subTreeSum = i;
        //console.log("in count:" + count);
        
        comb = 0;
        // count subTree
        // for (let j = 0; j <= i; j++) {
        //     // index is actual count - 1
        //     // let leftCount = (j-1 < 0) ? 1 : stCount[j-1];
        //     // let rightCount = (subTreeSum - j - 1 < 0) ? 1 : stCount[subTreeSum-j-1];
        //     // comb += leftCount * rightCount;    
        //     comb += ((j-1 < 0) ? 1 : stCount[j-1]) * ((i-j-1 < 0) ? 1 : stCount[i-j-1]);    
        //     //console.log("j: " + j + "/" + subTreeSum + " " + leftCount + "  " + rightCount);
        // }
        comb += stCount[i-1] * 2;
        for (let j = 1; j < i; j++) {
            comb += stCount[j-1] * stCount[i-j-1];
        }
        stCount[i] = comb;
    }
    //console.log(stCount);
    return stCount[n-1];
};
```

時間花的應該也有點久。速度最快只快過46%。就當作是誤差了。
討論區有個[解法](<https://leetcode.com/problems/unique-binary-search-trees/discuss/1565543/C%2B%2BPython-5-Easy-Solutions-w-Explanation-or-Optimization-from-Brute-Force-to-DP-to-Catalan-O(N)>)是套用數學公式的（[Catalan number](https://en.wikipedia.org/wiki/Catalan_number)），但我想這就不是重點了。

[[2024-04-30|2024-04-30, 11:09]]
發現光看上面的程式碼，無法了解解題邏輯。
看上面註解掉的部分之後，才懂。

這題可以用分治法解，目前數量的二元樹有多少種，可以分解成左邊子樹的種類數量 + 右邊子樹的種類數量，並且要記得左右子樹的數量從0 ~ n - 1這樣去對分，少的節點是根節點。

```
n = 5 的情況

0 4
1 3
2 2
3 1
4 0

首尾直接是 n-1
```

或許這題演算法，讓指標直接作為數量計算會比較好理解，就是一開始的陣列要宣告為`new Array(n+1)`