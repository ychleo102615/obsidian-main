---
tags:
  - AdjacencyList
date: 2024-12-29
time: 16:03
---
https://leetcode.com/problems/min-cost-to-connect-all-points/description/
https://neetcode.io/problems/min-cost-to-connect-points

[[2025-05-17|2025-05-17 Sat, 16:50]]
使用Prims's Algorithm，錯在一個細節。在更新mincost的時候，會使用新計算的dist。但是在計算下一個要納入的點時，不是使用dist，而是使用mincost。
dist只是用來計算可能更小的mincost而已。

[[2025-04-06|2025-04-06 Sun, 15:37]]
今天嘗試用 Prim's Algorithm (Optimal)的方式解。
- Time complexity: $O(n^2)$
- Space complexity: $O(n)$

卡在一個地方：我一直在想`cost[i]`要存的是什麼，是紀錄目前為止累積的cost，還是從最後一個點與此點間的距離？
都不是，他要記得的是最小的距離，不管從哪個點連接。

平常使用MST heap的版本是：
- Time complexity: $O(n^2log⁡n)$
- Space complexity: $O(n^2)$

---

[[2025-03-27|2025-03-27 Thu, 23:00]]
看了一下解答，下次可以試試用Bellman-Ford的方法 [[787. Cheapest Flights Within K Stops]]

---

[[2025-03-15|2025-03-15 Sat, 15:36]]
雖然有想到要用minheap來解答，但是初始的狀態寫的不漂亮，讓程式碼整體很冗。
關鍵在一開始：
```python
heap = [(0, 0)]
```
這樣就連初始化都可以在while迴圈搞定了。

---

這題是先在neetcode上看到記錄在leetcode裡面的。
剛剛花了一小時左右想怎麼解吧。我一直想要從任意的群組開始連線，等之後新加入點再優化。

但是看了解答後，他是用Minimum Spanning Tree的解，關於這個演算法我是完全沒有印象。
這個演算法挺單純的，了解之後就很好解。

1. 選定任意一點作為起點
2. 將該點與剩餘所有還沒拜訪過的點計算edge
3. 從所有edge中選最小的加入
4. 重複直到選完

注意這邊所有edge是使用minHeap來存，所以選最小的edge時，可能會出現已經訪問過的點。