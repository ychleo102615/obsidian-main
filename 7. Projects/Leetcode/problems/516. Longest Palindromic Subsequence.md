---
tags:
  - leetcode_medium
date: 2024-09-28
time: 15:33
---
[link](https://leetcode.com/problems/longest-palindromic-subsequence/description/?envType=problem-list-v2&envId=xixy4dq7)

> [!NOTE]- Problem
> Given a string `s`, find _the longest palindromic **subsequence**'s length in_ `s`.
> 
> A **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.
> 
> **Example 1:**
> 
> **Input:** s = "bbbab"
> **Output:** 4
> **Explanation:** One possible longest palindromic subsequence is "bbbb".
> 
> **Example 2:**
> 
> **Input:** s = "cbbd"
> **Output:** 2
> **Explanation:** One possible longest palindromic subsequence is "bb".
> 
> **Constraints:**
> 
> - `1 <= s.length <= 1000`
> - `s` consists only of lowercase English letters.


我先去複習了一下[[5. Longest Palindromic Substring]]。不過仔細看一下，這題應該更難，它可以決定遇到的字元要或不要。

想了許久，還是放棄，直接看[解答](https://leetcode.com/problems/longest-palindromic-subsequence/solutions/2980416/easy-to-follow-dp-with-explanation/)。看了之後不懂，問了chatGPT。

> [!Note]- ChatGPT
> LeetCode 516: Longest Palindromic Subsequence 的題目要求我們找出一個字符串中最長的回文子序列。這裡的 “子序列” 是指在保持字符順序不變的情況下，從原始字符串中刪除一些或不刪除字符後形成的新字符串，而 “回文” 則是指正讀和反讀都相同的字符串。
> 
> **解題思維**
>   
> 這道題的核心是動態規劃（Dynamic Programming, DP），因為我們需要在每個字符上作出決策，並且有很多重複子問題需要處理。
> 
> **1. 問題拆解**
> 
> 假設我們有一個字符串 s，並用兩個指針 i 和 j 分別指向字符串的左邊和右邊。那麼根據回文的特性，我們可以考慮以下情況：
> 
> • 如果 s[i] == s[j]，那麼最長的回文子序列至少包含這兩個字符，問題就變成考察子字符串 s[i+1...j-1] 的最長回文子序列，並加上這兩個相同的字符長度，即 2 + dp[i+1][j-1]。
> • 如果 s[i] != s[j]，我們需要選擇在 i 或 j 中刪除一個字符來縮小範圍，即考慮 s[i+1...j] 和 s[i...j-1] 的最長回文子序列，取兩者中的較大值。這就是 max(dp[i+1][j], dp[i][j-1])。
> 
> **2. 狀態轉移方程**
> 設 dp[i][j] 表示子字符串 s[i...j] 的最長回文子序列長度，我們可以得到以下狀態轉移方程：
> 
>   
> 
> • 當 s[i] == s[j] 時，dp[i][j] = dp[i+1][j-1] + 2。
> 
> • 當 s[i] != s[j] 時，dp[i][j] = max(dp[i+1][j], dp[i][j-1])。
> 
>   
> 
> 此外，邊界情況是當 i == j 時，dp[i][i] = 1，因為單個字符本身就是一個長度為 1 的回文子序列。
> 
>   
> 
> **3. DP 表格填充順序**
> 
>   
> 
> 我們需要從較小的子問題開始解決，逐步填滿 dp 表格。這通常意味著要從字符串的末尾開始進行迭代（因為需要用到 dp[i+1] 或 dp[j-1] 的結果）。具體地，我們可以讓 i 從大到小遍歷，j 從小到大遍歷，這樣保證我們在計算 dp[i][j] 時，dp[i+1][j] 和 dp[i][j-1] 已經被計算出來了。
> 
>   
> 
> **4. 初始條件**
> 
>   
> 
> • 當 i == j 時，dp[i][j] = 1（一個字符自身是回文）。
> 
> • 當 i > j 時，dp[i][j] = 0（無效情況，不會發生）。


