---
tags: 
date: 2025-01-09
time: 22:23
---
[435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)
[Non Overlapping Intervals](https://neetcode.io/problems/non-overlapping-intervals)

[[2025-03-26|2025-03-26 週三, 13:04]]
我希望能從比較直覺想法出發，所以我故意用sort by start的方式解。這讓我錯了好幾次。

sort by start不方便的地方在於，其實我們不需要關心start的排序，而是end的排序（只要我們是從前往後去訪問），因為就算早開始也有可能晚結束，而不能重疊的判斷方式就是要用之前的end來與後來的start比較

[[2025-02-28|2025-02-28 Fri, 16:53]]
anki複習。
我現在想這題，我會覺得我第一時間也無法好好解釋為什麼這個解可以行得通。
我想了一下，回想到之前應該是在yt留言區看到的說法：
把題目反過來思考，想想要怎麼排列，取得不會重疊的intervals的最大數目（本來是要刪除最少的intervals來讓剩餘的不會重疊）。
所以每次在取一個intervals時，應該從end最小的開始拿，這樣符合想要取得最大數目的目標。

---

[[2025-01-24|2025-01-24 Fri, 22:20]]
anki複習。
我把sort by start, sort by end的寫法都寫了一遍，他們的差異主要是：sort by start 時，我們無法確定目前的prev是一個重疊群組中最小的，要手動min()。但是sort by end則自然就依此排序好了。

另一種想法是，因為判斷是由前至後的，所以end的時間點是更為重要的依據。


---
[[2025-01-10|2025-01-10 Fri, 22:25]]
複習，幾乎是用背把答案寫出來。prev更新的判斷搞錯了。



這題我用硬幹的方式解，意外的是解答也是用同一套方式。
但在leetcode上跑的速度挺慢。

解題的核心是：重疊的線段，刪除比較右邊的那個。


leetcode上有一個解答，我覺得應該是更好的？
相比於neetcode解答，再少了幾個更新比較操作。
https://leetcode.com/problems/non-overlapping-intervals/solutions/3785409/beat-s-100-c-java-python-beginner-friendly/

```python
def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
	intervals.sort(key=lambda a:a[1])
	n = len(intervals)
	prev = 0
	count = 1
	for i in range(1, n):
		if intervals[i][0] >= intervals[prev][1]:
			count += 1
			prev = i
  
return n - coun
```

思路是反過來的：該怎填滿最多個non overlapping的interval