---
tags:
  - leetcode_medium
  - code_practice
date: 2024-05-26
time: 21:30
---
[link](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

[[2025-06-05|2025-06-05 Thu, 21:46]]
錯在邊界處理了。我印象中upper bound演算法就是「找到第一個大於目標值的位置」，但是我沒有想到**沒有找到的情況**。
upper bound沒有找到的話，代表沒有值大於目標值，所以當前的停留位置的值有可能 **等於或小於** 目標值。

我在lower bound時已經確保一定有找到等於目標值的位置，所以upper bound沒找到的時候，代表當前停留位置就是**右界**了。

---

這題感覺可以反覆練習，因為這題挺看重邊界處理的。

我一開始的想法是：先想辦法用二元搜尋法找到值後，**利用同一個迴圈**，繼續去找左右邊界。
寫來寫去，發現這樣會很複雜。
後來改採用找到值之後就break，另外用兩個迴圈找兩個邊界。


看了下[解法](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/3188625/best-c-2-solution-binary-search-linear-search-brute-force-optimize-one-stop-solu/)，應該是在考**二元搜尋的變化**。找不到值沒關係，甚至就是不用找到值，持續找到`left, right`交叉。

```cpp
int startingPosition = lower_bound(nums, low, high, target);
int endingPosition = lower_bound(nums, low, high, target + 1) - 1;
```

[[lower bound upper bound]]