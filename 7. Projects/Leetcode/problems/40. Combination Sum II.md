---
tags:
date: 2025-02-13
time: 00:16
---
[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)
[Combination Sum II](https://neetcode.io/problems/combination-target-sum-ii)

# Big O
- Time complexity: $O(n∗2^n)$
- Space complexity: $O(n)$

[[2025-11-28|2025-11-28 Fri, 11:03]]
與 3-28 犯了一樣的錯。
錯的原因：我以為在陣列中，只要與第一個數字比較是否相等。但是這麼做就 miss 掉例如這樣的狀況：
```python
[1, 3, 3, 3]
```
1, 3 不相同，所以 3 就被重複拜訪了。

[[2025-05-17|2025-05-17 Sat, 15:49]]
top-down 記得可以剪枝，因為是排序的資料，所以當`total + candidates[i] > target`時，就可以break了。

 [[2025-04-27|2025-04-27 Sun, 17:49]]
 leetcode練習，把bottom up, top down的方式都練了一遍，最後跑最快的是top down（迴圈優化）。

[[2025-03-28|2025-03-28 Fri, 22:25]]
這題用dp的方式我解得很快。
但是用DFS的時候，邏輯卡死在一個地方。
在避免重複納入數字的時候，我的比較對象設定該scope的第一個元素，但應該只要比對鄰近的元素就好
```python
# 我卡死的版本，這樣在處理例如 [1,1,2,2,3,3,4,4,] 的時候，除了1之外恐怕都會
for j in range(i, n):
	if j > i and candidates[j] == candidates[i]:
		continue
	dfs(j+1, total + candidates[j]

# 正確版本
for j in range(i, n):
	if j > i and candidates[j] == candidates[j-1]:
		continue
	dfs(j+1, total + candidates[j]
```

[[2025-03-10|2025-03-10 Mon, 21:40]]
使用在 [[416. Partition Equal Subset Sum]] 看到的逆序技巧，可以避免同一個硬幣多次使用。但是仍遇到問題：如果`coins = [2, 2]` ，這樣子會收集到 `dp[2] == [[2], [2]]`。所以dp改用set來儲存。

---

[[2025-02-19|2025-02-19 Wed, 21:58]]
neetcode複習。
我在複習了[解答影片](https://youtu.be/FOyRpNUSFeA?si=tp0tR1cpi121fSh-&t=168)一次。 
我們的目的是要去除重複的解。核心技巧在於當我們今天決定「**不再採用**」某個數字之後，我們在之後的可能性中也不可以再次考慮該數字，不然就會有可能重複。

---

這題卡了很久。我一直想要用2d dp 的方式去思考解，但是後來沒想出來，感覺資料節後會太複雜。

回歸backtracking，錯了兩次。一次錯在沒有先sort資料（我還多用set去紀錄，但是只要sort就能避免重複的問題）。第二次是超時，沒有考慮到像是這樣的case：
```python
[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
30
```

解答說，這會用到3Sum的概念，考慮相同的數字時要跳過多餘的計算：不取某數之後，下次就不會再考慮相同的數了。