---
tags:
  - leetcode_easy
date: 2024-06-05
time: 21:57
---
[371. Sum of Two Integers](https://leetcode.com/problems/sum-of-two-integers/)
[Sum of Two Integers](https://neetcode.io/problems/sum-of-two-integers)

[[2025-10-16|2025-10-16 Thu, 21:19]]
今天在解，突然卡住。

> ✅ 「在 Python 中，`-1` 會被表示成無限長的補數形式（無限個 1），而不是只有 32 個 bit。  
> 因此當它與 `0xffffffff` 做 AND 時，就相當於『把無限長的 1 截成 32 個 1』，結果變成 4294967295。」

換句話說：

| 語言                | -1 的內部二進位形態                           | 結果                |
| ----------------- | ------------------------------------- | ----------------- |
| Java (32-bit)     | `11111111111111111111111111111111`    | 固定 32-bit         |
| Python (無限延展)<br> | `...11111111111111111111111111111111` | 理論上無限長，遇 mask 才截斷 |


[[2025-03-26|2025-03-26 週三, 13:19]]
有一個洞見：bit XOR 1 相當於 ~bit ，所以和mask XOR 時等於是範圍限定的位元反轉。 

---

[[2025-01-16]]

這題有兩種思路：一種是一個bit一個bit慢慢每次算進位來求得結果，另一種是批量計算，使用XOR 和 AND。

另外補充

```python
x = 10
x = ~x
# x == -11
```
這個動作稱之為「取反」，數學數值上等同於`-(x+1)`。


python溢位的時候：
```python
if res > 0x7FFFFFFF:
	res = ~(res^0xFFFFFFFF)
```
這樣可以回復

算是踩了個雷，python只有在取反的時候，會逆轉符號解釋。

> [!chatgpt]
> `res = (res & 0xFFFFFFFF)` 这个操作的主要作用是将 `res` 限制为 **32 位无符号整数**，但**不会直接实现 32 位有符号整数的效果**。这是因为 `& 0xFFFFFFFF` 强制保留了 `res` 的低 32 位，而**未改变其符号解释**。

------

這題本質上不難，正統的做法應該就是用二進位bitwise來解。
花了一個半小時，時間應該是花在複習怎麼在`javascript`操作bitwise，還有理解一些特別bitwise操作技巧。

畫圖列舉仍是重要的理解方式。

# 1. 判定第幾位元上是1還是0
```ts
let isBitSet = function(num: number, n: number) {
    return (num & (1 << n)) != 0;
}

```
我一開始自作聰明，把判斷方式改為 `== 1`，結果就錯了。


# 2. 翻轉第幾位元上的值
```ts
num ^=  (1 << n)
```
記得任何數字 XOR 0 都不會改變其數值，所以在全部為0的位元組上特定位置改為1，就有翻轉該位置的位元的效果。


leetcode上有[更鬼畜的解和其他技巧](https://leetcode.com/problems/sum-of-two-integers/solutions/84278/a-summary-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently/)：
```cpp
int getSum(int a, int b) {
    return b==0? a:getSum(a^b, (a&b)<<1); //be careful about the terminating condition;
}
```
a&b 提供了哪邊需要進位的線索，這有點像不斷重複，直到 b == 0
就算 a 先成為 0，下一圈也會因 a&b 倒轉成 b 是 0。
這太巧妙了。


## 額外補充
### JavaScript 中 `>>` 和 `>>>` 的区别

1. **`>>` 带符号右移**：
    - 这个运算符保留符号位（最高位）。对于正数和负数，结果可能不同。
    - 负数的符号位（最高位）填充右移后的空位，确保结果仍然是负数。
    - 正数的空位用 0 填充。
2. **`>>>` 无符号右移**：

    - 这个运算符不保留符号位，总是用 0 填充右移后的空位。
    - 对于负数，结果将转换为一个较大的正数，因为符号位不保留。