---
tags:
  - leetcode_medium
date: 2024-09-02
time: 21:11
---
[link](https://leetcode.com/problems/reorganize-string/description/)

一開始的想法是：
走訪所有字串，計算其總數。
若最大的數量大於其餘總和+1，則無解，回傳""。
否則，按照這個計數map，輪流貼上char。


雖然解出來，但一直覺得這個解法很浪費計算時間。

想了一下，應該可以設計一個機制，走訪字串的同時，記錄需要被打斷的位置的queue，若走完時發現該queue還有剩，則代表無解。
**不對**，像是
```ts
s = "abcabczzz"
```
這樣的例子，會發現重複的字母都在後面，沒有新的字母可以替換。




在參考測資的結果回傳之後（測試會回傳一個合格的字串），思考了很久，不知為啥想出來了。
這是一個很幾何的想像過程：

在算完所有字母各有幾個之後，將他們群聚合併：
```ts
a * 3
b * 4
c * 5

combinedString = "aaabbbbccccc"
```
並且**對折！**
```ts
"aaabbb"
"cccccb"
```
如果就這樣兩兩交錯合併的話，扣除尾部的相同字母，那就可以得出解了！
這簡單，只要將第二排倒轉就可以了！
```ts
"aaabbb"
"bccccc"
```
答案就是
```ts
"abacacbcbcbc"
```

#### 反省：
我發現我有點執著在像這樣的例子：
`asdfasdfasdf`
這種輪番出現的字串，他們本來就是合格的，我一直想從這作為思考出發點。

結論是應該更從簡一點。
