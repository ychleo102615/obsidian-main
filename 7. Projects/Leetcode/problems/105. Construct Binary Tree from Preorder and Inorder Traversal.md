---
tags:
  - leetcode_medium
date: 2024-02-15
time: 09:17
---
[105. Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
[Construct Binary Tree From Preorder And Inorder Traversal](https://neetcode.io/problems/binary-tree-from-preorder-and-inorder-traversal)

[[2025-03-17|2025-03-17 Mon, 21:38]]
直接用python的範圍運算來丟似乎還是會影響效能不少，下次試試用左右指標的版本

---

[[2025-02-08|2025-02-08 Sat, 15:52]]
neetcode 複習
雖然有解過這題的印象，但是一開始還是一直嘗試使用迴圈去解。但這實在是太痛苦了。後來漸漸回想起來之前好像用利用邊界去divide and conquer來解，就有成功解出來。
這題還有一層優化，看了leetcode解答才發現。這是類似two sum的技巧。

---


# 下次請用divide and conquer練習

[[2024-02-12|2024-02-12, 13:12]]
昨天花了應該有一個半小時，沒想出來。後在在床上再用ipad繼續想，有稍微想出一個流程。

我會用兩個指標: `pi, ii` 來分析 `traversal`。
1. 當`pi, ii` 指到同一個node的時候，代表這個node**沒有左子樹**。
2. 所以指到不同node時，可以往左子樹繼續找：`pi++; cur.left = build()` 
3. 當確認沒有左子樹，或是左子樹已經分析完之後，要確認**有無右子樹**
4. `ii++;` 如果inorder的此時指到的節點已經拜訪過了，代表**沒有右子樹**
5. 有右子樹的話，`pi++; cur.right = build()`


隔天，也就是現在，花了應該也差不多一個半小時，有解出來。但是也不是完全理解為什麼會對，有點像賽到的。



```ts
class TreeNode {
    val: number
    left: TreeNode | null
    right: TreeNode | null
    constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {
        this.val = (val===undefined ? 0 : val)
        this.left = (left===undefined ? null : left)
        this.right = (right===undefined ? null : right)
    }
}

function buildTree(preorder: number[], inorder: number[]): TreeNode | null {
    let pi = 0;
    let ii = 0;
    let visited: Map<number, boolean> = new Map();

    function build(): TreeNode | null {
        if (pi == preorder.length) {
            return null;
        }
        // ("build ", preorder[pi]);
        let cur = new TreeNode(preorder[pi]);
        visited.set(cur.val, true);

        // ("find left");
        if (preorder[pi] !== inorder[ii]) {
            // left is not null
            pi++;
            cur.left = build();
        }

        // if (preorder[pi] !== inorder[ii]) {
        //     console.error("not expected");
        // }

        // ("find right")
        ii++;
        if (!visited.has(inorder[ii])) {
            // right is not null
            pi++;
            cur.right = build();
        }

        return cur;
    }
    return build();
};

```



leetcode上面的[解法](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34538/my-accepted-java-solution/)

我覺得我的程式碼更加單純，但反而不好理解。
leetcode上面的解釋很好懂，洞見也更加聰明：
今天得到的PR[], IN[]，PR[0]必定是當前的節點，我們可以在IN[]之中尋找這個節點。找出來之後，該值之前的索引值要給左邊的子樹，該值之後的要給右邊的子樹，以此類推。
這解法更有divide and conquer的精神。


[[2024-02-12|2024-02-12, 22:24]]
再更後來，解完[[106. Construct Binary Tree from Inorder and Postorder Traversal]]題之後，我又再瀏覽一下其他人的解，發現[這個解](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/34543/simple-o-n-without-map/)跟我的概念很像，但是更加的精簡優雅。

[[2024-06-22|2024-06-22, 15:36]]
順著[[How to serve Vue App with Express]]又來看這題。上面的解法是用一個stop，inorder走到的時候就要停止。