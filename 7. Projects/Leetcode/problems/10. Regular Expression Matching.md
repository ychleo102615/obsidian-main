---
tags:
  - 2D-dp
date: 2025-04-06
time: 21:11
---
[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)
[Regular Expression Matching](https://neetcode.io/problems/regular-expression-matching)

# Big-O
#### time $O(m*n)$
#### space $O(m*n)$

[[2025-05-24|2025-05-24 Sat, 17:33]]
這個測資會需要我們紀錄 dp
```
"aaaaaaaaaaaaaaaaaaa"
"a*a*a*a*a*a*a*a*a*b"
```

[[2025-04-30|2025-04-30 Wed, 22:47]]
錯在狀態轉移的細節：沒有星號卻又match的時候，轉移是：`res = dfs(i+1, j+1)`

[[2025-04-18|2025-04-18 Fri, 21:40]]
錯在有星星的時候，即使目前比對成功，也可以跳過目前的`s[i]`

[[2025-04-11|2025-04-11 Fri, 22:20]]
今天練習，有成功寫出2DDP table的方式來求解。但是效率比Backtracking的版本還差。
看了解答，赫然發現，dp的轉移公式還能再簡化一點點。

我原本以為，當有星號並且字元相通的時候，要考慮三種情況：
```
dfs(i, j) = dfs(i, j+2) or dfs(i+1, j) or dfs(i+1, j+2)
            *0             *1             *n
```
但實際上，考慮兩種就夠了，因為x1可能性會被包含在`*n` -> `*0` 的使用情況中。
```
dfs(i, j) = dfs(i, j+2) or dfs(i+1, j+2)
            *0             *n
```



[[2025-04-10|2025-04-10 Thu, 23:07]]
想要把邏輯簡化一點，但是反而出錯了很多次。
錯在：
1. s用完的時候，沒有考慮到p有機會用星星成為空字串
2. match 條件錯誤：
```python
i < len(s) and s[i] == p[j] or p[j] == "."
```
3. 少考慮到，有星星的時候，就算match也可以選擇跳過，也就是有這個可能`dfs(i, j+2)`

總結來說，會有四個狀況，用兩個布林值分成四個象限：
有沒有星星，有沒有match。
match本身就可以處理到s到盡頭的情況

---

有自己寫出大致的演算法，neetcode過了，但是leetcode錯在一個測資：
```
"a"
"ab*"
```
我這裡多做了容許 i == len(s)的處理。