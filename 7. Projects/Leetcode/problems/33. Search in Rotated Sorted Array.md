---
tags:
  - leetcode_medium
date: 2024-05-20
time: 20:48
---
[link](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)
[Search In Rotated Sorted Array](https://neetcode.io/problems/find-target-in-rotated-sorted-array)

[[2025-02-10|2025-02-10 Mon, 23:42]]
解這題的時候，明明有印象之前是要分成兩個狀態解，我還是做死先用普通二元搜尋的方式去解。
```python
if nums[l] <= target < nums[m]:
    r = m - 1
else:
    l = m + 1
```
我只做這樣的判斷，倘若rotated的位置剛好在左邊且target也在左邊，那這樣搜尋的範圍會往錯誤的另一半去找。

---

[[2025-01-30|2025-01-30 Thu, 21:56]]
neetcode 複習

---
### review
| 日期                                | 備註         |
| --------------------------------- | ---------- |
| [[2024-05-20\|2024-05-20, 23:45]] | 我想了三個小時... |


一個排序好的陣列，經過rotated（也可以理解為shifted）之後，你要在O(logN)的時間內找到目標值。



# 我忘記的，關於二元搜尋法的重點

## 1. 在縮減範圍時，要把middle value排除之外

```
left = middle + 1
or 
right = middle - 1
```
這是很重要的技巧，不然會發現while迴圈會卡住走不下去（left一直停留在同一個值）

## 2. middle index
middle = (left + right) / 2，偶數長度時，一般上都會取偏左的值作為中間值



> [!NOTE]- ans
> ```python
> class Solution:
>     def search(self, nums: List[int], target: int) -> int:
>         left, right = 0, len(nums) - 1
> 
>         while left <= right:
>             mid = (left + right) // 2
> 
>             if nums[mid] == target:
>                 return mid
> 
>             # Check if left half is sorted
>             if nums[left] <= nums[mid]:
>                 if nums[left] <= target < nums[mid]:
>                     right = mid - 1
>                 else:
>                     left = mid + 1
>             # Otherwise, right half is sorted
>             else:
>                 if nums[mid] < target <= nums[right]:
>                     left = mid + 1
>                 else:
>                     right = mid - 1
> 
>         return -1
> ```
