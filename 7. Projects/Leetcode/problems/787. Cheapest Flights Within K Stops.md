---
tags:
  - SPFA
date: 2025-02-22
time: 20:54
---
[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)
[Cheapest Flights Within K Stops](https://neetcode.io/problems/cheapest-flight-path)

[[2025-06-20|2025-06-20 Fri, 21:31]]
細節出錯了。第一次沒有檢查queue是否為空，第二次沒有按照queue的size去處理。

[[2025-04-25|2025-04-25 Fri, 22:56]]
錯在BFS的使用方式錯誤，我每次pop一個element時就增加step，但應該要是把當前的queue清空時，才算增加step。

[[2025-03-23|2025-03-23 Sun, 11:11]]
錯了，錯在沒使用temp去紀錄前一組costTable。

---

這題錯了兩次。我是先用MST解的。首先是我沒有考慮到一個node他的cost會更新，甚至變多，因為他需要的step更少。第二，盲目地讓所有在heap的資訊去做MST會使時間爆炸。
最後用的是visited會記錄目前的步數，除非步數更小，否則不能更新該cost。

解答說有另一個演算法叫Bellman Ford的方法。

| 演算法         | **Bellman-Ford（前者）**    | **Dijkstra + BFS（後者）**   |
| ----------- | ----------------------- | ------------------------ |
| **策略**      | **動態規劃**，遍歷所有邊 k+1k+1 次 | **優先隊列（BFS + Dijkstra）** |
| **時間複雜度**   | O(kE)                   | O(E+klog⁡E)              |
| **空間複雜度**   | O(N)                    | O(N+E)（存 heap + graph）   |
| **是否適用稀疏圖** | ✅ 是                     | ✅ 是                      |
| **是否適用稠密圖** | ❌ 較慢                    | ✅ 更有效率                   |
| **是否適用負邊**  | ✅ 可以                    | ❌ 不適用                    |
| **優勢**      | **簡單，適用於全圖最短路徑**        | **更快，適合這題**              |
| **缺點**      | **多餘的迭代，較慢**            | **稍微複雜，需管理 heap**        |
