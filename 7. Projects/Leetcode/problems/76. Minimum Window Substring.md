---
tags:
  - Sliding-Window
  - leetcode_hard
date: 2025-03-16
time: 22:10
---
[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)
[Minimum Window Substring](https://neetcode.io/problems/minimum-window-with-characters)

### Time & Space Complexity
- Time complexity: $O(n)$
- Space complexity: $O(m)$
> Where $n$ is the length of the string $s$ and $m$ is the total number of unique characters in the strings $t$ and $s$.

[[2025-04-30|2025-04-30 Wed, 21:59]]
我之前執著於一種寫法，就是當檢測到目前的s char不在t裡面的時候，我就會跳過，因為基本上我不需要計算該字元的數量才對。
但是在leetcode上跑過發現，這樣的效率並不好。
印象中，我後來問chatGPT，因為這樣的做法中間會跳過許多可以讓l前進的檢查點，所以不但沒有優化，反而減慢的速度。
### 分析「跳過非必要字元」會變慢的原因
- 在你的寫法中，**只有在 `c in tcount` 時才會更新滑動窗口的右邊界與 `scount`，這會導致左邊界 `l` 長時間停留不動。**
- 當左邊界不積極移動，會讓視窗變得「冗長」，導致每次符合條件的視窗都會更大、更不容易更新為更短的答案。
- 此外，跳過不是 target 的字元還會**影響視窗內子字串的收縮邏輯**。你只有在進入的字元是目標時才收縮，錯過了很多可以提早收縮的機會。


這題沒有演算法上的困難，但就是細節上處理要很注意。
我的算法是儲存smap, tmap各自記著需要字元的數量，如果smap所有的值都大於tmap，則window處於一個合法的狀態。
我花了很久的時間寫，中間細節一直搞錯，主要都是在smap與tmap數量關係之間的掌握。
例如當移動window左邊之後，發現smap tmap還是處於合法狀態，則window右邊不需要移動。 


看完了解答，程式的結構果然比我寫的單純很多。sliding 的 r是用for去訪問的，而l則是在window處於合法的狀態時去移動的。