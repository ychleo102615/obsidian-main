---
tags:
  - leetcode_medium
  - dynamic_programming
date: 2024-01-20
time: 22:52
---
[link](https://leetcode.com/problems/interleaving-string/description/)
[Interleaving String](https://neetcode.io/problems/interleaving-string)

# Big O
- Time complexity: $O(2^{(m+n)})$
- Space complexity: $O(m+n)$

[[2025-05-20|2025-05-20 Tue, 22:44]]
今天先用top down解，因為這會快很多。錯在了沒檢查初始條件。
之後用bottom up的方式解，但卡了一陣子。而且我用了沒效率的方式去初始化dp表格（當i, j == 0時，我比較了從0 ~ i, j的字串，但其實只要利用dp和比較目前的char就好了）


[[2025-04-06|2025-04-06 Sun, 14:36]]
今天嘗試與以往不同的DP寫法。之前的方式會在一個iteration中更新其他兩處，但總會覺得這是比較不可控的做法。
現在改成只更新目前關注的位置，這樣做的差異在於，前置作業要做的更仔細，也就是i, j == 0的場合。

---

[[2025-04-04|2025-04-04 Fri, 15:23]]
錯在長度檢查

---

[[2025-03-27|2025-03-27 Thu, 22:10]]
**I want to come up/derive with the algorithm for this for loop on the spot."**（我想要現場想出這個 for 迴圈的演算法。）

> [!NOTE]-
> 看到這個題目，首先可能會想到要使用暴力解，如果s1[i] == s3[i+j]就遞增i下去，但是很快發現你會需要回到之前比較的狀態（也需要檢查s2[j] == s3[i+j]的情況），而不是單純使用loop持續比對下去。 所以接下來我想到要用遞迴dfs with backtracking，他會接收I, j兩個參數，比較上述的兩個情形。 到這邊可以想像到，這會畫出一個decision tree，時間複雜度應該是O(mn log mn) m, n 各代表s1, s2的長度，這可能不算一個太好的解。我們可能會訪問到同樣的狀況，也就是同樣一組i, j之前可能檢查過了。 這可以用dp來記住，但是function call 的時間複雜度仍然很高。 對於像這樣的dp題目，其實可以轉換成2d table 的 iteration，只要你發現他的狀態轉移公式。 這題的話，應該是 if s1[i] == s3[i+j] then dp[I+1][j] = true , if s2[j] == s3[I+j] then dp[I][j+1] = true ，這樣的話，只要我們用二維迴圈去解，就可以得到dp[m][n]就是最終的答案。
> 
> 你的解析已經相當清楚，但有一些地方可以調整，使邏輯更流暢、表達更精確：
> ### **可改進的點**
> 
> 1. **「首先可能會想到要使用暴力解」**
>     
>     - 你可以明確指出「暴力解」指的是什麼（e.g., DFS without memoization）。
>         
>     - 例如：「最直覺的方法是使用 DFS 直接遞迴嘗試所有可能的 interleaving。」
>         
> 1. **「如果 s1[i] == s3[i+j] 就遞增 i 下去」**
>     
>     - 這裡應該強調 **i 和 j 不是單向推進的，而是有兩種選擇**，可以明確表達：
>         
>     - 例如：「如果 s1[i] == s3[i+j]，則我們可以選擇遞增 i。同理，如果 s2[j] == s3[i+j]，則我們可以遞增 j。」
>         
> 1. **「但是很快發現你會需要回到之前比較的狀態」**
>     
>     - 這句話可以更具體，比如：「然而，由於 interleaving 可能會有多種可能性，我們需要回溯來嘗試不同的組合。」
>         
> 1. **「所以接下來我想到要用遞迴 DFS with backtracking」**
>     
>     - 可以加強過渡：「為了避免錯誤地跳過可能的 interleaving，我們可以使用 DFS 來嘗試所有可能的選擇，並搭配 backtracking。」
>         
> 1. **「這會畫出一個 decision tree，時間複雜度應該是 O(mn log mn)」**
>     
>     - 這裡的 **時間複雜度可能需要再確認**。
>         
>     - **暴力 DFS 的時間複雜度應該是 O(2^(m+n))**，而加上 memoization 後應該是 O(mn)。
>         
>     - O(mn log mn) 這個估計可能不太對，建議檢查一下。
>         
> 1. **「這可以用 DP 來記住，但是 function call 的時間複雜度仍然很高」**
>     
>     - 可以稍微補充：「雖然我們可以使用 memoization 來減少重複計算，但遞迴本身仍然帶來額外的函式呼叫開銷，因此我們考慮轉換為迭代 DP。」
>         
> 1. **「對於像這樣的 DP 題目，其實可以轉換成 2D table 的 iteration，只要你發現它的狀態轉移公式」**
>     
>     - 這句話沒錯，但可以更精確表達：「這題其實可以轉換成 bottom-up DP，使用一個 2D table 來存儲狀態轉移，只要我們能找出正確的轉移公式。」
>         
> 1. **「這樣的話，只要我們用二維迴圈去解，就可以得到 dp[m][n] 就是最終的答案」**
>     
>     - 「二維迴圈去解」可以更明確，比如：「我們可以用一個雙層迴圈來填充 DP 表格，最終的答案將會是 dp[m][n]，表示 s1 和 s2 是否可以交錯形成 s3。」
>         
> 
> ### **總結**
> 
> 你的解析已經很好，調整的重點在於：
> 
> 1. **強化邏輯過渡**（e.g., 為什麼 DFS 會導致重複計算、為什麼轉 DP）。
>     
> 2. **時間複雜度的確認**（O(mn log mn) 可能不準確，可能是 O(mn)）。
>     
> 3. **讓 DP 的解釋更清晰**（轉換成 2D DP 時，狀態轉移公式可以更明確）。
>     
> 
> 你想試著自己改寫一次，還是要我幫你整理成更流暢的版本？
> 
> 4o
> 
> ##### 你說：
> 
> 我的第一部分暴力解其實不是要用DFS，而是一個解不出題目的while loop 而已。 幫我直接整理流暢版本英文版
> 
> ###### ChatGPT 說：
> 
> Here's a more refined and fluent version of your explanation in English:
> 
> ---
> 
> When approaching this problem, the first idea that might come to mind is a brute-force approach. We could try iterating through `s3` with a loop, checking if `s1[i] == s3[i + j]` and incrementing `i` accordingly. However, we quickly realize that this approach doesn't work because we may need to backtrack and check `s2[j] == s3[i + j]` as well. A simple loop won’t be sufficient to handle all cases.
> 
> Given this limitation, we can consider using a recursive DFS with backtracking. The function takes two parameters, `i` and `j`, representing the current positions in `s1` and `s2`. At each step, we check whether we can proceed using `s1[i]` or `s2[j]`, effectively forming a decision tree.
> 
> At this point, we can see that this approach results in a branching recursion, leading to a time complexity of **O(2^(m+n))**, where `m` and `n` are the lengths of `s1` and `s2`. This is inefficient because we may revisit the same `(i, j)` state multiple times. To optimize this, we can use **memoization** to store previously computed results and avoid redundant computations. However, recursive function calls still introduce overhead.
> 
> A more efficient way to solve this problem is by converting it into a **2D DP table**. The key is to identify the **state transition formula**:
> 
> - If `s1[i] == s3[i + j]`, then `dp[i + 1][j] = true`.
>     
> - If `s2[j] == s3[i + j]`, then `dp[i][j + 1] = true`.
>     
> 
> By filling in the DP table iteratively using a **nested loop**, we can determine whether `s1` and `s2` interleave to form `s3`. The final answer is stored in `dp[m][n]`.
> 
> 
> **"Introduce overhead"** 的意思是 **「引入額外的開銷」**，通常指的是 **增加計算成本、記憶體使用或執行時間**。
> 
> 在你的例子中，雖然 **memoization** 可以減少重複計算，但 **遞迴本身仍然會帶來函式呼叫的額外開銷（overhead）**，例如：
> - **函式呼叫成本**（每次遞迴都會有額外的 call stack 操作）
> - **額外的記憶體使用**（遞迴深度影響 stack size）
>     
> 
> 所以這句話的意思是：「雖然我們可以用 DP（memoization）來記住計算結果，但因為還是使用了遞迴，這會引入額外的開銷。」
> 你可以這樣理解：
> - **Recursive approach with memoization** → 減少重複計算，但仍有函式呼叫的開銷（overhead）。
> - **Iterative DP approach** → 透過 2D table 直接計算，避免遞迴的 overhead，更高效。

 [[2025-02-14|2025-02-14 Fri, 23:49]]
 我記得解題的形狀，但是忘記解題的邏輯了。
 我一開始就想用一維DP的方式解，但是反而讓自己搞混。（或者是說我就是忘記怎麼解了）
 我以為每個iteration要更新的就是目前的位置。但這樣就很奇怪啦，為什麼我印象中會做`s1[i] == s3[i+j], s2[j] == s3[i+j]`這兩個比較呢？
 切換回二維DP的方式，就想起來怎麼解了。如果比對成功的話，就在該字串的維度延伸字串的可組成性（就像是`dp[i][j+1] = True`）。
 切記，dp記的不是「使用哪一邊的字串」，而是「**使用了這些字串後的結果**」。
 
 最後，一樣錯在沒有檢查字串的長度了。
 
 或許使用一維DP是很聰明，但是因此忘記了解題真正的邏輯就也太本末倒置了。
 下次先從二維DP開始解起來好了。

---

[[2025-02-01|2025-02-01 Sat, 17:02]]

錯了兩次：
1. 沒有檢查字串長度
2. 仍然搞錯i, j 的range

我很清楚i, j的定義了，但是range(len(s1) + 1)才對，這樣才能考量到s1本身長度為0的情況

---
[[2025-01-27|2025-01-27 Mon, 22:47]]
解不出來，就算我知道要用二維DP解。上次解出來應該是因為剛看完上題的解之後，才馬上聯想的過去...。

釐清DP代表什麼意義真的是至關重要。這個題目中用的2D DP 長度會比字串長度再加1，這正是因為DP代表的意義是「**`s3可否被s1中前i個字與s2中前j個字組成`**」，這題目中的定義包含著0。當i 或是 j為0的時候，代表s3使用的完全來自另一個字串。

```python
if i < len(s1) and s3[i+j] == s1[i]:
	dp[i+1][j] = True
if j < len(s2) and s3[i+j] == s2[j]:
	dp[i][j+1] = True
```

這段程式碼讓我挺搞不懂的，但是只要搞清楚DP的定義，你就會知道：
1. i < len(s1) 要比較這個的原因是要保證s1還沒被使用完畢，若已經使用完畢則不需與s1比較
2. `s3[i+j]`我一直有個疑問是，如果i, j個代表s1, s2現在要比較的字，那i+j怎麼會是s3目前最新的字呢？應該要會是i+j+1之類的吧？
	這裡就可以發現我對i, j的定義是不清楚的。i, j代表的是「**已經用完的字**」，剛好`s1[i]`代表的是下一個s1要比較的字元，所以才這樣寫的。


[[2025-01-04|2025-01-04 Sat, 13:45]]
用二維DP解，而且對這一題的印象還在，很快就解出來了。
下次可以試試不要用遞迴解。




這題想了應該有三四天了，現在還是沒有通過題目測試。

有兩個難點我還不知道怎麼克服，我處理好一邊之後，另一邊就有問題。
### 1. 過於龐大的搜尋範圍
```
aaaaaaaaaaaaaaaaaaax
aaaaaaaaaaaaaaaaaaay
aaaaaaaaaaaaaaaaaaayaaaaaaaaaaaaaaaaaaax
```

### 2. 複雜行走路徑
```
s1: aacaac
s2: aacaaeaac
s3: aacaacaaeaacaac
```
像是這樣，有沒有可以聰明的方式，而不是窮舉？




[[2024-01-21|2024-01-21, 14:45]]
我之前都是只靠遞迴硬解。
後來透過畫圖，偶然想起可以用動態規劃的方式處理。

two dimensional array
二維陣列
> [!code]- code
> 
>```ts
>let visited: boolean[][] = Array.from(Array(s1.length+1), ()=> new Array(s2.length+1).fill(false));
>
>```



[^1]: 
