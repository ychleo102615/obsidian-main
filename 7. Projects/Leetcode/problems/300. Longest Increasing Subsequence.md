---
tags:
  - leetcode_medium
date: 2024-08-03
time: 16:09
---
[link](https://leetcode.com/problems/longest-increasing-subsequence/description/)
[Longest Increasing Subsequence](https://neetcode.io/problems/longest-increasing-subsequence)

[[2025-03-26|2025-03-26 Wed, 21:05]]
錯在愚蠢至極的地方，binary search沒有用到 middle的值來比較。

[[2025-03-04|2025-03-04 Tue, 22:16]]
neetcode複習。我在想最優的解法要怎麼解釋給別人聽，才會比較好懂。

最優解最奇怪的一個地方，就是你有能會搜集到一個不存在sequence，即使他的長度就是目前最長的LIS。~~這邊我覺得可以切進來說，max LIS就直接用一個變數去記就好了，而sequence每次遇到新數字時，都需要把所有大於等於新數字的的sequence內容都刪除掉。這樣就很像 [[739. Daily Temperatures]] 這題。~~
後來發現這是不行的，例如：
```
0 1 2 0 3
```
當遇到第二個0的時候，如果把兩個0之前的數值都刪掉，就會找不到LIS: `0 1 2 3`。

---

[[2025-03-02|2025-03-02 Sun, 14:25]]
neetcode練習。他給的解答是O(n^2)的解，是使用DP由後往前算的方式。
他說這是一個你比較能夠期待一個人在面試中想出來的解。

---

我自己有想出O(N2)的解，但是卡在無法從本來的想法轉到O(nlogn)

下方的解是參考leetcode上的解後，去問chatgpt的。

[[lower bound upper bound]]


[leetcode 解答參考](https://leetcode.com/problems/longest-increasing-subsequence/solutions/1326308/c-python-dp-binary-search-bit-segment-tree-solutions-picture-explain-o-nlogn/)
> [!note]- chatgpt
> 我想問一下leetcode上面的題目300. Longest Increasing Subsequence。解答區中有一個解是這樣的：保持一個紀錄用array，稱之record，在走訪原array時，若新元素小於record的最尾值，就使用二元搜尋record，使用新元素取代在record中，元素最小大於該值的位置。我想問的是為什麼可以這樣做，為什麼不會出問題？
> 
> ChatGPT
> 
> 题目300. Longest Increasing Subsequence 的这个解法实际上是一个动态规划与二分查找相结合的方法，其核心思想是维护一个递增序列的数组 `record`，并通过二分查找来优化插入位置，从而达到 O(nlog⁡n)O(nlogn) 的时间复杂度。具体的做法如下：
> 
> 1. **初始化一个空的 `record` 数组**，用于记录当前的递增子序列。
>     
> 2. **遍历原数组 `nums` 的每一个元素**：
>     
>     - 如果当前元素大于 `record` 数组的最后一个元素，则将当前元素追加到 `record` 数组的末尾。
>     - 否则，使用二分查找找到 `record` 数组中第一个大于等于当前元素的位置，并将该位置的元素替换为当前元素。
> 
> 这样做的原因和不会出问题的原因可以通过以下几点解释：
> 
> 1. **`record` 数组始终是一个递增数组**：每次遍历原数组时，我们都保持 `record` 数组是递增的。如果当前元素大于 `record` 数组的最后一个元素，说明我们可以安全地将其添加到 `record` 的末尾，保持递增性。如果当前元素不大于 `record` 的最后一个元素，我们通过二分查找找到 `record` 中第一个大于等于当前元素的位置，并用当前元素替换它，确保 `record` 数组的递增性不被破坏。
>     
> 2. **替换操作不会影响最长递增子序列的长度**：替换操作实际上是在维护一个潜在的更优的递增子序列。例如，原本的 `record` 数组为 `[2, 5, 8]`，当前元素为 `4`，使用二分查找找到 `5`，然后将其替换为 `4`，得到 `[2, 4, 8]`。这样做的好处是，我们仍然保持了长度为3的递增子序列，但现在的 `record` 数组中的元素更小，更有潜力在后续增加更多元素。
>     
> 3. **最终结果的长度即为最长递增子序列的长度**：因为每次操作都在维护一个潜在的更长的递增子序列，所以 `record` 数组的长度即为原数组中最长递增子序列的长度。
>     
> 
> 具体实现如下：
> 
> python
> 
> 複製程式碼
> 
> `from bisect import bisect_left  def lengthOfLIS(nums):     record = []     for num in nums:         pos = bisect_left(record, num)         if pos < len(record):             record[pos] = num         else:             record.append(num)     return len(record)`
> 
> ### 解释
> 
> 1. `bisect_left(record, num)`：找到 `record` 中第一个大于等于 `num` 的位置。
> 2. `if pos < len(record): record[pos] = num`：如果找到的位置在 `record` 的范围内，则用 `num` 替换 `record[pos]`。
> 3. `else: record.append(num)`：否则，将 `num` 添加到 `record` 的末尾。
> 
> 通过这个过程，`record` 始终保持为一个递增的子序列，并且其长度即为最长递增子序列的长度。
 