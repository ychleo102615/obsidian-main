---
tags:
  - leetcode_medium
  - Trie
  - Bitwise
date: 2024-08-20
time: 22:29
---
[link](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/)

## 題目理解

給定一個整數陣列 `nums`，找出任意兩個數字 XOR 的最大值。

```
輸入: nums = [3, 10, 5, 25, 2, 8]
輸出: 28
解釋: 5 XOR 25 = 28
```


---


[[2026-01-18|2026-01-18 Sun, 10:04]]
想不出來。最後問 Claude。
有兩種解題思路。第一種比較直覺，使用 `Trie` 資料結構防止過於複雜的設計，是我一直想要嘗試的方式。第二種的靈感來自 bitwise operation，不夠了解的話，感覺是想不出來的。

### 第一種：Bitwise Trie

先建立所有數的 Trie 樹狀結構。之後對每一個數，透過 Trie 來找尋 XOR 最大值，所有最大值之中最大的就是解答。

找 XOR 最大值的方法是，對目標數值目前的 bit 取反，如果 Trie 中有的話就走，沒有的話就只能走另外一側。除了 leaf trie 不會有兩個子 node 都是 null 的情況。

### 第二種：Bitwise Greedy + HashSet

下面的筆記講的方法，但是我昨天看這個筆記也看不懂。
跟 Claude 討論過後，把它想成這樣的語意解釋：

我：
我不管實際上是哪兩個數字XOR得出的結果（甚至有可能是複數種組合可以得到，但也不重要），我只在乎目前的「最大值前綴」，所有組合當中有沒有人辦得到，有的話就保留（1），沒有的話就不變（0），直到最後。

> [!NOTE]
> ## HashSet 解法：你的理解是對的
> 
> 你說的正是這個解法的精髓：
> 
> > 我不管實際上是哪兩個數字 XOR 得出的結果，我只在乎目前的「最大值前綴」有沒有人辦得到
> 
> 這是一種**存在性驗證**的貪婪策略：
> 
> ```
> 第 31 位：能不能讓答案是 1xxxxxxx...？ → 檢查「存在性」
> 第 30 位：能不能讓答案是 11xxxxxx...？ → 檢查「存在性」
> 第 29 位：能不能讓答案是 110xxxxx...？ → 檢查「存在性」
> ...以此類推
> ```
> 
> 我們從不關心「是誰和誰」，只關心「有沒有人能達成」。一旦確認某個前綴可行，它就被「鎖定」，成為下一輪驗證的基礎。




---

這題想了很久還是只能想到暴力解，就去看解答了。

目前看下來，這個應該是最好的[解](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/91049/java-o-n-solution-using-bit-manipulation-and-hashmap/)。

有一個關於bitwise操作需要知道的事：
```
a ^ b = c
c ^ b = a
c ^ a = b
```
待補充


[[2024-08-22|2024-08-22, 21:51]]
程式的時間複雜度應該是`O(32 * n)`，也就是`O(n)`。

每個bit，由左至右檢查，**是否存在現階段最大的值**。
```ts
// round 1
mask = 10000000000000000000000000000000      
// round 2
mask = 11000000000000000000000000000000   
...
// round 32
mask = 11111111111111111111111111111111
```
mask顧名思義，在限定我們檢查的範圍，後面的值我們暫時不管。

### 檢查的方式
檢查目前最大的值（目前第幾回合，就有一個最大值，從左數來該回合的bit數的值，其餘bit為0。e.g. 前七回合的最大值可能長這樣：`1010101 - 0000000...`），其右界加上 `1`的話，這個值是否存在？
以例子來說，第八回合檢查的就是，前七回合的最大值 + `0000000 - 1 - 0000......`。
**我們要檢查**：`10101011 - 00000.....` **這個值有沒有可能被XOR出來？**
稱呼這個目標值為`C`。

走訪所有的數字（n個），擷取前面要檢查的bit數，得到一個 `prefix`。
```ts
// 將其中一個數字取前綴，可能長這樣
10110010 - 00000....
```
稱此前綴為`A`。

我們需要的是`C`，這個值要由`A`與另一外一個前綴值`B` XOR 得到。
`A ^ B = C`
透過上面補充的 bitwise知識，式子可以改成：
`A ^ C = B`
我們的目標可以改成：**檢查`B`存不存在！**

套用two sum的規則，用hashmap查找的話，只需要`O(1)`。

當然，這個`B`很有可能是找不到的，這個時候，目前最大的值就不會改變。
有沒有可能從頭到尾`B`都找不到？有的，這就是全部的值都是一樣的時候。