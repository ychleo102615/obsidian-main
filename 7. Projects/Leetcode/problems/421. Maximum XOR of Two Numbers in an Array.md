---
tags:
  - leetcode_medium
date: 2024-08-20
time: 22:29
---
[link](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/description/)

這題想了很久還是只能想到暴力解，就去看解答了。

目前看下來，這個應該是最好的[解](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solutions/91049/java-o-n-solution-using-bit-manipulation-and-hashmap/)。

有一個關於bitwise操作需要知道的事：
```
a ^ b = c
c ^ b = a
c ^ a = b
```
待補充


[[2024-08-22|2024-08-22, 21:51]]
程式的時間複雜度應該是`O(32 * n)`，也就是`O(n)`。

每個bit，由左至右檢查，**是否存在現階段最大的值**。
```ts
// round 1
mask = 10000000000000000000000000000000      
// round 2
mask = 11000000000000000000000000000000   
...
// round 32
mask = 11111111111111111111111111111111
```
mask顧名思義，在限定我們檢查的範圍，後面的值我們暫時不管。

### 檢查的方式
檢查目前最大的值（目前第幾回合，就有一個最大值，從左數來該回合的bit數的值，其餘bit為0。e.g. 前七回合的最大值可能長這樣：`1010101 - 0000000...`），其右界加上 `1`的話，這個值是否存在？
以例子來說，第八回合檢查的就是，前七回合的最大值 + `0000000 - 1 - 0000......`。
**我們要檢查**：`10101011 - 00000.....` **這個值有沒有可能被XOR出來？**
稱呼這個目標值為`C`。

走訪所有的數字（n個），擷取前面要檢查的bit數，得到一個 `prefix`。
```ts
// 將其中一個數字取前綴，可能長這樣
10110010 - 00000....
```
稱此前綴為`A`。

我們需要的是`C`，這個值要由`A`與另一外一個前綴值`B` XOR 得到。
`A ^ B = C`
透過上面補充的 bitwise知識，式子可以改成：
`A ^ C = B`
我們的目標可以改成：**檢查`B`存不存在！**

套用two sum的規則，用hashmap查找的話，只需要`O(1)`。

當然，這個`B`很有可能是找不到的，這個時候，目前最大的值就不會改變。
有沒有可能從頭到尾`B`都找不到？有的，這就是全部的值都是一樣的時候。