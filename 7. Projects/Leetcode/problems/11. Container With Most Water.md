---
tags:
  - leetcode_medium
date: 2024-05-10
time: 21:55
---
[11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
[Container With Most Water](https://neetcode.io/problems/max-water-container)

[[2025-02-25|2025-02-25 Tue, 22:36]]
今天想到了一個說法：
每次更新較矮側的height，這樣的演算法不會遺漏掉正確的解，是因為「**在這個步驟中，刪除掉的組合都不可能得到更大的解（與矮height組合的其他所有可能性）**」。
所以每個小步驟中都不會刪掉更大的可能性（它是一個valid的步驟），自然就可以漸漸的找大最大的組合。

[[2025-01-26|2025-01-26 Sun, 18:05]]
其中一邊柱子能夠更新的條件是：另一側的柱子要比它高。如果這個柱子在這個算法中，永遠沒更新過，代表另一側所有的柱子全都比它矮，自然更新是沒有意義的。

[[2025-01-20|2025-01-20]]
這題解了很多次。我現在的想法是，重點是如何去證明為什麼解答有效？

原因應該是：l, r 分別置於兩側，計算面積，取比較矮的一側去輪替。為什麼？因為如果拿比較高的那一側去輪替的話，**你永遠得不到更大的面積**，面積的高必為矮的那一側，輪替高的一側沒有意義。只有輪替矮的一側，才有可能找到更大的面積。


---

這題的算法，我迷糊中記憶還有點印象，所以比起完全不看解答解題（都已經破梗了），還不如把時間花在理解解答的上面。

算法很單純，就是用兩個指標指在最左側與最右側，每次都捨去比較矮的高度（往中間走一格），直到比對到中間。

比起記憶這個算法，更重要的是為什麼這個算法是可行的（怎麼證明？）

以下取自討論區：
The reason for this is simple. There is no reason to hang onto the pillar of the smallest size in the current range because in the next iteration, the overall width will decrease by one. Thus, a potential greater area will never be reached by hanging onto the smaller pillar, because even if another taller pillar is found by moving the pointer at the taller pillar, the area must always be calculated with the minimum of the two pillars. Due to the smaller width by decreasing the pointer range, the overall area will be smaller regardless. Thus, we can safely disregard the smaller pillar at each iteration.

計算後兩側的柱子圍起來的容積後，該怎麼尋找潛在更高的容積呢？
首先矮的柱子是必定可以捨棄的，因為目前的寬已是最大值，**使用目前的矮柱的話，不可能再從此測資中找到更大的容積了**。