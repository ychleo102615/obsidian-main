---
tags:
  - 1D-dp
  - Two-Pointers
date: 2025-02-23
time: 21:16
---
[647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
[Palindromic Substrings](https://neetcode.io/problems/palindromic-substrings)

[[2025-04-06|2025-04-06 Sun, 15:03]]
練習Manacher's Algorithm解的時候，有個環節出錯了：
```python
if rad > radius[i]:
    radius[i] = rad
    if i + rad - 1 > right:
        right = i + rad - 1
        for j in range(1, rad):
            radius[i+j] = radius[i-j]
```
這段程式碼中，最上面的判斷是多的。
我本來以為這是無妨礙的操作，但仔細想一下，因為目前的`radius[]`可能是錯的，像這樣跳過更新的部分可能是問題的所在。因為後續的複製時，可能使用到錯的radius了。


---

[[2025-03-22|2025-03-22 Sat, 20:52]]
記錄一下用Manacher's Algorithm解的方式。
這次跟以往不同的是，我參考了解答，讓整體結構更簡潔。
並且半徑的算法是「包含自己」，所以最後計算有幾個回文時，是用`radius[i] // 2`去計算。

[[2025-03-19|2025-03-19 週三, 13:33]]
回文迴圈條件判斷出錯，當當前字元不同時就得break了。

---

[[2025-03-02|2025-03-02 Sun, 12:01]]
錯在使用`count = min(radius[i], right - i) + 1`這裡沒有加一。
因為我的算法會在後面回退l, r，如果不一開始就加一的話，r甚至會倒退一。
但是這是題目與測資不符的原因。在leetcode上跑同一份code是過的。

---

[[2025-02-25|2025-02-25 Tue, 23:44]]
neetcode複習，但是用錯演算法了。

剛剛問了一下gpt，我說左右枚舉法`O(n^3)`直覺上跟中心擴展法`O(n^2)`應該有一樣的比較次數，他竟然回我你的直覺很敏銳，然後下面直接打臉我。我笑死www。

很簡單，我沒注意到的是，中心擴展法會省去重複的計算，例如`aaaaa`，若從最中間的a開始擴展到總長，總花費是`O(n)`。但是左右枚舉的話很明顯就是`O(n^2)`，中間的部分都是可以省去的重複計算。


---

這題用暴力解是可以的，但是在leetcode可以明顯看到比較沒有效率。
而既然這題在neetcode上歸類在1DDP，那就有更好地做法，
想到之前也是palindrome相關的題目用到的技巧：
1. 將字串統一換為基數形式（在包含頭尾的所有間隙插入額外字元）
2. 當比對完成一組回文後，在其範圍內的曾經計算過的回文（左半部），是可以套過去右半部的。但是要注意**不能超出這次回文比對的範圍**。

參考[[5. Longest Palindromic Substring]]

以上兩點我有做到，但是有幾個個細節做錯了。

ㄧ、total新增時，計算方式為`total += (count+1)//2`。這是觀察歸納出來的。

二、當本次回文比對範圍沒有超出目前已比對過的最右邊界，那不可以使用上述左半套用去右半的做法；或者是說即使想要套用，也要處理複雜的邊界範圍。

這個題目我就錯在這個範例：
```python
cbbbc

 0 1 2 3 4 5 6 7 8 9      # location
"* c * b * b * b * c"     # str
 0 1 0 1 2 5 2 3 ...      # count of location
```
我錯在這個3上面，他應該只能是1而已。
因為前一個點是2，我把5複製到了左邊，他改為計算`min(5, 9 - 6)`

另外，剛剛看了一下解過的palindrom題目，[[516. Longest Palindromic Subsequence]]這題很久沒解了，需要複習一下。