---
tags:
  - 1D-dp
  - Two-Pointers
date: 2025-02-23
time: 21:16
---
[647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/)
[Palindromic Substrings](https://neetcode.io/problems/palindromic-substrings)

#提取關鍵字 你不能越界


[[2025-12-22|2025-12-22 Mon, 12:53]]
```ts
function countSubstrings(s: string): number {
    s = "*" + Array.from(s).join("*") + "*"
    const n = s.length
    const rad = new Array(n).fill(0)
    let center = 0, right = 0
    let sum = 0

    for (let i = 0; i < n; i++) {
        // 利用對稱性初始化
        if (i < right) {
            rad[i] = Math.min(rad[2 * center - i], right - i)
        }
        
        // 擴展
        while (i - rad[i] >= 0 && i + rad[i] < n && 
               s[i - rad[i]] === s[i + rad[i]]) {
            rad[i]++
        }
        
        // 更新 right 和 center
        if (i + rad[i] > right) {
            center = i
            right = i + rad[i]
        }
        
        sum += Math.floor(rad[i] / 2)
    }
    return sum
}
```

[[2025-12-15|2025-12-15 Mon, 11:18]]

回想為什麼 rad + 1 會比較方便：

|                    | rad | rad + 1 | ans |
| ------------------ | --- | ------- | --- |
| `* / ""`           | 0   | 1       | 0   |
| `*a* / a`          | 1   | 2       | 1   |
| `*a*a* / aa`       | 2   | 3       | 1   |
| `*a*a*a* / aaa`    | 3   | 4       | 2   |
| `*a*a*a*a* / aaaa` | 4   | 5       | 2   |

今天卡這題卡了很久。我一樣是在默背題目解法。其中一個語意錯誤了。
「能夠將左邊的值更新到右邊的狀況，只有當 right 更新的時候」
right 更新代表我們可以確定：以現在的 i 作為中心，「左右有機會相等，直到 right」
陷阱在於，沒有更新 right ，僅僅因為在 i 的半徑內就把左值更新到右值，導致的錯誤。
參考下面的例子，第二個 b 把 5 複製到 `rad[6]` 的位置上，但是該值只有 1 而已。

```
abba
* a * b * b * a *
1 1 1 1 1 1 1 1 1
  2 1 2 5 2 1 2 1
            5
            💀
```

語意檢視的話，第二個 b 誤以為自己是中心軸，能夠複製左值到右值。
但是其實因為第二個 b 已經在另外某個更大的對稱中心軸的範圍之下，所以不行複製。

總結，最重要的是，我應該要先有以下的認知，才能使用這個演算法來解：

> [!NOTE]
> 能夠把左值複製到右值的本質：**在中軸的範圍內左右對稱**。所以我們只能保證在這個範圍內，複製的半徑值是有效的（最多不能超過範圍）。
>```
>C | a b a C a b a | X
>左邊的 b 的半徑值，複製到右邊之後，不可超過中央 C 的範圍
>```
> 


[[2025-04-06|2025-04-06 Sun, 15:03]]
練習Manacher's Algorithm解的時候，有個環節出錯了：
```python
if rad > radius[i]:
    radius[i] = rad
    if i + rad - 1 > right:
        right = i + rad - 1
        for j in range(1, rad):
            radius[i+j] = radius[i-j]
```
這段程式碼中，最上面的判斷是多的。
我本來以為這是無妨礙的操作，但仔細想一下，因為目前的`radius[]`可能是錯的，像這樣跳過更新的部分可能是問題的所在。因為後續的複製時，可能使用到錯的radius了。


---

[[2025-03-22|2025-03-22 Sat, 20:52]]
記錄一下用Manacher's Algorithm解的方式。
這次跟以往不同的是，我參考了解答，讓整體結構更簡潔。
並且半徑的算法是「包含自己」，所以最後計算有幾個回文時，是用`radius[i] // 2`去計算。

[[2025-03-19|2025-03-19 週三, 13:33]]
回文迴圈條件判斷出錯，當當前字元不同時就得break了。

---

[[2025-03-02|2025-03-02 Sun, 12:01]]
錯在使用`count = min(radius[i], right - i) + 1`這裡沒有加一。
因為我的算法會在後面回退l, r，如果不一開始就加一的話，r甚至會倒退一。
但是這是題目與測資不符的原因。在leetcode上跑同一份code是過的。

---

[[2025-02-25|2025-02-25 Tue, 23:44]]
neetcode複習，但是用錯演算法了。

剛剛問了一下gpt，我說左右枚舉法`O(n^3)`直覺上跟中心擴展法`O(n^2)`應該有一樣的比較次數，他竟然回我你的直覺很敏銳，然後下面直接打臉我。我笑死www。

很簡單，我沒注意到的是，中心擴展法會省去重複的計算，例如`aaaaa`，若從最中間的a開始擴展到總長，總花費是`O(n)`。但是左右枚舉的話很明顯就是`O(n^2)`，中間的部分都是可以省去的重複計算。


---

這題用暴力解是可以的，但是在leetcode可以明顯看到比較沒有效率。
而既然這題在neetcode上歸類在1DDP，那就有更好地做法，
想到之前也是palindrome相關的題目用到的技巧：
1. 將字串統一換為基數形式（在包含頭尾的所有間隙插入額外字元）
2. 當比對完成一組回文後，在其範圍內的曾經計算過的回文（左半部），是可以套過去右半部的。但是要注意**不能超出這次回文比對的範圍**。

參考[[5. Longest Palindromic Substring]]

以上兩點我有做到，但是有幾個個細節做錯了。

ㄧ、total新增時，計算方式為`total += (count+1)//2`。這是觀察歸納出來的。

二、當本次回文比對範圍沒有超出目前已比對過的最右邊界，那不可以使用上述左半套用去右半的做法；或者是說即使想要套用，也要處理複雜的邊界範圍。

這個題目我就錯在這個範例：
```python
cbbbc

 0 1 2 3 4 5 6 7 8 9      # location
"* c * b * b * b * c"     # str
 0 1 0 1 2 5 2 3 ...      # count of location
```
我錯在這個3上面，他應該只能是1而已。
因為前一個點是2，我把5複製到了左邊，他改為計算`min(5, 9 - 6)`

另外，剛剛看了一下解過的palindrom題目，[[516. Longest Palindromic Subsequence]]這題很久沒解了，需要複習一下。