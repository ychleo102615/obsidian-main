---
tags: 
date: 2025-03-20
time: 00:09
---
[4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)
[Median of Two Sorted Arrays](https://neetcode.io/problems/median-of-two-sorted-arrays)

[[2025-05-03|2025-05-03 Sat, 21:15]]
同時有粗心，也有邏輯錯誤的地方。
1. 前後比較的部分，是用`<=`的，而不是`<`
2. 二元搜尋的範圍，我稍微想了一下，用了較長list並使用half作為邊界。但其實仔細想一下，這樣並不保證另外一個list不會超出邊界，而這正是我們想要保證的事情。下面一個月前的筆記就有想通，但是現在的我反而沒有。所以最重要的原則應該是：「**不可超出邊界**」

[[2025-04-06|2025-04-06 Sun, 12:39]]
關於範圍的處理，我想了一個解釋。
當演算法處理完後，我們想要檢查edge cases。可能會發生問題的地方在於x, y是否會超出m, n。
我們有個限制是x + y < half。設想一個情況，len(num1) > len(nums2)，也就是說len(nums) < half。
在這個情況下，如果x == 0, y == half，y會超出n，因為half > n 。所以這裡處理的方式是，我們應該要在小的list上搜尋x, y。

[[2025-04-05|2025-04-05 Sat, 21:16]]
範圍算錯了。
我直覺的想法是讓nums1 是容量大的那一方，並且在0 ~ m 之間搜尋x。
但是這會有問題。我們希望讓搜尋的範圍不會出錯的話，反而是應該nums1處於小的一方，並搜尋0~m。
因為我們想要避免空字串的問題。如果有一方是空的，那找到的x 自然就是0

[[2025-03-20|2025-03-20 Thu, 22:32]]
二元搜尋的界定範圍卡了很久，也錯了兩次。
我最後的做法是在`[0, half]`之間尋找nums1中可以用的數量，但這個定義本來就怪怪的，應該要是`[0, m]`才對吧。

---

這題的概念，在看了neetcode的三個提示之後有抓到，但是沒有一個聰明的技巧的話，這題的條件判斷會很煩。

這個技巧是使用正負無限大代表邊界。