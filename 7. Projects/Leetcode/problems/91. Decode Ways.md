---
tags:
  - 1D-dp
date: 2025-02-28
time: 21:58
---
[91. Decode Ways](https://leetcode.com/problems/decode-ways/)
[Decode Ways](https://neetcode.io/problems/decode-ways)

[[2025-05-09|2025-05-09 Fri, 22:44]]
粗心錯

[[2025-03-02|2025-03-02 Sun, 12:13]]
今天改用dfs的方式試試看。錯在了二位數的條件判斷，我用的判斷是直接照抄我本來的迴圈寫法。

但是微妙的是，`10, 20`這兩個數字的判斷位置會不一樣。
迴圈寫法是在i指到0的時候處理，而dfs則是i指到1, 2的時候處理。
所以我原來的條件判斷`11 <= val <= 26`在面對10這個數值時會出錯。

---


[[2025-02-28|2025-02-28 Fri, 22:23]]
看完了解答，他是使用backtracking + dp來解。可能會比較沒效率，但是直覺好懂。
並且也給了一個我沒想到的優化，DP其實不用記住整個長度的記憶體，其實只需要兩個（就像 [[55. Jump Game]] 或是 [[213. House Robber II]] 那樣，我會用a, b兩個變數）。

---

看到這題，一開始的想法都蠻卡的，我甚至想要一次比對兩個數字來計算。
後來還是覺得這太複雜了。

我覺得後來想法的突破口是：

1. 我一次只專注在處理目前的字元：
	0 or 1-9 分開處理
2. 當目前的數字可以與前一個數字形成另一組答案時，寫個簡單例子把所有可能列舉出來。
	例如我舉了這樣的例子
	
```python
1, 1, 1, 1

# first 3
[1, 1, 1]
[11, 1]
[1, 11]
```
我會糾結於第四個1要怎麼使用dp來算出答案。當列舉出來的時候就會很好懂了，就是直接加起來。
```python

# from dp[i-1]
[1, 1, 1,   1]
[11, 1,     1]
[1, 11,     1]

# from dp[i-2]
[1, 1,   11]
[11,     11]

# 所以總共5個
```