---
tags:
  - leetcode_medium
date: 2024-05-18
time: 21:59
---
[link](https://leetcode.com/problems/min-stack/description/)
[Min Stack](https://neetcode.io/problems/minimum-stack)

[[2025-05-17|2025-05-17 Sat, 16:05]]
錯在還原stack的時候，沒有處理 top < 0 的狀況

[[2024-12-14|2024-12-14, 16:56]]
用anki複習，試著用只有一個stack的做法，但是卡了很久。
我有一個概念搞錯了，我一直以為「實際值 = min + stack」，但這不是恆常都是如此。

`stack > 0`
「實際值 = min + stack」

`stack == 0`，這代表對應的值 == min
「實際值 = min」

`stack < 0` ，代表min值更新，且這個差幫助我們得到上一個min
「實際值 = min」

[[2024-12-14|2024-12-14, 15:59]]
這題我只有想到用兩個stack的方式解（我還想出用index來記錄min value出現的位置的方式來解少index stack需要的空間）。但是更好的解是只需要一個stack。他透過讓stack記住表徵stack與min值的差來表示。這題的洞見是「**stack中的每一個元素都會對應一個min值**」。
我認為一個stack的解比上面筆記說的贏過99%還精簡。

這題一開始我還以為肯定題目搞錯了，我還以為必定需要O(logN)。
但仔細看題目，並沒有要求pop Min的方法，也沒有要pop head的方法。
也就是stack永遠只會在尾部變動資料（它是stack啊，廢話嘛），那stack在每個長度時的最小值，都可以在push, pop時算好。

我用了個叫 changingPoints的array來去儲存：最小值在stack的哪些長度時會被更新（更小的值被加進stack了）。

[這個解](https://leetcode.com/problems/min-stack/solutions/4923316/typescript-solutions-that-beats-99/)看起來很棒，贏過99%。計算量更少。

