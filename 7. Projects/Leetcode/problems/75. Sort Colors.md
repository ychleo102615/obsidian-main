---
tags:
  - leetcode_medium
date: 2024-06-14
time: 22:33
---
[link](https://leetcode.com/problems/sort-colors/description/)


[[2025-06-07|2025-06-07 Sat, 16:30]]

比較類似的演算法：quick select [[215. Kth Largest Element in an Array]]
## 🧠 核心邏輯：

你有三個區間要維護（可以想成區域變色）：
```
[0, l-1]      → 都是 0 （紅色區）
[l, i-1]      → 都是 1 （白色區）
[i, r]        → 未分類
[r+1, n-1]    → 都是 2 （藍色區）
```

- 當 `nums[i] == 0`：丟去最左邊，擴張紅色區，`l++`, `i++`
- 當 `nums[i] == 1`：它就屬於中間，跳過，`i++`
- 當 `nums[i] == 2`：丟去最右邊，`r--`，但 `i` 不動（因為換過來的值還沒看）

這就是為什麼你在交換 2 時不前進 `i` 的關鍵原因！

---

這題，之前解過但是忘了，我直覺想的解是：遇到0往左擺，遇到2往右擺。（看了Feb 25, 2023的解答，演算法是一樣的，c++ 100%）

看到解答有個更直接的，全部數一次，再全部覆寫上去。
這版本的寫入次數是`n`次，我的要用到swap，就算在已經sort好且均分的測資上跑，也要寫入`(4/3*n)`次，慢於解答。

還有另外一個解答，雖然看起來是用二維迴圈在跑，但實際上大部分的情況應該很少寫入（`0`很快就會到`i`的位置上）。有幾種顏色就需要`n-1`層迴圈來跑