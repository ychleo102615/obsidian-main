---
tags: 
date: 2025-04-01
time: 23:52
---
[Alien Dictionary](https://neetcode.io/problems/foreign-dictionary)
leetcode premium

### 📌總時間複雜度：
整體為 **O(M + N + E)**，其中：
- `M`: 所有字元的總數（用來遍歷字串）     試圖比對並找出edge所花費的時間
- `N`: 不同字母的個數（節點數）                 建立indegree, res 等資料結構的時間
- `E`: 有向邊數，最壞情況下每對字元之間都有一條邊，為 O(N²)      更新indegree的時間
一般來說若字母數量固定（26），則時間複雜度可以視為 O(M)。

[[2025-04-17|2025-04-17 Thu, 21:36]]
可能是因為一陣子沒解了，錯在了另外一個地方。（ind的檢查倒是還記得）。
當檢測到字元順序的時候，就要break。我卻把break寫在如果這個順序是新的時候才執行。

[[2025-04-11|2025-04-11 Fri, 23:07]]
錯在同一個地方。

[[2025-04-08|2025-04-08 週二, 13:35]]
錯在與之前一樣的地方。除了使用set之外，也要檢查當edge存在時，就不要增加indegree。

[[2025-04-03|2025-04-03 Thu, 15:02]]
複習的時候卡了一陣子，對於indegree的初始化我一開始很想要和比較同時做。
最後分開做了，簡單很多。
甚至看到更簡單的寫法
```python
adj = {c: set() for w in words for c in w}
```
解的時候也錯在一個地方，就是要檢測當這個edge存在時，就不要再增加他的indegree了。

---

這題想了很久。第一天在想的時候，我還想要用 [[146. LRU Cache]] 那樣子的double linked list來處理這個動態的排序關係。
```
a -> b
b -> c
a -> c
```
我們可能會遇到這種情況，我一直在想要怎麼整理成一個排序好的linked list。
還想說要用Trie。

結果是沒想出來，也沒時間想出來。
曾經有飄過 [[207. Course Schedule]] 跟這題很像的想法，但後來沒仔細去想。但結果這就是這題的解法。

後來第二天今天，在洗澡時想到，上面的單向圖關係，不就是 topolocal sort 要用的adjacency list嗎？就蠻確定這個想法是可行的。


最後寫題目錯了幾次。忘了幾種可能性：
1. 如果沒有登上adjacency list的話，他其實也要算rank == 0的點（代表可以隨時開始）
2. `"wrtkj","wrt"` 這樣的資料是不合法的，空字串要優先於非空字串

看完解答，意外發現topological traverse 可以用 post order DFS來處理，這與之前看到的 [[332. Reconstruct Itinerary]] 題目很像，只是這題不可以有cycle。