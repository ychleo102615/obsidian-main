---
tags:
  - 2D-dp
date: 2025-04-05
time: 22:47
---
[312. Burst Balloons](https://leetcode.com/problems/burst-balloons/)
[Burst Balloons](https://neetcode.io/problems/burst-balloons)
# Big-O
#### 
#### Time: $O(n^3)$
#### Space: $O(n^2)$

#### Divide-and-Conquer 且不記憶化
- Time complexity: $O(n∗2n)$
- Space complexity: $O(n∗2n)$

[[2025-04-22|2025-04-22 Tue, 00:12]]
今天被自己了雷了許久，而用chatGPT也找不出bug，最後來是自己找到的。
或許處理問題應該要用推理模型。

簡單說，我在嘗試bottom up的做法時，我一直執著於：
```python
if l == r:
	dp[r][l] = nums[l]
```
仔細想想這是個巨大的錯誤，因為我根本沒有乘上鄰居的值。

[[2025-04-08|2025-04-08 Tue, 23:59]]
嘗試使用用填


---

這題非常難。我沒有想出來。

最一開始的想法，用暴力解的話，我們要找的可能性會有$O(n!)$組，可以想像一個decision tree，每個節點有n個選擇，而且樹高為n。
就算用DP去記憶優化，需要的空間複雜度也是$O(2^n)$，每個氣球有已被刺破與還在的可能性。
這兩個都過於沒有效率了。

解答影片中的方式真的只能讚嘆了。

上面提到的暴力解方式，雖然有用到[[Dynamic Programming 動態規劃]]的精神：最適子結構與重疊子問題，但問題是這個子問題的空間過於廣大了。
解答反轉了我們一般正序的想法與子結構：**如果目前的氣球是最後刺破的話，最多可以得到多少錢？**

保證目前的氣球是最後刺破的話，那至少我們可以拿到該氣球數值的錢。
那剩下的呢？
這個目前的氣球會成會子問題的邊界值（這其實有點像題目給的小提示了，題目特意告訴你想像兩邊邊界外的數值是1，明明只要說我們不需要多做乘法就好了）。


> [!NOTE]
> 這裡的核心轉念就是：與其模擬**從前往後刺氣球的過程**（那會導致狀態難以維持），不如想：**如果我知道最後一個氣球是哪個，那我可以把子問題隔開！**

### 🧠 小技巧：如何想出這種解法？
這類題的常見特徵是：
1. **移除某元素會影響相鄰狀態** → 正向做難以維護狀態
2. **合併順序/刺破順序不唯一** → 倒序考慮「最後一步」能簡化問題
3. **區間型問題（左右邊界會變動）** → 嘗試用 `dp[i][j]` 來表示某範圍內的最優子解

#### 🧩 **矩形分割問題 / 區間動態規劃（Interval DP）**
像這題就是典型的區間型 DP，而類似思路還出現在：
##### 🎯 1.1. LC 1000. Merge Stones
- 類似 burst balloons 的劃分方式，不是考慮先合併哪兩堆，而是考慮最後一次合併是哪些區間。
##### 🎯 1.2. LC 1130. Minimum Cost Tree From Leaf Values
- 也是選一個元素當作**最後合併的根節點**，再遞迴左右子區間。

✅ **大多數區間型 DP 都有某種程度的「倒序遞推特性」**，因為它們的狀態轉移通常建立在「某個劃分點」或「最後一次操作」上。

### 💡 一個好記的判斷法則：
當你遇到一題問題：
- 是關於「一段範圍」的最佳解（ex: 範圍內合併、刪除、選擇）
- 每次操作都會影響剩下的內容（非獨立）
- 難以從前往後思考

那麼你就可以嘗試問自己：

> 「如果我知道這段區間的最後一步操作是什麼，那我能不能把它拆成兩個子問題？」

這就會引導你進入「倒序」+「區間 DP」的視角。