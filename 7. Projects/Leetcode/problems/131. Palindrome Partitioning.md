---
tags:
date: 2025-02-16
time: 14:38
---
[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)
[Palindrome Partitioning](https://neetcode.io/problems/palindrome-partitioning)

[[2025-09-18|2025-09-18 Thu, 22:24]]
產出「**所有有效分割方式**」，而這個過程本身就會有 **指數級數量的分支組合**（因為每個切點都可以切或不切）

這題的時間複雜度分析我比較不懂。
我一開始想要用看到迴圈就乘上N的做法，所以一開始會有$n^2$個檢查palindrome的空間，然後呼叫dfs，我就卡住了。

看了解答和問gpt，有分兩種，差異在有沒有使用DP預處理。

| 分析項目         | ✅ 無預處理版本                                           | ✅ 有預處理版本 (DP)                     |
| ------------ | -------------------------------------------------- | --------------------------------- |
| 🔸 建表成本      | 無                                                  | `O(n²)` 預處理 `dp[i][j]`            |
| 🔸 回文判斷成本    | `O(k)`（每次切割檢查 `s[i:j+1]` 是否為 palindrome）           | `O(1)`（直接查 `dp[i][j]`）            |
| 🔸 回溯總次數     | `O(2^n)`（與切法數量相關）                                  | `O(2^n)`（相同）                      |
| 🔸 回溯中每層時間   | 最壞每層切一段，花 `O(n)` 時間檢查 palindrome → 總體 `O(n * 2^n)` | 每層切一段，查表 `O(1)` → 總體 `O(2^n)`     |
| ✅ **總時間複雜度** | `O(n * 2^n)`                                       | `O(n² + 2^n)`                     |
|回溯堆疊空間|`O(n)`|`O(n)`|
|回文快取表|無|`O(n²)`|
|結果儲存空間（輸出）|`O(n * 2^n)`|`O(n * 2^n)`|
|✅ **總空間（含輸出）**|`O(n + n * 2^n)` = `O(n * 2^n)`|`O(n² + n * 2^n)`|

> [!有使用DP預處理]
> ## ✅ DP 解法的做法與時間複雜度
> 我們建立一個 `dp[i][j]` 表示字串 `s[i..j]` 是否為回文。DP 遞推式如下：
> `dp[i][j] = True if (s[i] == s[j]) and (j - i <= 2 or dp[i+1][j-1])`
> 解釋：
> - `j - i <= 2`: 表示只剩一個字元、兩個字元或三個字元時，只要頭尾相等即可視為回文（單字、偶數字元回文）
> - `dp[i+1][j-1]`: 表示如果中間子字串是回文，且兩端字元相等，那麼整段就是回文
> 
> ## ⏱️ 為什麼是 O(n²)
> - 外層：`i` 從 n-1 到 0（逆向，保證 dp[i+1][j-1] 先被處理）
> - 內層：`j` 從 i 到 n-1
> 
> 這樣總共處理了所有 i ≤ j 的組合，也就是上三角矩陣的 cell 數量，數量是：
> `(1 + 2 + 3 + ... + n) = n(n+1)/2 = O(n²)`
> 
> ➡️ 每個 cell 都是 O(1) 計算（因為前面算好了 `dp[i+1][j-1]`），所以總共是 O(n²)

[[2025-05-01|2025-05-01 Thu, 15:16]]
在解題過程中，~~有發現不需要使用DP（不是靠記憶，而是靠推導）~~
可以使用DP。

> [!NOTE]
> > **在一般測資下，「回文檢查本身很快」＋「非回文路徑很早就被剪枝」＝即使不做預處理，效能仍非常可接受。**
> 
> ## 🔁 再補強一下兩個核心點：
> ### 1️⃣ 回文檢查「實務上很快」
> - 雖然理論上是 O(k)，但大多檢查的都是長度 1~3 的子字串（常見 case: `"a"`, `"aa"`, `"aba"`）
> - 在 Python 這種高效語言裡，`s == s[::-1]` 是 native 實作，短字串 slice & 比對非常快
> ### 2️⃣ 剪枝效果強
> - 一旦某段不是 palindrome，就不會繼續延伸這個切法（即使你理論上可以切到末端）
> - 非回文路徑不會進入遞迴下一層，直接回退
> - 所以實際遍歷的「解空間」遠小於 2ⁿ
> 
> ## 🎯 附帶一個小提醒
> 你剛說的這點 **特別成立在一般輸入（例如隨機產生、非惡意測資）下**，但如果輸入設計成：
> `s = "aaaaaaaaaaaaaaaaaaa"  # 例如 20 個 a`
> 這時：
> - 每一段都是回文
> - 所有可能切法都會被試過
> - 每一段都會進入 DFS 的下一層
> ➡️ 這時 **預處理的優勢才會明顯**。Leetcode 的大型測資通常會考慮這種 corner case，但不是每一題都壓在效能上。

[[2025-03-03|2025-03-03 Mon, 21:59]]
這題想了一下能否有使用DP的時候。分析一下題目，他要列舉所有可能的回文子字串，時間複雜度無法更快。同樣的一組回文不會重複走過，所以也不需要用DP。

測試時有卡在l, r指標的更新。

---

[[2025-02-26|2025-02-26 Wed, 21:25]]

稍微思考了一下有沒有辦法使用中心擴展法。後來覺得會太複雜了還是作罷。
看了解答，發現還有DP的版本，因為的確這題會有同樣的palindrom區段會多次用到，可以避免重複運算。

---

這題沒有遇到什麼困難就有想出解法了。