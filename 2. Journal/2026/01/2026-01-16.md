---
tags: dailies  
date: 2026-01-16
create: 2026-01-16-Fri
time: 11:55
---
## 每日精華

#### NeetCode
- [[98. Validate Binary Search Tree]]
- [[269. Alien Dictionary]]
- [3798. Largest Even Number](https://leetcode.com/problems/largest-even-number/)
- [3799. Word Squares II](https://leetcode.com/problems/word-squares-ii/)
	這題我太想使用聰明的解法。但是到頭來還是用最暴力樸實的方式解出來。
	一開始有觀察到類似於對角線交換的關係，想說找出結果直接 `*2` 就可以解出來。
	嘗試一：用四層巢狀迴圈找出頭尾相同的路徑，但是沒有比對重疊，造成錯誤（我認為4條路徑，每每都需要檢查的話是 $C_4^6$ ，感覺太繁瑣）
	嘗試二：top, right, bottom, left 的路徑搜尋，但是與題目要求的不相符，而且還有 lexical order 問題
	嘗試三：top, left, right, bottom 的順序 DFS，有成功解出來
- [3800. Minimum Cost to Make Two Binary Strings Equal](https://leetcode.com/problems/minimum-cost-to-make-two-binary-strings-equal/)
	有點和上一題相反，感覺題目理解不足，用太笨的方式來解。
	一直想用 DFS + DP 解。這樣做的缺點是太複雜，而且時間複雜度很差
	1. `dfs(s: string, diff: Array<number>, cur)` cur 會與 dp 衝突，算出錯誤的解。感覺像是 top down, bottom up 打架的寫法 
	2. `dfs(s: string, diff: Array<number>)`  完整的 s ，但其實不需要 。中間還錯誤理解題目，以為 cross 有順便 swap。
	3. dfs (diff: string) 結果正確，而且很優雅。但是超時
	4. 這題的洞見在於，順序位置全部都不重要，重要的是不相同的 1, 0 的數量。也不需要 DP，沒有什麼前後相依性。直接依照不同的字元配對 cost 就可以了。只要一開始計算好兩個 bit 不相同時，swap 划算還是 filp 兩次划算，之後遇到 swap 時都用這個答案就好了： `Math.min(swapCost, flipCost * 2)`
	感覺花了我整個下午才解出來。
	我覺得我直覺都有往對的方式走，但是往往寫到一半卡住，又回頭用不好的舊解法。

### claude
#### 遇到「最小成本」題目時，先問這三個問題：

> [!NOTE]
> ### 問題 1：選擇之間是否獨立？
> 
> **思考過程：**
> 
> ```
> 假設有 4 個差異點：
> 位置 2: s1=0, s2=1 (需要 0→1)
> 位置 5: s1=1, s2=0 (需要 1→0)
> 位置 7: s1=0, s2=1 (需要 0→1)
> 位置 9: s1=1, s2=0 (需要 1→0)
> 
> 問：我先處理 (位置2, 位置5) 這一對，
>     會改變處理 (位置7, 位置9) 的成本嗎？
> ```
> 
> **答案：不會**
> 
> - 配對 A 的成本 = `min(swapCost, 2 * flipCost)`
> - 配對 B 的成本 = `min(swapCost, 2 * flipCost)`
> - 兩者完全相同，互不影響
> 
> **結論：獨立 → 指向貪心/數學**
> 
> ---
> 
> ### 問題 2：最優解由什麼決定？
> 
> **思考過程：**
> 
> ```
> 考慮兩個不同情境：
> 
> 情境 A: 差異在位置 [1, 3, 5, 7]
> 情境 B: 差異在位置 [2, 4, 100, 200]
> 
> 假設兩者都有 2 個 (0→1) 和 2 個 (1→0)
> 
> 問：最優解會不同嗎？
> ```
> 
> **答案：完全相同**
> 
> - 都是 2 對互補差異
> - 成本都是 `2 * min(swapCost, 2 * flipCost)`
> - 位置分佈不影響答案
> 
> **結論：純數量決定 → 不需要 DP**
> 
> ---
> 
> ### 問題 3：狀態轉移有沒有「累積效應」？
> 
> **對比背包問題：**
> 
> ```
> 背包問題：
> - 選了重量 5 的物品 → 剩餘容量減少 5
> - 後續選擇「受限於」之前的選擇
> - 這就是累積效應
> 
> 這題：
> - 處理完一對差異 → ???
> - 後續配對的成本 → 完全不變
> ```
> 
> **答案：沒有累積效應**
> 
> - 沒有「剩餘資源」的概念
> - 沒有「前置條件」限制
> - 每一對的處理完全獨立
> 
> **結論：無累積 → 不需要 DP**
> 
> ---
> 
> ## 總結判定
> 
> |檢查點|這題的答案|指向|
> |---|---|---|
> |選擇是否獨立？|✅ 獨立|貪心/數學|
> |最優解由什麼決定？|純數量|計數問題|
> |有累積效應嗎？|❌ 沒有|不需要 DP|
> 
> **三個問題都指向同一個結論：這是計數 + 貪心問題，不是 DP 問題。**
> 
> ---
> 
> ## 反思：你的 DFS 為什麼會超時？
> 
> 你的 `dfs(diff: string)` 本質上是在枚舉「所有可能的配對順序」，但我們剛剛證明了——**順序根本不影響答案**。
> 
> 這就像是：
> 
> > 計算 `3 + 5 + 7` 時，你卻在枚舉「先加 3 再加 5」和「先加 5 再加 3」有沒有不同。
> 


## 完成事項