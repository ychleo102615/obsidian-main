---
tags: dailies  
date: 2026-01-16
create: 2026-01-16-Fri
time: 11:55
---
## 每日精華

#### NeetCode
- [[98. Validate Binary Search Tree]]
- [[269. Alien Dictionary]]
- [3798. Largest Even Number](https://leetcode.com/problems/largest-even-number/)
- [3799. Word Squares II](https://leetcode.com/problems/word-squares-ii/)
	這題我太想使用聰明的解法。但是到頭來還是用最暴力樸實的方式解出來。
	一開始有觀察到類似於對角線交換的關係，想說找出結果直接 `*2` 就可以解出來。
	嘗試一：用四層巢狀迴圈找出頭尾相同的路徑，但是沒有比對重疊，造成錯誤（我認為4條路徑，每每都需要檢查的話是 $C_4^6$ ，感覺太繁瑣）
	嘗試二：top, right, bottom, left 的路徑搜尋，但是與題目要求的不相符，而且還有 lexical order 問題
	嘗試三：top, left, right, bottom 的順序 DFS，有成功解出來
- [3800. Minimum Cost to Make Two Binary Strings Equal](https://leetcode.com/problems/minimum-cost-to-make-two-binary-strings-equal/)
	有點和上一題相反，感覺題目理解不足，用太笨的方式來解。
	一直想用 DFS + DP 解。這樣做的缺點是太複雜，而且時間複雜度很差
	1. `dfs(s: string, diff: Array<number>, cur)` cur 會與 dp 衝突，算出錯誤的解。感覺像是 top down, bottom up 打架的寫法 
	2. `dfs(s: string, diff: Array<number>)`  完整的 s ，但其實不需要 。中間還錯誤理解題目，以為 cross 有順便 swap。
	3. dfs (diff: string) 結果正確，而且很優雅。但是超時
	4. 這題的洞見在於，順序位置全部都不重要，重要的是不相同的 1, 0 的數量。也不需要 DP，沒有什麼前後相依性。直接依照不同的字元配對 cost 就可以了。只要一開始計算好兩個 bit 不相同時，swap 划算還是 filp 兩次划算，之後遇到 swap 時都用這個答案就好了： `Math.min(swapCost, flipCost * 2)`
	感覺花了我整個下午才解出來。
	我覺得我直覺都有往對的方式走，但是往往寫到一半卡住，又回頭用不好的舊解法。


## 完成事項