---
tags:
  - flashcards
date: 2026-01-29
time: 17:15
---

# 前端面試常見問題

#flashcards/interview-browser

請描述瀏覽器的渲染流程
?
DOM 解析 → CSSOM 解析 → Render Tree 合成
→ Layout（計算位置大小）
→ Paint（繪製像素）
→ Composite（GPU 合成圖層）

什麼情況會觸發 reflow（重排）？如何避免？
?
觸發：改變幾何屬性（width, height, margin, padding, position）
避免方式：
- 批量修改 DOM（用 documentFragment 或一次性改 className）
- 避免逐一讀寫 DOM（先讀完再寫）
- 用 transform 代替 top/left 做動畫
<!--SR:!2026-01-31,1,230-->

什麼情況會觸發 repaint（重繪）？
?
改變視覺屬性但不影響佈局
例如：color, background-color, visibility, box-shadow
比 reflow 開銷小，但仍應盡量減少

如何優化網頁的首屏載入速度？
?
減少請求：合併檔案、使用雪碧圖、HTTP/2 多工
減少大小：壓縮、Tree Shaking、Code Splitting
優化載入順序：Critical CSS inline、JS defer/async
快取策略：強快取 + 協商快取 + CDN
預載入：preload, prefetch, preconnect
<!--SR:!2026-02-02,3,250-->

什麼是 Critical Rendering Path？如何優化？
?
CRP 是瀏覽器將 HTML/CSS/JS 轉換成像素的關鍵步驟
優化方式：
- 最小化關鍵資源數量（延遲非關鍵 CSS/JS）
- 最小化關鍵資源大小（壓縮、移除未使用程式碼）
- 縮短關鍵路徑長度（減少 RTT）

#flashcards/interview-http

請描述從輸入 URL 到頁面顯示的完整過程
?
1. URL 解析（協定、主機、路徑）
2. DNS 解析（快取 → 遞迴查詢）
3. TCP 三次握手
4. TLS 握手（HTTPS）
5. 發送 HTTP 請求
6. 伺服器處理並回應
7. 瀏覽器解析 HTML、下載子資源
8. 渲染（DOM → CSSOM → Render Tree → Layout → Paint → Composite）

HTTP/1.1 vs HTTP/2 vs HTTP/3 的差異？
?
HTTP/1.1：一個 TCP 連線一次只處理一個請求，有隊頭阻塞
HTTP/2：多工（一個連線多個請求）、Header 壓縮、Server Push，但 TCP 層仍有隊頭阻塞
HTTP/3：基於 QUIC（UDP），解決 TCP 隊頭阻塞，連線建立更快

GET 和 POST 的差異？
?
語意：GET 獲取資源，POST 提交資料
參數：GET 在 URL，POST 在 body
快取：GET 可快取，POST 不可
冪等：GET 是冪等的，POST 不是
長度：GET 有 URL 長度限制（瀏覽器實作），POST 無限制

解釋 HTTP 快取機制
?
強快取：Cache-Control: max-age / Expires，直接用快取不發請求
協商快取：向伺服器驗證
- ETag / If-None-Match（內容 hash）
- Last-Modified / If-Modified-Since（修改時間）
命中返回 304，未命中返回 200 + 新內容

Cookie, localStorage, sessionStorage 的差異？
?
Cookie：每次請求自動帶上，可設過期時間，約 4KB
localStorage：持久儲存，需手動清除，約 5MB
sessionStorage：分頁關閉即清除，各分頁獨立，約 5MB
Cookie 可被伺服器讀取，其他兩者純前端

#flashcards/interview-security

什麼是 XSS？有哪些類型？如何防範？
?
XSS（跨站腳本攻擊）：攻擊者注入惡意腳本在使用者瀏覽器執行
類型：Stored（存入 DB）、Reflected（URL 參數）、DOM-based（純前端）
防範：輸出時 escape、使用 textContent 而非 innerHTML、CSP、HttpOnly Cookie

什麼是 CSRF？如何防範？
?
CSRF（跨站請求偽造）：誘騙使用者發送惡意請求，利用已登入的身份
防範：
- CSRF Token（表單帶隨機 token）
- SameSite Cookie（Strict/Lax）
- 檢查 Origin/Referer header

解釋 CORS 的運作機制
?
CORS 讓伺服器聲明允許哪些跨域請求
簡單請求：直接發送，檢查回應的 Access-Control-Allow-Origin
複雜請求：先發 OPTIONS 預檢，確認允許後才發實際請求
關鍵 Header：Allow-Origin, Allow-Methods, Allow-Headers, Allow-Credentials

為什麼需要同源政策（SOP）？
?
防止惡意網站讀取其他網站的敏感資料
例如：evil.com 的 JS 不能讀取你已登入的 bank.com 的回應
SOP 限制「讀取」，不限制「發送」，所以還需要 CSRF 防護

Cookie 的 HttpOnly, Secure, SameSite 各有什麼作用？
?
HttpOnly：禁止 JS 存取，防止 XSS 偷 Cookie
Secure：只在 HTTPS 傳輸
SameSite：
- Strict：完全禁止跨站攜帶
- Lax：允許 GET 導航攜帶（如連結點擊）
- None：允許跨站（需搭配 Secure）

#flashcards/interview-css

如何垂直置中一個元素？列舉多種方法
?
1. Flexbox：parent 設 display: flex; align-items: center; justify-content: center
2. Grid：parent 設 display: grid; place-items: center
3. 絕對定位 + transform：position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)
4. 絕對定位 + margin auto：position: absolute; inset: 0; margin: auto（需設寬高）

Flexbox 和 Grid 的差異？什麼時候用哪個？
?
Flexbox：一維佈局（單行或單列），適合元件內部排列、導航列
Grid：二維佈局（行 + 列），適合頁面整體結構、複雜網格
經驗法則：內容決定佈局用 Flex，佈局決定內容用 Grid

什麼是 BFC？如何觸發？有什麼用途？
?
BFC（Block Formatting Context）：獨立的渲染區域，內部佈局不影響外部
觸發：overflow 非 visible、display: flow-root、float、position: absolute/fixed
用途：清除浮動、防止 margin 重疊、阻止元素被浮動元素覆蓋

position 的各個值有什麼差異？
?
static：預設，正常文檔流
relative：相對自身原位置偏移，仍佔據原空間
absolute：相對最近的定位祖先，脫離文檔流
fixed：相對視窗，脫離文檔流
sticky：滾動到閾值前是 relative，之後是 fixed

CSS 選擇器優先級如何計算？
?
!important > inline style > ID > class/attribute/pseudo-class > element/pseudo-element
計算方式：(a, b, c, d)
a: inline style
b: ID 數量
c: class/attribute/pseudo-class 數量
d: element/pseudo-element 數量

#flashcards/interview-js

解釋 JavaScript 的 Event Loop
?
JS 是單執行緒，用 Event Loop 處理非同步
執行順序：Call Stack → Microtask Queue（Promise.then）→ Macrotask Queue（setTimeout）
每次 Call Stack 清空後，先清空所有 Microtask，再執行一個 Macrotask

什麼是閉包？有什麼應用場景？
?
閉包：函式能存取其詞法作用域外的變數，即使外部函式已執行完畢
應用：資料封裝（私有變數）、工廠函式、部分應用（partial application）、記憶化（memoization）

Promise 和 async/await 的差異？
?
Promise：用 .then/.catch 鏈式處理非同步
async/await：語法糖，讓非同步程式碼看起來像同步
差異：async/await 更易讀、錯誤處理用 try/catch
本質相同，await 後面接 Promise，async 函式返回 Promise

解釋 this 的指向規則
?
1. 全域呼叫：window（嚴格模式 undefined）
2. 物件方法：該物件
3. 構造函式（new）：新建立的實例
4. 箭頭函式：繼承外層的 this（詞法綁定）
5. call/apply/bind：指定的對象

深拷貝和淺拷貝的差異？如何實現深拷貝？
?
淺拷貝：只複製第一層，巢狀物件仍是參考（Object.assign, spread）
深拷貝：完全複製所有層級
實現方式：
- JSON.parse(JSON.stringify(obj))（無法處理函式、undefined、循環參考）
- structuredClone()（現代瀏覽器原生支援）
- 遞迴實現或使用 lodash.cloneDeep

#flashcards/interview-ssr

CSR, SSR, SSG 的差異？各自適合什麼場景？
?
CSR（Client-Side Rendering）：瀏覽器渲染，適合後台管理系統、高互動 SPA
SSR（Server-Side Rendering）：伺服器渲染，適合 SEO 需求、首屏速度要求高
SSG（Static Site Generation）：建置時預渲染，適合內容不常變的網站（部落格、文件）

SSR 的優缺點是什麼？
?
優點：
- 更快的 FCP（首次內容繪製）
- 更好的 SEO
- 低效能裝置友善
缺點：
- 伺服器負載增加
- TTI 改善有限（仍需 Hydration）
- 開發複雜度增加（需考慮 server/client 環境差異）

什麼是 Hydration？為什麼需要它？
?
Hydration：將伺服器渲染的靜態 HTML 與客戶端 JS 連接，使頁面可互動
過程：JS 載入 → 綁定事件監聽器 → 同步狀態
需要它是因為 SSR 只產生 HTML，沒有事件綁定和狀態管理

