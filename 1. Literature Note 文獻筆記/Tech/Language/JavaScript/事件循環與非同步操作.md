---
tags: []
date: 2026-01-25
time: 14:52
link: https://brucefe.com/zh-tw/frontend-interview-prepare/event-loop-async-tasks
---

### 什麼是非同步操作

`setTimeout`：macrotask，延遲後操作
`Promise.then`：microtask ，同步後立即操作
`async/await`：Promise 語法糖
`queueMicrotask`：手動加入 microtask queue

### 瀏覽器的事件循環 Event Loop

#### requestAnimationFrame
1. 同步程式
2. 執行**所有** microtasks
3. requestAnimationFrame
4. 瀏覽器渲染（layout, paint, composite）
5. 執行**一個** macrotask


### Node.js 事件循環
Node.js 的事件循環是基於 libuv，總共有六個階段，每個階段都有自己對應的任務。每一階段之間會先執行所有 microtask（含 process.nextTick 和 Promise）。

1. timers `setTimeout` / `setInterval`
2. pending callbacks
3. idle, prepare
4. poll  I/O 事件
5. check 執行 `setImmediate`
6. close callbacks：像是 `socket.on('close')`

`process.nextTick` 優先於所有 microtask

### setTimeout vs setImmediate 的非同步行為

```javascript
setTimeout(() => console.log('timeout'), 0);
setImmediate(() => console.log('immediate'));
```

解答：輸出順序不固定（可能是 timeout → immediate，也可能是 immediate → timeout）

> [!NOTE]
> ##### 技術細節
> 
> 關鍵點來自 libuv 原始碼分析：
> 
> 1. **`setTimeout(fn, 0)` 內部會被轉換為 1ms**
> 2. Timer callback 執行條件：當前 loop 時間 > timeout 時間
> 3. 在第一次 loop 開始前，會有一段準備時間
> 
> 
> ###### 不確定性來源
>
> | 情況        | 準備時間  | 結果                                         |
> | --------- | ----- | ------------------------------------------ |
> | 系統較忙或啟動較慢 | > 1ms | timer 已到期，先執行 setTimeout                   |
> | 系統較快      | < 1ms | timer 未到期，跳過 timers phase，先執行 setImmediate |
> 

```js

// I/O callback 中，順序固定
const fs = require('fs');
fs.readFile(__filename, () => {
	setTimeout(() => console.log('timeout'))
	setImmediate(() => console.log('immediate'))
})
// output: immediate -> timeout


// 直接執行，順序不固定
setTimeout(() => console.log('timeout'), 0)
setImmediate(() => console.log('immediate'))
// output 不固定

```


```
timers → ... → poll → check → ...
   ↑                          │
   └──────────────────────────┘

每個 phase 之間都會清 nextTick + microtask
```
