[cn](https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html)
[en](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html)

# Vertex Shader 頂點著色器
---

它的工作是生成裁剪空間座標`clipspace coordinates`
每個~~*像素*~~頂點都會呼叫著色器一次，每次都需要設置`gl_Position`成裁剪空間座標的值

頂點著色器可以靠**三種方式取得資料**
1. [Attributes](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#attributes) (data pulled from buffers)
2. [Uniforms](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms) (values that stay the same for all vertices of a single draw call)
3. [Textures](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#textures-in-vertex-shaders) (data from pixels/texels)

# Attributes
頂點著色器，資料最常見的取得方式：透過Buffer和Attributes

> [!example]- 範例細流程式碼
> You create buffers,
> `var buf = gl.createBuffer();`
>
> put data in those buffers
> ```
> gl.bindBuffer(gl.ARRAY_BUFFER, buf);
> gl.bufferData(gl.ARRAY_BUFFER, someData, gl.STATIC_DRAW);
> ```
> Then, given a shader program you made you look up the location of its attributes,
> `var positionLoc = gl.getAttribLocation(someShaderProgram, "a_position");`
>
> then tell WebGL how to pull data out of those buffers and into the attribute
> ```
> // turn on getting data out of a buffer for this attribute
> gl.enableVertexAttribArray(positionLoc);
> var numComponents = 3;  // (x, y, z)
> var type = gl.FLOAT;
> var normalize = false;  // leave the values as they are
> var offset = 0;         // start at the beginning of the buffer
> var stride = 0;         // how many bytes to move to the next vertex
>                         // 0 = use the correct stride for type and numComponents
> gl.vertexAttribPointer(positionLoc, numComponents, type, false, stride, offset);
> ```
> we can do no math in the shader and just pass the data directly through.
> ```
> #version 300 es
> in vec4 a_position;
> void main() {
>    gl_Position = a_position;
> }
> ```

與主題無關，這個是[[Callout]]的應用

Attributes can use `float`, `vec2`, `vec3`, `vec4`, `mat2`, `mat3`, `mat4`, `int`, `ivec2`, `ivec3`, `ivec4`, `uint`, `uvec2`, `uvec3`, `uvec4` as types.


# Uniforms
在一次的draw call，所有的vertices(頂點)都是不變的值。簡單的例子是Offset：
```C GLSL
#version 300 es

in vec4 a_position;
uniform vec4 u_offset;

void main() {
	gl_Position = a_position + u_offset;
}
```

```js
var offsetLoc = gl.getUniformLocation(someProgram, "u_offset");
gl.uniform4fv(offsetLoc, [1, 0, 0, 0]); // offset it to the right half the screen
```

> [!example]- 多組範例
> ```js
> gl.uniform1f (floatUniformLoc, v); // for float
> gl.uniform1fv(floatUniformLoc, [v]); // for float or float array
> gl.uniform2f (vec2UniformLoc, v0, v1); // for vec2
> gl.uniform2fv(vec2UniformLoc, [v0, v1]); // for vec2 or vec2 array
> gl.uniform3f (vec3UniformLoc, v0, v1, v2); // for vec3
> gl.uniform3fv(vec3UniformLoc, [v0, v1, v2]); // for vec3 or vec3 array
> gl.uniform4f (vec4UniformLoc, v0, v1, v2, v4); // for vec4
> gl.uniform4fv(vec4UniformLoc, [v0, v1, v2, v4]); // for vec4 or vec4 array
> gl.uniformMatrix2fv(mat2UniformLoc, false, [ 4x element array ]) // for mat2 or mat2 array
> gl.uniformMatrix3fv(mat3UniformLoc, false, [ 9x element array ]) // for mat3 or mat3 array
> gl.uniformMatrix4fv(mat4UniformLoc, false, [ 16x element array ]) // for mat4 or mat4 array
>
> gl.uniform1i (intUniformLoc, v); // for int
> gl.uniform1iv(intUniformLoc, [v]); // for int or int array
> gl.uniform2i (ivec2UniformLoc, v0, v1); // for ivec2
> gl.uniform2iv(ivec2UniformLoc, [v0, v1]); // for ivec2 or ivec2 array
> gl.uniform3i (ivec3UniformLoc, v0, v1, v2); // for ivec3
> gl.uniform3iv(ivec3UniformLoc, [v0, v1, v2]); // for ivec3 or ivec3 array
> gl.uniform4i (ivec4UniformLoc, v0, v1, v2, v4); // for ivec4
> gl.uniform4iv(ivec4UniformLoc, [v0, v1, v2, v4]); // for ivec4 or ivec4 array
>
> gl.uniform1u (intUniformLoc, v); // for uint
> gl.uniform1uv(intUniformLoc, [v]); // for uint or uint array
> gl.uniform2u (ivec2UniformLoc, v0, v1); // for uvec2
> gl.uniform2uv(ivec2UniformLoc, [v0, v1]); // for uvec2 or uvec2 array
> gl.uniform3u (ivec3UniformLoc, v0, v1, v2); // for uvec3
> gl.uniform3uv(ivec3UniformLoc, [v0, v1, v2]); // for uvec3 or uvec3 array
> gl.uniform4u (ivec4UniformLoc, v0, v1, v2, v4); // for uvec4
> gl.uniform4uv(ivec4UniformLoc, [v0, v1, v2, v4]); // for uvec4 or uvec4 array
>
> // for sampler2D, sampler3D, samplerCube, samplerCubeShader, sampler2DShadow,
> // sampler2DArray, sampler2DArrayShadow
> gl.uniform1i (samplerUniformLoc, v);
> gl.uniform1iv(samplerUniformLoc, [v]);
> ```


# 片段著色器 Fragment Shader
---
為了當前的pixel提供顏色，通常長這樣：
```C GLSL
#version 300 es
precision highp float;

out vec4 outColor; // you can pick any name

void main() {
	outColor = doMathToMakeAColor;
}
```

片段著色器也有**三種取得資料的方式**
1. [Uniforms](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#uniforms) (values that stay the same for every pixel of a single draw call)
2. [Textures](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#textures-in-fragment-shaders) (data from pixels/texels)
3. [Varyings](https://webgl2fundamentals.org/webgl/lessons/webgl-shaders-and-glsl.html#varyings) (data passed from the vertex shader and interpolated)

## [[3. WebGL2 着色器和 GLSL 语言#Uniforms|Uniforms]]可參考頂點著色器 

# Textures

為了在片段著色器中，從Texture取值，我們需要建立一個`sampler2D`uniform，並且透過一個GLSL function `texture`來取值。
```C GLSL
precision highp float;
uniform sampler2D u_texture;
out vec4 outColor;
void main() {
	vec2 texcoord = vec2(0.5, 0.5); // get a value from the middle of the texture
	outColor = texture(u_texture, texcoord);
}
```

建立資料，將資料放進texture
```js
var tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
var level = 0;
var internalFormat = gl.RGBA,
var width = 2;
var height = 1;
var border = 0; // MUST ALWAYS BE ZERO
var format = gl.RGBA;
var type = gl.UNSIGNED_BYTE;
var data = new Uint8Array([255, 0, 0, 255, 0, 255, 0, 255]);
gl.texImage2D(
	gl.TEXTURE_2D,
	level,
	internalFormat,
	width,
	height,
	border,
	format,
	type,
	data);
```

設定[[材質過濾]]的方式：
```js
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
```

WebGL 要求你必须绑定它到纹理单元去。
```js
var someSamplerLoc = gl.getUniformLocation(someProgram, "u_texture");

var unit = 5; // Pick some texture unit
gl.activeTexture(gl.TEXTURE0 + unit);
gl.bindTexture(gl.TEXTURE_2D, tex);
```

 最后告诉着色器要绑定哪个单元(unit)到纹理中去。
```js
gl.uniform1i(someSamplerLoc, unit);
```


# Varyings
Varying 是一种从点着色器到片段着色器传值的方式
变量“varyings”，将位置信息从点着色器传递给片段着色器。 之所以称为"varyings"，因为它的值可以变化的。 当 WebGL 使用片段着色器绘制每个像素时， 它会对我们在点着色器中提供的值进行[插值](https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-how-it-works.html)。
