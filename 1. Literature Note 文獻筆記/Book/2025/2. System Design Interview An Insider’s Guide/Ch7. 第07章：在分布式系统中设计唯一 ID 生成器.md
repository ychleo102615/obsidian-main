---
tags: 
date: 2025-07-02
time: 21:50
link: https://github.com/Admol/SystemDesign/blob/main/CHAPTER%2007：DESIGN%20A%20UNIQUE%20ID%20GENERATOR%20IN%20DISTRIBUTED%20SYSTEMS.md
---

- ID 必须是唯一的。
- ID 只是数值。
- ID 适合 64 位。
- ID 按日期排序。
- 能够每秒生成超过 10,000 个唯一 ID。

生成的方式：
- 多主复制 Multi-master replication
- 通用唯一标识符 (UUID)
- Ticket 服务器
- 推特雪花算法


### Multi-master replication

有k台server，計數器一次就會增加k。
![500](https://github.com/Admol/SystemDesign/raw/main/images/chapter7/figure7-2.jpg)

缺點：
- 難以在多個資料中心中擴展
- 在多server中，id不隨時間增長
- server數量難以增減

### UUID
128bits的資料，約 $3.4 \times 10 ^ {39}$

**优点：**

- 生成 UUID 很简单。服务器之间不需要协调，因此不会有任何同步问题。
- 该系统易于扩展，因为每个 Web 服务器负责生成它们使用的 ID。 ID 生成器可以轻松地与 Web 服务器一起扩展。

**缺点：**

- ID 是 128 位长，但我们的要求是 64 位。
- ID 不会随时间上升
- ID 可以是非数字的。

### Ticket 服务器
![500](https://github.com/Admol/SystemDesign/raw/main/images/chapter7/figure7-4.jpg)

这个想法是在一个单一的数据库服务器（Ticket Server）中使用一个集中的自动增量功能。

**优点：**

- 数字 ID
- 易于实施，适用于中小型应用程序

**缺点：**

- 单点故障。单个票务服务器意味着如果票务服务器发生故障，所有依赖它的系统都将面临问题。为了避免单点故障，我们可以设置多个票务服务器。然而，这将引入新的挑战，如数据同步。


### 推特雪花算法

上面提到的方法给了我们一些关于不同的ID生成系统如何工作的想法。然而，它们都不符合我们的具体要求；因此，我们需要另一种方法。Twitter 独特的 ID 生成系统“snowflake” 很有启发性，可以满足我们的要求。

分而治之是我们的朋友。我们不是直接生成一个ID，而是将一个ID分成不同的部分。图7-5显示了一个64位ID的布局。

![700](https://github.com/Admol/SystemDesign/raw/main/images/chapter7/figure7-5.jpg)

- 符号位：1 位，它将始终为 0。这是为将来使用保留的。它可以潜在地用于区分有符号数和无符号数。
- 时间戳：41 位。自纪元或自定义纪元以来的毫秒数。我们使用 Twitter 雪花默认纪元 1288834974657，相当于 2010 年 11 月 4 日 01:42:54 UTC。
- 数据中心 ID：5 位，这给了我们 25=32 个数据中心。
- 机器 ID：5 位，每个数据中心有 25=32 台机器
- 序列号：12 位。对于在该机器/进程上生成的每个 ID，序列号都会递增 1。该数字每毫秒重置为 0。

#### 时间戳

最重要的41位组成了时间戳部分。由于时间戳随时间增长，ID可按时间排序。

图 7-7 显示了二进制表示如何转换为 UTC 的示例。您还可以使用类似的方法将 UTC 转换回二进制表示。
![500](https://github.com/Admol/SystemDesign/raw/main/images/chapter7/figure7-7.jpg)

可以用 41 位表示的最大时间戳是： 2^41−1=2199023255551毫秒(ms)，这样我们就可以得到。 ≈69年=2199023255551毫秒/1000秒/365天/24小时/3600秒。

#### 序列号

序列号是 12 位，这给了我们 2^12=4096 种组合。除非在同一台服务器上在一毫秒内生成多个 ID，否则该字段为 0。理论上，一台机器每毫秒最多可以支持4096个新ID。


### 总结

- 时钟同步。在我们的设计中，我们假设 ID 生成服务器具有相同的时钟。当服务器在多个内核上运行时，此假设可能不成立。同样的挑战存在于多机场景中。时钟同步的解决方案超出了本书的范围；但是，了解问题的存在很重要。网络时间协议是这个问题最流行的解决方案。有兴趣的读者可以参考参考资料[4]。
- 节段长度调整。例如，较少的序列号但较多的时间戳位对低并发性和长期应用是有效的。
- 高可用性。由于 ID 生成器是关键任务系统，因此它必须具有高可用性