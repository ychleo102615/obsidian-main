---
tags: []
date: 2025-03-15
time: 17:42
---
## 雜湊索引
記憶體中會記錄鍵值與位元組偏移量（key and byte offset），指名可以找到該對應位置。

現實中，Bitcask就是這麼做的（Riak中的預設儲存引擎）。
這樣的除紋引擎非常適合每個鍵的值經常更新的狀況，例如影片url對應影片的點擊量。沒有太多不同的鍵，每個鍵有很多的寫操作。

## SSTables 和 LSM樹
日誌的結構儲存段都是謝列鍵值對。並按鍵排序。這個格式稱為**排序字串表**（Sorted String Table），簡稱SSTable。

與雜湊索引相比有幾個大的優勢：
1. 合併段的操作簡單而高效，就像merge sort
2. 為了在檔案中找到特定的鍵，不需要在記憶體中儲存所有的鍵的索引。例如你儲存了`handbag`和`handsome`，因為排序特性，你可以知道`handiwork`必須出現在這兩這之間。可以直接跳過去找


#### 建構和維護SSTables
- 新寫入時，將其新增到記憶體中的平衡術資料結構（例如紅黑樹）。這個記憶體數有時被稱為記憶體表（memtable）
- 剛記憶體表大於某個閥值，將其作為SSTable寫入硬碟
- 要讀取的時候，先在記憶體表中找，找不到就在最近的硬碟段中找
- 時不時要合併壓縮，合併段檔案

#### 用SSTables製作LSM樹
日誌結構合併樹（Log-structured Merge Tree）

#### 效能優化
尋找不存在的鍵時，LSM樹的演算法會很慢，你要找完所有的段之後才能確定他不存在。為了最佳化，儲存引擎通常會使用額外的布隆過濾器（Bloom filters）。


## B樹

像SSTables一樣，B樹抱持案件排序的鍵值對，這允許高效的鍵值查詢和範圍查詢。
但是他與SSTables有很大的不同。

B樹將資料庫翻解成固定大小的塊或分頁，傳統上為4KB。一次只能讀寫一個頁面。
一個頁面就像一個樹狀結構的節點，他可以指向多個其他的頁面。
所以會有一個頁面作為root。

一個頁面中對子頁面的引用數量稱為分之因子（ branching factor）。實踐中，分支因子的大小取決於儲存頁面引用和飯為邊界所需要的攻堅，通常是幾百。

如果要新增一個新的鍵，你需要找到期範圍能包涵新建的頁面，並新增。如果沒有足夠可用空間容納新鍵，將其分成兩個半滿頁面，並更新父頁面以反應新的鍵範圍分割槽。
這個演算法可以保持B樹平衡：具有n個鍵的B樹總是具有O(logn)的深度。
大多樹資料庫可以芳一個三到四層的B樹。分支因子為500的4KB頁面的四層樹可以儲存256TB的資料。


## [比較B樹和LSM樹](https://github.com/Vonng/ddia/blob/main/zh-tw/ch3.md#%E6%AF%94%E8%BC%83b%E6%A8%B9%E5%92%8Clsm%E6%A8%B9)

LSM樹的優點
有時較低的寫放大，進而有較高的吞吐量。也因為它們順序寫入。比隨機寫入快很多。
硬碟空間利用更有效率。

缺點
如果寫入吞吐量很高，並且壓縮沒有仔細配置好，有可能導致壓縮跟不上寫入速率。


| 特性 / 技術     | Log-Structured Storage    | B-Tree                     | Column-Oriented Storage       |
| ----------- | ------------------------- | -------------------------- | ----------------------------- |
| **寫入方式**    | Append-only               | In-place update            | Append by column              |
| **查詢效率**    | 差（需合併）                    | 快（log n）                   | 針對某幾欄查詢非常快                    |
| **適合的查詢**   | Key-based lookup          | 範圍查詢 / 排序查詢                | 聚合、過濾、統計查詢                    |
| **壓縮效率**    | 中                         | 低                          | 高（相同欄位容易壓縮）                   |
| **適用場景**    | 高寫入量、訊息、時序系統              | 傳統資料庫、OLTP                 | 分析型查詢、OLAP、資料倉儲               |
| **代表技術/產品** | Kafka, Cassandra, RocksDB | MySQL, PostgreSQL (B+Tree) | ClickHouse, Parquet, Redshift |


- **Materialized View**：  
    把查詢結果「存起來」的表格，類似快取（cache），避免每次都重新查原始資料。
    
- **Data Cube / OLAP Cube**：  
	是一種特殊的 Materialized View，把 __多維度的彙總統計資料，(如總銷售額)__ 預先計算好，讓查詢更快。

Materialized View 不適合OLTP，但適合OLAP，因為它不適合一直update，但是適合一直讀取。

| 比較項目 | View        | Materialized View |
| ---- | ----------- | ----------------- |
| 資料儲存 | ❌ 不儲存，動態查詢  | ✅ 儲存查詢結果          |
| 更新頻率 | 即時計算        | 需手動或排程更新          |
| 查詢速度 | 慢（每次都重新跑）   | 快（使用快取）           |
| 用途   | 統一查詢介面、封裝邏輯 | 提升查詢效能，預算統計       |