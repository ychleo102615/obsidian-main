---
tags: []
date: 2025-06-21
time: 20:47
---
在資料系統中，為什麼寫入密集型的應用特別適合使用 LSM-Tree？請說明其合併（compaction）流程如何同時影響寫入效率與讀取成本。

回答：LSM-Tree就是log sorted-string merge tree，每次資料寫入時，不會存取隨機記憶體，而是寫在目前檔案位置尾端，所以速度能夠很快。合併的流程我不確定。

## **一、Compaction 怎麼做？**

1. **挑檔**
    
    - 系統為每一層（Level）設定一個容量上限，例如 L₁ 最多 10 MB。
        
    - 當某層的 SSTable 總量超過上限，就挑出這一層裡最「舊」或與下一層重疊最多的幾個檔案，和下一層中鍵範圍有交集的檔案一起合併。
        
    
2. **串流合併（Streaming Merge）**
    
    - 不會一次把整個檔案全載入記憶體，而是以多路合併的方式：
        
        1. 對每個要合併的 SSTable 開一個 iterator，順序讀出每筆 key–value。
            
        2. 把這些 iterator 的輸出，做 merge-sort，依 key 排序地寫到新的 SSTable。
            
        3. 在此同時，若遇到相同 key，就只保留新版並丟棄 tombstone（刪除標記）或舊版紀錄。
            
        
    
3. **替換與清理**
    
    - 合併完成後，把參與合併的舊 SSTable 都刪掉，新產生的 SSTable 放到下一層。
        
    - 這樣，每次 compaction 都把「老檔案」往更底層推，並消除重複與刪除標記。
        
    

---

## **二、對寫入效率的影響**

- **順序寫最少隨機 I/O**
    
    - 使用 LSM-Tree 時，所有新寫入先都追加到 MemTable（記憶體）→ flush → 生成 SSTable，即是順序寫入磁碟，不做隨機更新。
        
    - Compaction 雖然會額外寫多次（造成寫放大），但都是順序掃描舊檔案、順序寫入新檔案，不會觸發大量隨機 I/O，整體仍比 B-Tree 的隨機更新效率高。
        
    
- **高吞吐量**
    
    - 在高寫入量場景下，LSM-Tree 可先快速收集大量寫入，再在背景做批次合併，寫者幾乎不會被阻塞。
        
    

---

## **三、對讀取成本的影響**

- **讀放大（Read Amplification）**
    
    - 在各層 SSTable 尚未完全整理前，同一筆 key 可能存在於多個檔案裡，讀取時要依序到每一層、每一個檔案做 merge 查找，造成讀放大。
        
    - Compaction 可以把多層重疊減到最少，讓更高層（如 L₁、L₂…）的檔案 key-range 不重疊，讀者只需查到最上層命中即停止，大幅降低讀放大。
        
    
- **平衡讀寫**
    
    - 系統可調整 compaction 的頻率與每層大小比（size ratio），在寫入吞吐和讀取延遲之間找到最適平衡：
        
        - **頻繁 compaction** → 少重疊、更低讀放大，但寫放大增多；
            
        - **延後 compaction** → 減少寫放大，但讀放大暫時較高。