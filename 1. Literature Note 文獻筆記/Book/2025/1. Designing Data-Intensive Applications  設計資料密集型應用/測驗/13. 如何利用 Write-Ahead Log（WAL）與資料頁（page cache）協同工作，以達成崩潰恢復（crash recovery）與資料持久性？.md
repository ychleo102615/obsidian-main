---
tags: []
date: 2025-07-01
time: 21:46
---
題目：資料庫如何利用 Write-Ahead Log（WAL）與資料頁（page cache）協同工作，以達成崩潰恢復（crash recovery）與資料持久性？請簡要說明其寫入與恢復流程。 
回答：page cache我不知道是怎麼運作的，WAL是在資料庫寫入資料之前，先將該改動寫進WAL之中，所以資料庫在寫入途中crash的話，也能夠靠著重播WAL，將資料庫恢復到最新狀態。

## 寫入流程

1. **寫入 WAL（順序寫入）**
    
    - 當事務要修改某個資料行時，資料庫先把這次變更的 **Log Record** 以「追加」方式寫到 WAL 檔案，並呼叫 fsync 確保已持久化到磁碟。
        
    - 這個步驟保證了即使後續崩潰，只要 WAL 已經刷入，事務的變更就能被保留。
        
2. **更新 Page Cache（記憶體中的資料頁）**
    
    - 接著，資料庫在 **Page Cache**（Buffer Pool）中找到對應的資料頁，把修改應用到記憶體版的頁面上。
        
    - **注意**：此時資料頁還未寫回磁碟上的資料檔，只存在於記憶體。
        
3. **延遲寫回 Data File（磁碟上的資料頁）**
    
    - 為了效能，資料庫會累積多次修改，再根據策略（如 LRU、dirty page age）選擇合適時機，把修改過的資料頁從 Page Cache 寫回到資料檔上。
        
    - 寫回時若發生 crash，不用擔心，因為修改已在 WAL 中被記錄，可以在恢復階段重播。
        

---

## 崩潰恢復流程

1. **重放 WAL（Redo）**
    
    - 系統重啟後，先讀取 WAL 中自上次 checkpoint 之後的所有 Log Record，並依序「重播」這些變更到資料檔或重建 Page Cache，將資料庫恢復到最接近崩潰前的狀態。
        
2. **Undo 未提交事務（可選）**
    
    - 若 WAL 同時記錄了 undo 資訊（或有獨立的 undo log），還可以回滾那些在崩潰時尚未提交的事務，確保原子性。
        
3. **重新建立檢查點（Checkpoint）**
    
    - 恢復完成後，資料庫會再做一次 checkpoint，把當前的 Page Cache 狀態全部或部分持久化到資料檔，並截斷已重播過的 WAL 段，準備下次循環。
        

---

## 協同效益

- **高效寫入**：WAL 的順序寫入與 Page Cache 的延遲寫回，讓寫操作既能保證持久化，又能最大化利用記憶體與磁碟的 I/O 吞吐。
    
- **Crash Recovery**：即使資料頁尚未全部同步到資料檔，只要 WAL 已經刷入，就能靠重放 WAL 把資料檔補齊。
    
- **一致性保障**：WAL＋Page Cache 機制配合 checkpoint，確保即使多次 crash，也能快速而正確地恢復到一致狀態。


當 WAL 在寫入過程中崩潰，只會導致那一條（或那一頁）的 log record「無效化、捨棄」，不會影響之前已完整寫入、且已 fsync 的日誌內容。恢復時系統從最後一條有效記錄繼續重播，確保不會因半條寫入而破壞資料一致性。