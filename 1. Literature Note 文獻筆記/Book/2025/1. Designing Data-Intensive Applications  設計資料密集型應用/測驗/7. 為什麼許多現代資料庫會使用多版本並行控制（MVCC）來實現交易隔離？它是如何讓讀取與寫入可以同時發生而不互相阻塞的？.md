---
tags: []
date: 2025-06-20
time: 22:09
---
回答：第二個問題就是第一個問題的回答：因為可以同時讀取和寫入而不阻塞。至於第二個問題，每個交易會有一個版本號，在該次交易中，就只能讀取相同版本的資料，例如A先開始了交易，之後B的交易開始並寫入一個資料，而之後A要讀取該資料時，不會讀到B寫入的資料，而會是在A開始交易時的版本。不同版本的資料是透過append log的方式去實踐的。

回饋：
### **1. 為什麼要用 MVCC？**

- **避免讀寫鎖競爭**：傳統的兩階段鎖（2PL）若要保證隔離性，讀操作要加共享鎖、寫操作要加排他鎖，容易導致大量讀寫互相阻塞，影響吞吐。
    
- **提升並發吞吐**：MVCC 讓讀者不加任何鎖就能讀取舊版本，寫者也不會因為有讀者在讀而被阻塞，極大地提升了系統在高併發讀取場景下的效能。
    
- **支援快照隔離**：MVCC 天然支援「快照隔離」（Snapshot Isolation），每個事務都看到自己啟動時的一個資料快照，避免了髒讀、不可重複讀和遺失更新等低階 anomalies。
    

---

### **2. MVCC 怎麼讓讀寫不阻塞？**

1. **多版本資料存放**
    
    - 每筆資料在儲存時，不是直接覆寫原來的值，而是 **保留舊版本**，並在同一資料位置「追加（append）」一個新版本。
        
    - 這些版本通常以「開始版本號（或 timestamp）」和「結束版本號」標記可見時間範圍。
        
    
2. **事務讀取快照**
    
    - 當事務 A 開始時，指派一個 **讀取時間戳**（read timestamp）。
        
    - 之後所有讀操作，只讀取在這個時間戳之前「已經提交」且對 A 可見的版本，不會去看更晚寫入的新版本。
        
    - 因此即使此刻有事務 B 正在寫入同一筆記錄，A 也不會被阻塞，也不會看到 B 的新值。
        
    
3. **寫入不覆蓋**
    
    - 寫者 B 寫入新版本時，只要在資料結構尾端追加一個新版本，修改其版本號範圍即可，**不需要鎖定讀者正在讀的舊版本**。
        
    - 等到後續無任何事務再需要舊版本時，系統再做垃圾回收（GC）或合併，回收那些過期版本。
        
    
4. **版本可見性檢查**
    
    - 讀取時，系統只要根據事務的讀取時間戳，挑出最「接近」且在時間範圍內的版本即可。
        
    - 寫入時，要做最簡單的衝突檢查（如是否有同時修改相同欄位的新版本）再決定是否 abort，並不需要鎖定讀操作。