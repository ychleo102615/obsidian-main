---
tags: []
date: 2025-08-23
time: 12:53
source book: https://agorism.dev/book/software-architecture/%28Robert%20C.%20Martin%20Series%29%20Robert%20C.%20Martin%20-%20Clean%20Architecture_%20A%20Craftsman’s%20Guide%20to%20Software%20Structure%20and%20Design-Prentice%20Hall%20%282017%29.pdf
---

# Ch. 4 結構化程式設計

- 由Dijktra發起。
- 數學可以證明正確，科學可以證明錯誤。用數學證明程式正確太難，但是用科學證明程式在多數的情況不會出錯比較簡單。
- 像是goto這種「不好證明錯誤」的編寫方式是不好的。「能夠證明錯誤」的程式碼，能在通過一定程度的測試之後，讓我們有信心說他「足夠正確」。
###### **修正版：**
- 由 Dijkstra 發起結構化程式設計，推動用數學思維管理程式複雜度。
- 數學能證明正確，但過於繁瑣；科學能嘗試證明錯誤，軟體開發更偏向後者：透過大量測試，若無法證偽，即可視為「足夠正確」。
- 不受限制的 goto 讓錯誤難以驗證，因此不好；採用結構化程式（順序、選擇、迴圈）可讓程式拆解、測試、驗證更容易。


# Ch5. 物件導向程式設計

### 封裝？
很多物件導向語言很少或沒有強制性封裝。

### 繼承？
早期程式語言早就能用技巧實現類似繼承，OO 語言只是把這件事變方便，特別是自動處理型別轉換，並支援多重繼承語法。

### 多型？

UNIX要求IO設備提供5個標準函式：`open, close, read, write, seek`，署名必須一致。

```C
extern struct FILE* STDIN:

int getchar() {
	return STDIN->read();
}
```
`getchar`不在乎使用哪個設備。

##### 多型是是指向函數的指標。OO沒有帶來多型，但是使他更安全、更方便。

#### 多型的威力

IO設備就是copy程式的`plugin`（外掛）。
我們希望程式做相同的工作，只是使用不同的設備。

#### 依賴反轉
OO語言提供安全且方便的多型意味著，**無論在何處，任何的原始碼依賴方向都可以被改變。**

UI和資料庫可以作為業務規則的`plugin`。業務規則的原始碼永遠不會提及UI或資料庫。

程式碼改變 -> 只有該元件需要重新部署 -> 可獨立部署性 independent deployability
可以獨立部署 -> 可由不同團隊獨立開發 -> 可獨立開發性

### 結論
**OO是透過多型，來獲得對於系統中每個原始碼依賴方向的絕對控制力。**


# Ch6. 函數式程式設計
[[2025-09-27|2025-09-27 Sat, 23:37]]

函數語言中的**變數不會改變**。

### 不可變與架構
如果沒有可變的變數，就不會有競爭條件 race condition，死結條件 deadlock，平行更新問題 concurrent update problem。

我們希望系統在執行多執行緒和多處理器的情況仍舊耐用。你一定要問自己：不變性是否可行。

在做出某些折衷，不變性是可行的。

### 可變性的分離

書中用clojure語言舉例一個很像資料庫事務的方式：

`(swap! counter inc)` 
inc會比較counter是不是與呼叫當下一樣，不一樣的話就得重試。

架構師應該明智地將盡可能多的處理，放入到不可變的元件中，並且將更多的程式碼盡可能放置於可變動的元件之外。

### 事件來源
我們儲存交易，而非狀態，當需要取得狀態時，我們只是簡單地從源頭開始應用所有的交易。


應用程式不是CRUD，只具備CR。所有不會有任何平行話的問題。
有足夠空間和足夠的處理器能力，我們可以使應用程式完全是不可變的，也就是完全的函數式化。

git source control也是這樣工作的

# 總結
- 結夠化程式在直接控制轉移上加上規範
- 物件導向程式在間接控制轉移上加上規範
- 函數式程式在變數賦值上加上規範
我們所學的，是哪些是不該做的ㄕ