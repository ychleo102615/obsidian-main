---
tags: []
date: 2024-11-06
time: 23:03
---
## 4. 分離領域

### 樣式：Layered Architecture
*p.66*
- 使用者介面層
- 應用層
- 領域層
- 基礎設施層

#### 架構框架
專案應該都需要某種形式的架構框架。
我們應有選擇性地應用，就可以避免框架的不足之處。明智審慎地選擇框架中「最具價值的功能」，減少實作和框架之間的耦合。


> [!NOTE] 我目前對分層的想法     
> 目前的舉例，作者感覺表達出領域是可以依賴於基礎設施層的。
> 其實這個想法，轉個想法也可以理解。但重點是基礎設施層使用的框架、或是其他功能，是非常經典、常用、不易變動的才行。
> 後端常用的一些與資料庫互動的工具，應該就可歸類於這類吧。
> [[2024-10-08|2024-10-08, 22:54]]


### 樣式：THE SAMART UI 「反模式」
此模式與領域驅動設計**互不相容**。

此模式只適合極其簡單的專案。好處是又快又簡單又好重寫。


## 5. 軟體中所表示的模型

### 關聯
模型中每一個可遍歷（traversable）的觀念，軟體中都要有同樣屬性的機制。

三種方法使關聯更容易控制
1. 規定一個遍歷方向
2. 增加限定符，以便有效地減少多重關聯
3. 消除不必要個關聯

2\. 講的就是map的key值這樣的概念。

### 樣式：ENTITY (REFERENCE OBJECT)

entity可以是任何事物，只要滿足兩個條件
1. 它在整個生命週期中具有連續性
2. 它的區別並不是由那些「對使用者非常重要的屬性」決定的

並不是每一個事物都必須有一個標誌，標誌重不重要，取決於他是否有用。
同一個事物在領域模型中，可能需要是entity，也可能不需要。

舉例：對號座的座位是entity。自由座的座位不是entity。

entity往往透過協調其關聯物件的操作來完成自己的職責。

例如：
Customer有需多不同目的的phone number，那phone number就與標誌無關，應該拉出為關聯物件，Sales Contact中。

#### 設計標誌操作
我們常用物件「在記憶體中的位置」作為標誌，但這過於簡單。
從資料庫曲出物件時，建立新實體，這樣原來的標誌就會失去。
在網路上傳輸物件，也同樣道理。

有時候資料的組合可以確保唯一性，例如日期。


### 樣式：值物件 VALUE OBJECT
用於描述領域的某個方面而本身沒有概念標示的物件稱為 Value Object。
我們只關心他們是什麼what，而不關心他們是誰who or which。

例子：顏色

Value Object 可以是其他物件的集合。例如窗戶的高、寬。
Value Object 可以引用 Entity，例如路線可以引用頭尾的城市與公路。
Value Object 常作為「參數」在物件之中傳遞。他們是臨時物件，使用完即丟棄。
Value Object 可以是 Entity 的屬性。
Value Object 應該是不可變的。

Value Object 在概念上應該是一個整體，例如：「地址」
```java
Address
--------
street
city
state
```


> [!NOTE] 我的想法
> 值物件這個名稱，本身就告訴你，他應該被看待為一個「值」，而不是有特別意義的實體。

#### 設計
傳遞值物件時，其所有者的約束條件可能會改變。可以透過傳遞不變的物件或是副本來解決。

#### 優化
值物件是可以共享的（同一個參考，指向同一個實例）。
要複製還是共享實例，取決於實作環境。

只要Value Object是不可變的，管理就會變得簡單。因為你只能替換整體來修改它。

#### 設計包含Value Object的關聯
雙向關聯完全沒有意義。如果有這個需要，或許不應定義它為Value Object。


### 樣式：SERVICE   
*p.102*
一些領域概念不適合被建模為物件。
Service是技術框架中常見的模式，他們也可以在領域層中使用。

Service，強調的是與其他物件的關係。是動詞而不是名詞。
Service有定義的職責。而「這種職責」與「履行它的介面」也應作為領域模型的一部分來加以定義。參數和結果應該是領域物件。

好的Service有三個特征。
1. 這個操作屬於領域，但它又不算是Entity和Value Object的自然組成部分
2. 介面是根據領域模型的其他元素定義的
3. 操作是無狀態的 (stateless)

##### 無狀態
不關心實例的歷史狀態

> [!NOTE] 我的想法
> 目前我在工作中實作的Service，可能跟State大有關係。
> 我分類了在不同的State中要做的事到不同的Service中。這樣每個Service其實不用太多關心state在哪個狀態（因爲會進來此Service就代表已經是某狀態，不用關心其他狀態）。
> 
> 但像是DealService，需要關心目前發了幾張牌。這樣還能算是好的Service嗎？


#### Service與孤立的領域層
文獻中大多的Service指的是純技術的Service（沒有業務意義，是基礎設施的Service）。

例如：轉帳Service應屬於領域層，它涉及了基本的業務邏輯。


### 樣式：MODULE (PACKAGE)
Module是一種表達機制。
把物件放進Module，相當於告訴其他人「要把這類別放在一起考慮」。

Module的名稱應是Ubiquitous Language的術語。

### 非物件元素
將非物件元素混合到物件導向為主的系統中時：
- 不要和實作範式對抗：找到適合的模型範式
- 把通用的語言作為依靠的基礎
- 不要一昧依賴UML：有時其他圖形、簡單敘述會比物件視圖好用
- 保持懷疑

## 6. 領域物件的生命週期

### 樣式：AGGREGATE
每個Aggregate都有一個根root和一個邊界boundary。
根是Aggregate所包含的一個Entity，外部物件只可引用根。
邊界內部的物件則可以互相引用。

汽車可以是一個聚合根，其中包含的輪子則可以算在聚合內的Entity，外界不可直接存取。

##### 這邊書中用訂單PO(purchase order)舉了很實際的例子。
*p.128*

多人在編輯資料時，過於謹慎的鎖定會妨礙人們的工作。

PO有一個固定規則：購買總金額有上限
書中最後提出一個模型實作，把價格從PO中拆出來，因此**修改價格時「不會立即影響」訂單**。
對Price的修改不一定要傳遞到現有 PO，它取決於修改價格時「PO處於什麼狀態」。
例如東西都買完了的PO，修改他的價格就特別沒有意義。

### 樣式：FACTORY
避免物件自身負責其建立。更不用提讓客戶負責建立的話，會使客戶與物件產生過於緊密的耦合。

組合零件的工作與使其運轉的工作是獨立的。

##### Factory封裝了建立複雜物件或Aggregate所需的知識。
它提供了「客戶目標」的介面，以及「被建立物件」的抽象視圖。

#### 好的Factory需要滿足兩個基本需求
##### 1. 建立方法是原子的（atomic）
確保所有固定規則。要在一次互動中把所有所需資訊傳給Factory。
##### 2. Factory應備抽象為所需的類型，而不是具體類別
高級Factory模式

#### 選擇Factory及其應用位置
##### 為已存在的Aggregate添加元素
在其聚合根上建立Factory Method。如果該Factory不適合在根上建立的話，應該建構一個獨立的Factory。但是該元素仍只能在Aggregate內部存取。

##### 不是「擁有關係」的物件創建
例如：「帳號」與「一筆交易」的關係。
要建立交易物件時，裡面有許多屬性會由帳號物件那取得，但交易物件不會是帳號物件「擁有」的東西。
這個Factory Method可以在「帳號」物件上建立。這樣不必額外提取資料到其他地方去建立「交易」物件，也有利於表達他們的關係。

#### 有時候只需要建構子
使用Factory有巨大的好處，但它會使那些不具「多形 polymorphism」的簡單物件複雜化。

#### Factory的介面
##### 1. 操作必須是原子的
要在一次互動中把建立所需的所有資訊傳給Factory。
##### 2. 注意對參數的處理
可能會產生更多耦合，像是參數不是單純插入，而還要挑選。


### 樣式：REPOSITORY 

技術上，取出已儲存的物件屬於「建立物件」的範疇（從資料庫取出資料並組裝物件）。
但從概念上來講，這個動作還在Entity的生命週期**中間**。


我們可能因為基礎設施提供了很多方便，就直接提取資料與物件，而不是透過聚合根。導致領域邏輯進入查詢和客戶程式碼之中。
這使Entity, Value Object變成單純的資料容器，也使客戶程式碼變的混亂。最終模型變的無關緊要。

所以，Repository的用途就是把所有物件表示為一個集合，它有CRUD功能。
這些職責提供了對聚合根的整個生命週期的全程存取。
讓客戶始終聚焦於模型，而將所有物件的儲存和存取操作交給Repository完成。

- Repository為客務提供一個簡單的模型，用來獲取「持久化物件」並管理他們的生命週期
- Repository使應用程式和領域設計與持久化技術解耦
- Repository表現了物件存取的設計決策
- 可以很容易將他們替換成虛擬實作，以便在測試中使用（從資料庫改為使用記憶體）


> [!NOTE] 我的想法
> 書中這裡講的東西，可能都是以領域層與基礎設施層之間的關係作為出發點討論的。
> 所以Repository等於是領域模型和資料庫之間的轉接器，這與在整潔的程式碼中學到的概念符合。
> 我一開始還在想，這本書怎麼會讓領域層依賴於基礎設施層呢？看到這邊是明白了，作者將與資料庫的互動算作是「領域內部」，但是資料庫仍算是Clean Architecture中的「外部細節」。
> Repository就是一個Adapter的特別常見的用法。


#### 在框架內工作
如果除了使用指定框架之外沒有別的選擇：
尋求「領域驅動設計的概念」與「框架中的概念」之間的相似性。

如果可自由選擇，應選擇「與設計風格協調的框架」與「框架中的一些部分」。

#### Repository & Factory
從技術上來說，他們都會建立物件。但從DDD的角度來講，但他們具有完全不同的職責。
Factory負責創建。
Repository負責尋找已有的物件。

Repository也可以委託Factory來建立物件（但是實際上很少這樣做，大多數情況下會直接使用 ORM 或者在 Repository 內部手動處理物件的重建，特別是簡單的情況）。

也不要將二者組合為「尋找或建立」的功能。實務上只會讓局面變得混亂。

#### 為關聯式資料庫設計物件
資料模型與物件模型差別不應太大（不論映射工具的強大功能）。
可以犧牲一些豐富性、規範化來保持關係模型的緊密關聯。

大多數情況下「關聯式資料庫」是物件導向領域中的持久化儲存形式，因此簡單的斷應關係才是最好的。


## 7. 使用語言：一個延伸的範例

這章用貨物運輸系統做一個範例，實際演示一個模型和設計的過程。
1. 設計領域物件
2. 隔離出應用層的功能
3. 區分Entity, Value Object, 關聯、 聚合邊界

#### Handling Event
這個例子有三個主角：Cargo, Delivery History, Handling Event。他們都是Entity。他們之間循環引用。
Delivery History屬於Cargo的聚合之中。
本來的設計是讓Delivery History持有Handling Event的集合，但是這樣每次要在Delivery History新增Handling Event時，Cargo必須存在（也就是鎖住，其他使用者也無法同時編輯這個Cargo）；此外，這樣的設計，以常見的場景來說，應該會很浪費記憶體（大部分的時候，這些歷史資料應該都不太會用到）。

所以另一個設計就是，**為Handling Event新增Repository**。

好處有很多：
- 用查詢來代替集合可以降低「維護Cargo和Handling Event之間的循環引用的一致性」
- 很少查詢他的狀態，這種設計可以持久化物件的實際數量
- 新增Handling Event不會與Cargo Aggregate競爭
- 保持聚合邊境的清晰
壞處可能就是：
- 性能比不上集合還快


### 引入新特性：配額檢查
用其他軟體來制定不同類型貨物的運輸配額（運算利潤、運送能力、空間等）
#### 連接兩個系統
Sales Management System是一個外部系統。Booking Application若與他直接互動，會很難保持清新的DDD。
我們可以建立一個翻譯類別，作爲Anticorruption layer。

這個介面的名稱：
~~Sales management Interface~~
Allocation Checker
取一個反應了他在系統中職責的名稱。
##### 注意，Allocation Checker屬於領域層

#### 劃分業務
在Cargo 中新增Enterprise Segment（企業部門單元），它是一組維度，可以包含例如：時間維度。
（11章會談到）
~~這個Enterprise Segment需要被Allocation Checker翻譯，讓外部的Sales management System可以使用。~~
為了用有利於業務策略的維度進行劃分。**我們需要任意定義Enterprise Segment。**
這代表該物件不該由Cargo負責生成，而是讓那些知道劃分規則的物件來承擔「獲取這個值」的職責。
這是一個設計的選擇，而且不會應該不會對設計造成很大的破壞。

#### 性能優化
對Sales Management System操作，通訊開銷可能會很大。可以做像把一些靜態資料快取下來這樣的優化。
