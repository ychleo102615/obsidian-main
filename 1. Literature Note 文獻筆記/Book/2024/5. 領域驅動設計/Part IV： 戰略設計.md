---
tags: []
date: 2024-11-06
time: 22:57
---
隨著系統增長，我們需要掌握「操控」和「理解」大型模型的技術。

遵循*一些原則*，借可以對複雜的領域建模。這樣的決策可能需要多個團隊協商才能決定。這常常是**設計和策略產生交集**的結果。

設計一個「包含所有概念的」單一領域模型，會分長笨拙，產生大量難以察覺的重複和矛盾。
設計臨時拼揍的「小而各自不同的子系統」，又不具備解決企業及問題的能力，且各個整合點都有可能出現不一致。
透過使用「有系統的、不斷演變的設計策略」，就可以避免這兩種極端問題。

戰略設計原則（strategic design principle）必須指導設計決策，以便減少各個部分之間的互相依賴。在使「設計意圖」更清晰的同時，又不會失去關鍵的互通性（interoperability）和協同性（synergy）。


# 14. 保持模型的完整性

大型系統領域模型的完全統一既不可行，也不划算。
在系統中的各個不同部分開發多個模型是必要的，但我們必需慎重地選擇哪些部分可以分開，以及他們是什麼關係。
我們需要用一些方法來保持模型「關鍵部分」的高度統一。

統一的風險：
1. 一次嘗試對遺留系統做過多的替換
2. 大專案可能會陷入困境，因為協調的開銷太大了，超出了這些專案的能力範圍
3. 有特殊需求的程式不得不區就無法滿足其需求的模型，只能把行為移至他處
4. 模型會變得過於複雜且難以使用

我們需要標記出不同模型之間的邊界和關係。
「識別、溝通和選擇」模型邊界及關係。

### 模式：BOUNDED CONTEXT 限界上下文
[[Bounded Context（有界情境）]]

任何大型專案都會存在多個模型。而當以不同模型為基礎的程式碼被組合後，軟體就會出現 bug、變得不可靠和難以理解。團隊成員之間的溝通變得混亂。人們往往搞不清楚一個模型「不應該」在哪個上下文之中使用。

**一個模型只在一個上下文中使用**。模型上下文是為了保證該模型中的術語「具有特定意義」而必須要應用的一組條件。
明確地定義模型所應用的上下文。根據團隊的組織、軟體系統的各個部分以及物理表現（程式碼和資料庫）來設定模型邊界。在邊界內嚴格保持一致性。

在Context中，要保證模型在邏輯上統一，而不用考慮他是不是適用於邊界之外的情況。
在其他Context中，會使用其他模型，這些模型具有**不同的術語、概念、規則、和Ubiquitous Language的技術用語**。

> [!NOTE] Bounded Context 不是 Module
> 他們是具有不同動機的不同模式，雖然他們很常被如此劃分。
> 人們會在一個模型中用Module來組織元素，他們不一定要表達劃分Context的意圖。

### 範例：預訂系統的上下文

#### 識別Bounded Context中的不一致
語言上的混亂、以編碼的介面（coded interface）不匹配...  都是徵兆。

##### 假同源 false cognates
當兩個定義都與同一個領域方面相關ㄝ而只是在概念上稍微有區別時，這種衝突更難以發現。

### 模式：CONTINUOUS INTEGRATION
定義完一個Bounded Context之後，必須讓他保持合理。

Continuous Integration是指把一個上下文中的所有工作足夠頻繁地合併在一起，並使他們保持一致，以便當模型發生分裂時，可以迅速發現並糾正問題。

建立一個把所有程式碼和其他實作作品頻繁地合併在一起的過程，並透過自動化測試來快速檢查模型的分裂問題。堅持使用Ubiquitous language，以便在不同人的腦海中演變出不同的概念時，使所有人對模型都能達成一個共識（a shared view）。

Continuous integration可以在任何單獨的Bounded Context中使用，只要他的工作範圍大到需要兩個人以上的人去完成就可以。

### 模式：CONTEXT MAP
Bounded Context之間的程式碼重用是很危險的，應該避免。功能和資料的整合必須要透過轉換（translation）去實作。

在每個Bounded context中，都將有一種一致的Ubiquitous language的方言（dialect）。我們需要把Bounded context的名稱添加到該方言之中，這樣透過明確Context就能清楚地討論任意設計部分的模型。
簡單來說就是為Bounded Context命名。

Context Map 不用拘泥於任何形式。可以用視圖，可以用較多的文字描述，或是討論就夠了。

如果發現模型不一致時，不要急著描述，精確地從全域角度來解決混亂。最重要的任務是畫出一個清晰的Context map。

### 範例：運輸應用程式中的兩個Context

```java
Booking_TransportNetwork_Translator
convertSpec(RouteSpecification spec): List  // Booking -> TransportNetwork
convertPath(List nodePath): Itinerary  // TransportNetwork -> Booking
```
這是兩個團隊必曲一起維護的物件。設計應該使其易於單元測試，因此最好讓兩個團段合作開發一個測試套件。除此之外，他們可以採用不同的方式各自開發。

```java
// Routing Service
public Itinerary route(RouteSpecification spec) {

	Booking_TransportNetwork_Translator translator = new Booking_TransportNetwork_Translator();

	List constraintLocations = translator.convertConstraints (spec);
	
	// Get access to the NetworkTraversalService
	List pathNodes = traversalService.findPath(constraintLocations);

	Itinerary result = translator. convert (pathNodes);
	return result;
}
```

與其他Context和諧共存的一個秘訣是擁有「有效的介面測試集」。
我們很容易設計一組自動測是集來把Route Specification輸入到Routing Service之中，並檢查回傳的Itinerary。


### 測試Context的邊界
對各個Bounded Context的聯絡點的測試特別重要。測試有助於解決「轉換時所存在的一些細微問題」以及彌補「邊界溝通上存在的不足」。

### Context Map的組織與文件化
1. Bounded Context應該有名稱，以便討論，以及放入Ubiquitous language。
2. 每個人都應該知道邊界在哪裡，並且能夠分辨出任何程式碼片段的Context。

用Module是一個簡單的方式去區別Context。

## Bounded context之間的關係
把兩個模型關聯起來的眾多策略。把模型連接到一起之後，就能夠馬正個企業包括在內。
模式有兩個目的：
1. 為成功地組織開發工作設定「目標」
2. 為描述現有組織提供「術語」

### 模式：SHARED KERNEL
當不同團隊開發一些緊密相關的應用程式時，如果團隊之間不進行協調，即使短時間內能夠快速緊展，但他們開發出的產品可能無法結合。
最後不得不花飛大量精力在轉換層上（translation layers），並頻繁改動。這樣不如一開始就使用Continuous integration。

從領域模型中選出兩個團隊都同意共用的一個子集。這部分明確共用的內容具有特殊地位，一個團隊在「沒另一個團隊商量的情況下」不應擅自改動他。

共用核心必須整合自動測試套件，因為修改共用核心時，必須要通過兩個團隊的所有測試。
通常團隊先修改各自的共用核心副本，然後每隔一段時間與另一個團隊的修改進行整合。
例如：每天Continuous integration的團隊，可以每週進行一次核心的合併。

Shared kernel 通常是Core Domain，或是Generic subdomain，也可能兩者兼具。
Shared kernel 的**目的是減少重複，不是消除重複**。


### 模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM
一個子系統主要服務于另一個子系統。依賴是單向的，服務與任務都不同，無法共用程式碼。

下游團隊依賴於上游團隊，但上游團隊不負責下游團隊的產品交付。

在兩個團隊之間建立一種明確的客戶／供應商關係。下游團隊相當於上游團隊的客戶。
根據下游團隊的需求來協商「需要執行的任務」並未這些任務做預算，以便每個人都知道雙方的約定和進度。
兩個團隊**共用開發「自動化接受度測試」**，來驗證預期的介面。
把這些測試加到上游團隊的測試套件中，以便作為其持續整合的一部分。這些測試使上游團隊在作出修改時「不必擔心」對下游團隊產生的副作用。
客戶團隊在與供應商團隊合作的過程中，應該要開發「自訂接受度測試」來驗證所遺忘的介面。上游團隊把這些測試作為表準測試套件的一部分來執行。任何一個團隊在修改這些測試時都需要與另一個團隊溝通，因為**修改測試就意味著修改介面**。

#### 範例：收益分析與預定
現在有預定團隊與收益分析團隊。收益分析團隊需要向預訂應用程式中獲取大量訊息。預定應用程式並不依賴收益分析。

下游的需求：
1. 一些資料（任何預定操作都不需要這些資料）
2. 資料庫模式具有一定穩定性（或只少具有可鬧的變更通知機制），或者一個用於匯出的實用程式


### 模式：CONFORMIST 跟隨者
當上游／下游關係的團隊不歸同一個管理者指揮時，Customer/Supplier team這樣的合作模式就不會奏效。勉強使用只會對下游團隊造成麻煩。

透過嚴格遵從上游團隊的模型，可以消除在Bounded Context之間進行轉換的複雜性。雖然這會限制下游設計人員的風格，且可能得不到理想的應用程式模型，但選擇Conformity模式可以極大地簡化整合。
與供應商共用Ubiquitous language。供應商處於統治地位。

Conformist模式類似於Shared kernel模式。區別在於「決策制定」和「開發過程」不同，一個高度協調，一個是針對一個「對合作不感興趣的團隊」進行整合。


### 模式：ANTICORRUPTION LAYER
我們需要在不同模型的關聯部分之間建立轉換機制，這樣模型就不會被「未經消化的外來模型元素」所破壞。

建立一個隔離層（isolating layer），以便根據「客戶自己的領域模型」來為客戶提供相關功能。
這個層透過「另一個系統的現有介面」與其進行對話，而只需要對那個系統做很少的修改，甚至無需修改。
在內部，這個層在兩個模型之間進行必要的雙向轉換。

#### 設計Anticorruption layer的介面
建構一個全新的層來負責兩個系統之間的「語意轉換」。
把外部系統表示為一個「單獨的元件」可能是沒有意義的。
最好是使用多個Service（或偶爾使用Entity），其中每個Service都使用我們的模型來旅行一致的職責。

#### 實作Anticorruption layer
一種方法是實作為Facade, Adapter和轉換器（translator）的組合，外加兩個系統之間進行對話所需的「通訊和傳輸」機制。

Facade並不會改變底層系統的模型。他應該「嚴格按照另一個系統的模型」來編寫。
Facade應該屬於另一個系統的Bounded Context，他只是為了滿足你的專門需要而呈現出的一個更友好的外觀。

Adapter是一個包裝器（wrapper），它允許客戶使用另外一種協定，這種協定可以是行為實作者不理解的協定。當客戶向配接器寄送一條訊息時，Adapter把訊息轉換為一條「在語意上相同」的訊息，並將其寄送給「被配接者（adaptee）」。

```
elegant class -> service -> adapter -> facade -> messy class
```

##### 其他需要考慮的因素
- Anticorruption layer可以是雙向的，為了使其可以使用，另一個系統有時是需要修改的。
- 系統位於不同伺服器時，可能需要通訊機制。可能在Facade前後實作。
- 如果有權存取另一個子系統，對他進行少許的重構會使工作變得容易。如果可以的話，先從編寫自動測試開始
- 當需要進行廣泛的整合時，轉換的成本會直線上升。我們可能亦對正在設計的系統做出選擇，使之靠近外部系統，以便使轉換容易。如果這種方法看起來是**大部分重要問題的最自然的解決方案**，那麼可以考慮採用Conformist模式，消除轉換
- 如果另一個系統很整潔，可能就不用Facade。

因此我們可以：
- 在不替換現有功能的情況下增加新功能
- 持續操作合併的系統
- 進行新舊系統的逐步過度

#### 關於防禦的故事
作者以萬里長城舉例，他起到了很好的保護效果，卻也使一個朝代破產、甚至可能滅亡。
隔離策略的益處必須平衡他所產生的代價。


### 模式：SEPARATE WAY

整合總是代價高昂，而有時獲益卻很小。
如果兩個功能部分並不需要互相呼叫對方的估能，或者這兩個部分所使用的物件並不需要進行互動，或者他們操作期間不共用資料，那麼整合可能就是沒有必要的。
僅因為特性再用力中（use case）相關，並不一定等於他們必需整和在一起。
**宣告一個與其他上下文毫無關係連的Bounded Context，使開發人員能夠在這個小範圍內找到簡單、專用的解決方案**。


### 模式：OPEN HOST SERVICE
如果每個context之間都要轉換層，那會太多了。

定義一個協定，把你的子系統作為一組Service供其他系統存取。開放這個協定，以便所有需要與之整合的人都能使用它。
有新的整合需求時，就增強並擴充這個協定。
有特殊需求的話就使用一次性的轉換器來擴充協定。

這種通訊行是很寒一些共用的模型詞彙，他們是Service介面的基礎。
這樣，其他子系統就變成了與Open Host的模型相互連接，而其他團隊則必須學習Host團隊所使用的專用術語。


### 模式：PUBLISHED LANGUAGE
把一個良好文件化的、能夠表達出所需領域資訊的「共用語言」作為公共的通訊媒介，必要時在其他資訊與該語言之間進行轉換。
書中舉了「CML Chemical Markup Language」作為例子。不管開發人員用什麼語言寫，只要能夠轉換成CML的形式，最終就能互相引用。

這也讓我想到 Language Server Protocol，它讓不同的程式語言與背後的服務可以透過統一介面媒合。不過概念上應該還是不一樣。一個是文件，一個是公開的接口。


### 選擇你的上下文策略
接下來文中列出許多情境，分析我們適合用哪種上下文，以及哪些邊界關係。

大Bounded Context
- 用一個統一模型來處理更多任務時，使用者任務之間的流動更順暢
- 一個內聚模型比兩個不同模型加上他們之間的映射來的容易理解
- 兩個模型的轉換很難
- 共用語言可以使團隊之間的溝通更清楚
小Bounded Context
- 開發人員的溝通開銷減少
- 整體規模較小，更容易Continuous integration
- 比較不需要更加通用的抽象模型（技巧有難度）
- 可以滿足特殊需求

#### 部署
當資料轉移很花時間，或分散式系統無法同步更新時，即使是單一Bounded Context的元件部署也是很困難的，這會導致程式碼和資料有兩個版本共存。 
當兩個Context透過一個轉換層連結時，要更新其中一個Context，新的轉換層要為另一個Context提供相同的介面。
Shared Kernel需要進行更多的協調工作。


## 轉換
### 整合
#### separate way -> shared kernel
#### shared kernel -> continuous integration
### 規範
#### open host service -> published language


# 15. 精煉
模型就是知識的精煉。

領域模型的戰略精煉（strategic distillation）包括以下部分：
1. 協助所有團隊成員掌握系統的總體設計，以及各部分如何協調工作
2. 找到一個具有適度規模的核心模型並把它加到Ubiquitous language之中，促進溝通
3. 指導重構
4. 專注於模型中最有價值的部分
5. 指導外包、現成元件的使用以及任務委派

## 模式：CORE DOMAIN
當我們分門別類地為人們安排工作，限定到具體的模組，知識的傳遞就更少了。這種劃分導致難以平滑整合、靈活分配工作。

對模型進行提煉。找到Core Domain並提供一種容易區分的方法，把它與那些產生輔助作用的模型和程式碼分開。最有價值和最專業的概念要輪廓分明。盡量壓縮Core Domain。
讓最有才能的人來開發Core Domain。

如果某個設計部分需要保密以便維持競爭優勢，那麼他就是你的Core Domain。


### 選擇核心
我們需要關注的是那些能夠「表示業務領域」並「解決業務問題」的模型部分。
隨著開發，我們能夠把一些概念分離，只留下專有的部分在Core Domain之中。
或者，起初認為核心的物件會逐漸被證明只是支援用的。

### 工作的分配
技術強的人員往往缺乏領域知識，這使他們遠離了能學到領域知識的工作。
為了打破惡性循環，建立一個由開發人員和領域專家組成的聯合團隊。

自主開發軟體的最大價值來自對Core Domain的完全控制。
好的框架可能會提供「滿足你的專門需求」的高水準抽象，它可以解省開發那些更通用的部分，使你專注於Core。
但若它對你的約束超出了這個限度，可能是因為：
1. 你正在失去重要的軟體資產，我們應讓「限制性的框架」退出Core Domain
2. 框架處理的部分不是你所認為的核心，應重新劃定Core Domain的邊界
3. 你的Core Domain並沒有特殊需求。應考慮用風險更低的解決方案，例如購買軟體並與你的應用程式整合

## 模式：GENERIC SUBDOMAIN 通用子領域
模型中充斥著大量眾所皆知的一班原則，或是專門的細節，這些細節並不是我們的著要關注點。而只是產生支援作用。
然而不論他們多麼的通用，他們對實作系統和充分表達模型都是非常重要的。

例如：
- 各行各業都需要某種形式的企業組織圖。
- 常用的財務事項，可以用一個通用的會計模型。
- 時期、時間功能。

因此：
識別出那些與專案意圖「無關」的內聚子領域。把這些子領域的通用模型提取出來，並放到單獨的Module之中。任何專有的東西都不應放到這些模組之中。

分離出來之後，他們的優先順序應低於Core Domain的優先順序。不要派核心開發人員來完成這些任務。
可以考慮為這些通用子領域使用：
1. 現成的解決方案
	購買現成的解決方案，或使用open source code
2. 「公開發布的模型 Published Mode」。
	如果領域中已經有了一種非常正式且嚴格的模型，那麼就使用它。**會計和物理學**是我們立刻能想到的兩個例子。這些模型不僅精簡和健壯，而且被人們廣泛理解，因此可以減輕培訓負擔。
3. 把實作外包出去
4. 內部實作

####  範例：兩個與時區有關的故事

| 運輸專案的策略                                                                                                                      | 保險專案的策略                                                                                                                                        |
| ---------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| 優點<br>• GENERIC模型與 CORE 分離。<br>• CORE 模型較成熟。因此資源的轉移不會妨礙它。<br>• 明確知道需要什麼功能。<br>•為跨國的排程提供了關鍵支援功能。<br>• GENERIC模組的任務使用了短期程式設計師。 | 優點<br>• GENERIC 模型與 CORE 分離。                                                                                                                   |
| 缺點<br>• 最好的程式設計師沒有從事核心工作。                                                                                                    | 缺點<br>• CORE 模型未被開發出來，因此關注其他問題導致核心模型繼續被忽略。<br>•由於需求不明確，所以試圖開發一個能滿足所有需求的模組，而實際上只需簡單地提供北美地區的時區轉換功能就足夠了。<br>• 安排長期工作的程式師來執行這項任務，他們本來應該成為領域的知識儲存庫。 |

### 通用不等於重用
不要太特別關注程式碼的在使用性 reusability，這會違反精煉的基本動機：我們應該盡可能把大部分精力投入到Core Domain工作之中，只在必要時才在支援性的Generic Subdomain中投注工作。

重用也不一定總是程式碼的重用，通常是更高級的重用：模組的重用。
當使用公開發布的設計或模型時就是如此。
即便如此，我們也不必開發成「萬能的模型」，只要把業務所需的那部分建模並實作即可。

**即使我們不需考慮再使用性，通用子領域的設計必須嚴格地現定在通用概念的範圍之內。**
行為專用的概念若不屬於Core Domain，就是屬於他們自己更專業的子領域。而這些模型比通用子領域更有價值。


## 模式：DOMAIN VISION STATEMENT
願景說明會展示出應用程式為組織帶來的具體價值。
Domain vision statement就是模仿這類文件所建立的，但他關注的重點是領域模型的本質，以及如何為企業帶來價值。
寫一份Core Domain的簡短描述以及他將會創造的價值，也就是「價值主張」(value proposition)。那些不能將你的領域模型與其他領域模型區隔的方見就不要寫了。展示領域模型是如何實作和均衡各方利益的，這份描述要盡量精簡。盡早寫出來，隨著新的理解隨時修改他。


| 以下內容是DOMAIN VISION STATEMENT 的一部分                                                                                                                                                                                                                        | 以下內容雖然很重要，但它不是DOMAIN VISION STATEMENT 的一部分                                                                                                                                                                                                                                                           |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 航班預訂系統<br><br>•模型可以表示出「乘客的優先順序」和<br><br>「航班預訂策略」，並根據靈活的政策來平衡這些方面。乘客模型應該反映出<br><br>表示出「乘客的歷史記錄」、「參與過的特殊活動」，以及「與戰略企業客戶之間的關係」等。<br><br>-   表示出不同使用者的不同角色（例如：  <br>    乘客、代理商、經理），以便豐富關係模型，並為安全框架提供所需的資訊。<br>- 模型應該支援高效率的「航線/座位搜尋」，並與其他「已建立的航空預訂系統」整合。  <br> | 航班預訂系統<br><br>-   使用者介面應該兼顧「新舊使用者」，讓舊使用者能夠快速流暢地操作，讓新使用者也能容易使用。<br>- 系統將提供Web 存取，可以把資料傳輸到其他系統，或透過其他的UI提供存取，因此介面應該用XML來設計，並使用轉換層來服務Web 頁面或把資料轉換到其他系統之中。<br>-   彩色的動畫logo 將快取到客戶的機器上，以便將來存取時能夠快速顯示。<br>- 當客戶提交預訂時，在5秒鐘內提供可以看到的確認資訊。<br><br>• •   安全框架將驗證使用者的身分，然後根據「分配給特定使用者角色的許可權」來限制他能夠存取的具體特性。  <br> |


基本上像在用文件的方式去描述領域模型的業務邏輯。


## HIGHLIGHTED CORE
不同的人會有不同的理解，甚至同一個人在不同的時間也會有不同的理解。如果我們總是要不斷過濾麼形以便識別出關鍵部分，那麼就會分散本應該投入到設計的精力，而且這還需要廣泛的模型知識。
因此，**必須讓Core Domain變得更容易被分別出來。**

### 精煉文件
- 他可能是最核心概念物件的清單
- 可能是描述這些物件的圖，顯示他們最重要的關係
- 可能在抽象層次上或透過範例來描述基本的互動過程
- 可能用UML圖、序列圖、非標準的圖、文字解釋或這些元素的結合

精煉文件不是完備的文件。他是一個最簡單的切入點，描述並解釋核心，並提供更近一步提供研究這些核心的部分的理由。

編寫一個**絕對精簡**的文件（三到七頁，每頁內容不必太多），用於描述Core Domain以及Core元素之間的主要互動過程。

### 標明Core
把模型的主要儲存庫的Core Domain標記出來，不用特意去闡明其角色。使開發人員很容易就知道什麼在核心內，什麼在核心外。

### 把精煉文件作文過程工具
當模型或程式碼的修改影響到精煉文件時，需要與團隊其他成員一起協商。當對精煉文件作出修改時，需要立即通知所有團隊成員，而且要把新版本的文件分配給他們。

## 模式：COHESIVE MECHANISM 內聚機制
我們常會把複雜的演算法隱藏到方法之中，在為方法命明一個一看就知道用途的名字。
但計算有時會非常複雜，使設計開始變得膨脹。為了解決問題而提供的演算法的大量方法掩蓋了那些用於表達問題的方法。

把概念上的內聚機制分離到一個單獨的羽量級框架之中。要特別注意公式或那些有完備文件的演算法。用一個Intention revealing interface來暴露這個框架的功能。現在，領域中的其他元素就可以只專注於如何表達問題了（也就是「做什麼」），而把解決方案的負在戲節（也就是「如何做」）轉移給了框架。

避免在演算法中混雜「用於表達問題的領域模型」。
##### Core Domain或Generic Subdomain的模型描述的是「事實、規則和問題」。而Cohesive Mechanism則用來滿足規則或是用來完成模型指定的計算。

#### 範例：組織結構圖中的機制
領域模型要處理的父再性來自「便利組織樹中的特定分支」，從中搜尋特定的人員或關係。
這恰好是「成熟的圖系統」所能解決的問題。
用於圖操作的複雜程式碼被分離到一個「單純、以成熟演算法為基礎的」機制框架之中，進而可以進行單獨的維護和單元測試。

### GENERIC SUBDOMAIN 與 COHESIVE MECHANISM 的比較
GENERIC SUBDOMAIN 與 COHESIVE MECHANISM 的動機是相同的：
都是為 CORE DOMAIN 減輕負擔。差別在於兩者所承擔的職責的性質不同。GENERIC SUBDOMAIN 是以「描述性的模型」作為基礎的，它用這個模型表示出團隊會如何看待領域的某個方面。在這一點上它與 CORE DOMAIN 沒什麼區別，只是重要性和專門程度較低而已。
COHESIVE MECHANISM 並不表示領域，它的目的是「解決」描述性模型所提出來的一些複雜的計算問題。
模型提出問題（propose ），COHESIVE MECHANISM 解決問題（dispose）。
在實務中，除非你識別出一種正式的、公開發布的演算法，否則這種差別通常並不十分清楚，至少在開始時是這樣。在後續的重構之中，如果發現一些「先前未識別的模型概念」會使這種機制變得更簡單，那麼就可以把這種演算法精煉成一種「更純粹的機制」，或是轉換為一個GENERIC SUBDOMAIN。

### Mechanism是Core Domain的一部分
非常專業的演算法，如風險評估演算法，他無疑是Core Domain的一部分。事實上，演算法是高度機密的，甚至大部分核心開發人員都看不到他們。

分離出的Mechanism很有可能最終又回到Entity裡面。但這也不是繞遠路，而是得到更深層的模型。
實用的重構在保留「中間階段的重要價值」的同時，還能夠刪除「不必要的複雜性」。


## 模式：SEGREGATED CORE
為了增強Core的內聚性，把支援性元素（包含定義的不清楚的那些元素）從核心概念中分離出來。

重構得到Segregated core的步驟
1. 識別出一個Core子領域
2. 把相關類別移到新Module中，並依據與這些類別有關的概念為模組命名
3. 重構。把那些不直接表示概念的資料和功能的元素分離出來，盡量把他們與概念上相關的任務放在一起。但不要為了追求完美浪費太多時間
4. 對新的Segregated core module進行重構。使關係、互動變得更簡單、表達更清楚。並且最大限度地減少並澄清他其他Module的關係（這是一個持續進行的重構目標）

### 建立Segregated core的代價
- 可能會讓他與那些緊密耦合的非Core類別關係變得更晦澀複雜，但是會使Core Domain更清晰，利大於弊。
- 需要付出很大的工作量

*p.436*
當你的系統有一個很大的、非常重要的Bounded Context時，但模型個關鍵部分被大量支援性功能掩蓋了，那麼就需要建立Segregated Core了。

### 不斷發展演變的團隊決策
整個團隊需要不斷地更新新的理解（需要團隊的一致決策、足夠自律和協調）


## 模式：ABSTRACT CORE
我們處理大模型的方式通常會把它分解爲足夠小的子領域，並放到獨立的Module之中。
但有時這會使子領域之間的互動變得晦澀難懂。

如Module之間的大部分互動都可以再多行介面這個曾是上表現出來，那麼就可以把這些類型重構到一個特定的Core Module中。

**這裡並不是尋找技術上的技巧。只有當領域中的計本蓋念能夠用多形介面來表達時，這才是一種有價值的技術**。

把模型中最基本的概念識別出來，分離、設計這個抽象模型，使之能夠表達出重要元件之間的大部分互動。實作的類別可以放在「由子領域定義的Module 」之中。

## 深層模型精煉
精煉的目標是把模型設計得更明顯，使我們可以用模型簡單地把領域表示出來。

## 選擇重構目標
*p.444*
1. 觀察根本問題是否設計Core Domain或Core與支援元素的關係。如果確實射擊，那就要接受挑戰，首先修復核心
2. 當可以自由選擇重構的部分時，應先把Core Domain更好地提取出來，並把支援性的子令欲提煉成通用子領域


# 16. 大型結構
在一個大的系統中，如果因為缺少一種「全域性的原則」而使人們無法根據「元素在模型中的角色（這些模式被應用於整個設計）」來解釋這些元素，那麼開分人員就會陷入「只見樹木，不見森林」的境地。

設計一種應用於整個系統的規則（或角色和關係）模式，使人們可以透過他在一定程度上了解各個部分在整體中所處的位置（即使是在不知道個葛部分的詳細職責的情況下）。

一班情況下他會跨越多個Bounded Context，並耨過提供一種概念組織把「專案涉及的所有團隊漢子系統」緊密結合在一起。

## 模式：EVOLVING ORDER
一些技術架構確實能夠解決技術問題，如網路和資料持久化問題。但當我們在應用層和領域模型中使用框架時，他們往往會妨礙開發人員設計。

讓這種概念上的大型結構隨著應用程式一起演變，甚至可以變成一種完全不同的結構風格。不要依此過分限制詳細的設計和模型決策，這些決策和模型決策必須在掌握了詳細知識之後才能確定。

當發現一種大型結構可以明顯使系統變的更清晰，而又沒有對模型開發施加一些不自然的約束時，就應該使用這種架構。使用不合適的結構還不如不使用它，因此最好不要為了追求設計的完整性而勉強去使用一種結構，而應該盡可能精簡的方式解決所出現的問題。寧缺勿濫。

## 模式：SYSTEM METAPHOR
軟體設計往往非常抽象且難以掌握。開發人員和使用者都需要一些具體的方是來理解系統，並共用系統的一整個視圖。

當系統的一個具體類比正好符合團隊成員對系統的想像，並且能夠引導他們朝一個有用的方向進行思考時，就應該把這個類比用作一種大結構。圍繞這個隱喻來組織設計，並把他吸受到Ubiquitous language之中。但所有隱喻都不是完全精確的，因此應不斷地檢查隱喻受否過度或不恰當，當發現他產生妨礙時，要隨時準備放棄他。

## 模式：RESPONSIBILITY LAYER
如果每個物件的職責都是人為去分配的，將會沒有統一的指導原則和一致性，也無法把領域作為一個整體來處理。為了保持大型模型的一致，有必要再職責分配上實施一定的結構化控制。

注意觀察模型中的概念依賴性，以及領域中不同部分的變化頻率和變化原因。如果在領域中發現了自然的層次結構。就把他們轉換為廣泛的抽象職責。這些職責應該描述高層的目的和設計。

*p.457*
書中用較大的篇幅描述一個例子。
cargo shipping application 分成了三層架構：Capability, Operations, Decision Support

Operation包含公司的活動，無論過去現在未來。最明顯的物件是Cargo，他是公司大部分日常或動的焦點。Route Specification是Cargo不可或缺的部分。Itinerary是運輸計劃。

Capability反應宮寺在執行作業時所能利用的資源，包含Transit Leg, Customer

Decision Suport提供制定計劃和決策的工具。Router可以協助選擇運送貨物的最佳路見。

目前的依賴方向是Operation, Decision Support都依賴於Capability。

今天新增了個危險品運輸的規則：HazMatRoutePolicyService，他應該是一個屬於Decision Support的職責。所以為了遵從分層結構，**Cargo不能依賴HazMatRoutePolicyService**。

#### 選擇適當的層
想找到適當的Responsibility需要理解問題領域並反覆進行實驗。
對層進行「刪除、合併、拆分、衝新定義」等操作時，應尋找並保留以下一些有用的特徵：
1. 場景描述
	層應該能表達出領域的基本現實或優先順序，層應顯示出業務的優先順序
2. 概念依賴性
	較高的概念應依賴較低的層，低層不應獨立於高層
3. Conceptual contour
	不同層有不同變化的頻率或原因，那麼層應該能夠容許他們之間的變化

有些層是固定的：
- 潛能層 Potential
	潛能層不關心我們打算做什麼，而關心能夠做什麼。企業的資源及這些資源的組織方式是潛能層的核心
- 作業層 Operation
	我們正在做什麼？能利用潛能做哪些事？我們希望在這個層中看到自己的工作和活動

作業層可以引用潛能層，但潛能層不應該引用作業層。

- 決策支持層 Decision Support
	這個層是用來作出分析和制定策略的。他根據較低層的資訊進行分析
決策支持層可能是一個獨特的Bounded Context，並與作業軟體具有一種Customer/Supplier關係。

- 策略層 Policy
	規則和目標是什麼？
- 承諾層 Commitment
	我們承諾了什麼？這個能具有策略層的性質，因為他描述了一些指導未來運營的目標；但他也有作為作業層的的性質，因為承諾是作為後續業務活動的一部分而出現和變化的。

如果一個領域與上述討論毫無關係，所有分層可能都必須從頭開始。最後，我們必須根據直覺選擇一個起點，然後藉由Evolving Order來改善它。

## 模式：KNOWLEDGE LEVEL
Knowledge level是一組描述了另一組物件應該有哪些行為的物件。
建立自組不同的物件，用它們來描述和約束基本模型的結構和行為。把這些物件分為兩個級別，一個是非常具體的級別，另一個級別則提供了一些可讓使用者或超級使用者制定的規則和知識。

## 模式：PLUGGABLE COMPONENT FRAMEWORK
從介面和互動中提煉出一個Abstract Core，並建立一個框架，這個框架要允許這些介面的各種不同實作被自由替換。
通常只有在同領域實作了多個應用程式之後，才有機會使用Pluggable component framework。

# 17. 領域驅動設計的綜合運用
戰略設計的三個基本原則（上下文、精煉、大型結構）並非彼此的代替品，而是互為補充。

## 制定戰略設計決策的六個要點
#### 決策必須傳到到整個團隊
無論開發什麼系統，都不要用管理層所授予的權力來強制地推行戰略決策，而應該更加地關注開發人員與策略之間的實際關係
#### 決策過程必須收集回饋意見
戰略設計本身並不需要編寫很多程式碼，戰略設計真正需要的是「應用程式開發團隊的參與」。架構師可以聽取來自哥哥團隊的想法，並促進整體解決方案的開發。
#### 計劃必須允許演變

#### 架構團隊不必把所有最好、最聰明的人都吸進來
架構團隊不應排斥缺乏設計技巧但精通領域知識的開發人員。
#### 戰略設計需要遵守簡約和謙遜的原則
不要過度設計架構。我們應嚴格地約束自己，使設計出來的組織原則和核心模型精簡到只包含那些能夠顯著提告設計清晰度的內容。
#### 物件的職責要專一，而開發人員應該是通才
戰略設計工作必須由接觸編寫程式碼工作的人來完成。
過度專業化會削弱領域驅動設計的力量。