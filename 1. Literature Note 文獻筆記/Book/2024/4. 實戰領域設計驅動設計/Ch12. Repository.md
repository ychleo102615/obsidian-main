---
tags: []
date: 2025-03-23
time: 14:39
---
[[Part II： 模型驅動設計的建構區塊#6. 領域物件的生命週期#樣式：REPOSITORY]]
為每種需要全域存取的物件類型建立一個物件，這個物件相當於「該類型的所有物件」在記憶體中的一個集合的「替身」。
透過一個眾所皆知的全域介面來提供存取。
提供增加和刪除物件的方法。
提供根據具體條件來挑選物件的方法，並回傳屬性值滿足查詢準則的物件或物件集合。
只為那些確實需要直接存取的Aggregate root提供Repository。

一般而言，聚合型別與Repository之間存在著一對一的關係，然而，有時也會有兩種或多種不同聚合共享相同物件階層結構，因此可以共用同一個Repository。

嚴格來說，只有聚合才需要Repository。

Repository的設計可以分成兩類：
- 集合導向
- 持久性導向

## 集合導向Repository
此類Repository介面，無法察覺持久性技術的底層存在，從而**避免出現任何將資料存入或寫入儲存區的表述**。

但這種設計需要底層持久性機制的特殊支援，因此可能不適用你的情境。

在實作集合導向設計的Repository之前，了解他所模擬的集合Set運作原理是很重要的。無論背後採用的實際持久性技術為何，都不可以將同一個物件的實例重複加入。

> [!集合導向Repository的重點摘要]
> Repository要模擬的對象是Set集合的行為模式，無論後端實際的持久性機制實作技術為何，都不應該允許同一個物件的實例「重複加入」到Repository中。同時，編輯事件後也不需要再次存回Repository

##### 底層持久性機制的支援
1. 暗中於讀取時複製 Implicit Copy on Read
2. 暗中於寫入時複製 Implicit Copy on Write
這類持久性機制技術（如Hibernate）都可以協助我們建立傳統的集合導向Repository。

但是這類機制會在記憶體與執行效能上造成嚴重的負擔。

### Hibernate的實作

```java
public class HibernateCalendarEntryRepository implements CalendarEntryRepository {
	...     
	@Override     
	@SuppressWarnings("unchecked")
	public Collection<CalendarEntry> overlappingCalendarEntries(
		Tenant aTenant, CalendarId aCalendarId, TimeSpan aTimeSpan) {
		Query query = this.session().createQuery(
			"from CalendarEntry as _obj_ " +
			"where _obj_.tenant = :tenant and " +
			"_obj_.calendarId = :calendarId and " +
			"((_obj_.repetition.timeSpan.begins between " +
			":tsb and :tse) or " +
			" (_obj_.repetition.timeSpan.ends between " +
			":tsb and :tse))");
		query.setParameter("tenant", aTenant);
		query.setParameter("calendarId", aCalendarId);
		query.setParameter("tsb", aTimeSpan.begins(), Hibernate.DATE);
		query.setParameter("tse", aTimeSpan.ends(), Hibernate.DATE);
		return (Collection<CalendarEntry>) query.list();     
	}
	
	@Override
    public CalendarEntry calendarEntryOfId(
		Tenant aTenant,
		CalendarEntryId aCalendarEntryId) {
		Query query = this.session().createQuery(
			"from CalendarEntry as _obj_ " +
			"where _obj_.tenant = ? and _obj_.calendarEntryId = ?");
		query.setParameter(0, aTenant);
		query.setParameter(1, aCalendarEntryId);
		return (CalendarEntry) query.uniqueResult();
	}
	
    @Override
	@SuppressWarnings("unchecked")
	public Collection<CalendarEntry> calendarEntriesOfCalendar(
		Tenant aTenant, CalendarId aCalendarId) {
		Query query = this.session().createQuery(
			"from CalendarEntry as _obj_ " +
			"where _obj_.tenant = ? and _obj_.calendarId = ?");
		query.setParameter(0, aTenant);
		query.setParameter(1, aCalendarId);
		return (Collection<CalendarEntry>) query.list();
	}
	... 
}
```

## 持久性導向的 Repository

以「save」為主的Repository操作模式。

如果你的持久性機制將來極有可能會抽換，最好採用彈性較高的介面設計。
這樣做的缺點在於，當下的ORM工具會導致我們忘記要呼叫save()，直到Unit of Work被抽換掉時才會察覺。