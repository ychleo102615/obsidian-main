---
tags: []
date: 2024-12-08
time: 14:20
---
數字、字串、日期、時間、全名、貨幣、顏色、電話號碼、郵件地址...

#### 值物件的優點
用於測量、量化、描述事物的值物件，在建立、測試、使用、優化與維護上都很輕鬆方便。

我們應盡量使用值物件來建模而不是實體。實體在設計上也應偏向值物件的容器，而非其他子實體的容器。

# 值物件的特性

將領域概念建模為值物件時，首要之務是使用通用語言。
在決定一個概念是否為值物件時，應考慮：
- 可測量、量化或描述領域中的某樣事物
- 可保持不變性
- 將相關屬性組合成一個整體，建模一個概念整體（conceptual whole）
- 當測量或描述改變時可以被替換
- 可以使用值相等性與其他值物件進行比較
- 像協作方提供「無副作用行為」，不會對互動方造成影響

#### 測量、量化或描述
值物件的意義，不是領域中的一樣事物，而是某項事物的一個概念。
例：人與年齡。

#### 不可變
值物件可以持有對實體的參照，這是為了在組合式設計中實現不可變性、表達性以及便利性。
如果值物件的介面可以改變實體狀態，這種做法很有可能是錯的。

#### 概念整體
值物件可能擁有數個屬性，彼此之間互有關聯。**將它們組合在一起才能完整地表達測量或描述的內容**。
##### 「整體值模式（Whole Value pattern）」
「50000美元」包含「50000」和「美元」兩個屬性。將之拆開就會與原先表達的意思不同，甚至無意義。
name屬性也可以從String改為「ThingName」型別，在裡面封裝如大小寫管理的功能。
也不要對基本型別進行擴展、加入特定行為。例如擴展Double加上一個convertToCurrency的方法。
每個值類別都應是一個反映出內聚性的概念整體，並以通用語言精準地命名以表達概念。

#### 可替換性
不要因為想修改屬性而把實體作為建模選項，有可能替換掉整個物件就能解決問題。

#### 值相等性
聚合的唯一識別值也可以用值物件。
你正在設計的概念，必須是能夠與其他物件區分出不同之處的實體，還是可以用值相等性來分辨就可以了？如果概念不需要唯一識別值，那麼用值物件來建模即可。

#### 無副作用行為
[[Part III： 透過重構來加深理解#模式：SIDE-EFFECT-FREE FUNCTION]]
值物件的所有方法都必須是無副作用函數，因為不能違反不可變性原則。
在CQS中，這種函數稱作查詢方法。
```java
public FullName withMiddleInitial(String aMiddleNameOrInitial) {
	...
	String middle = aMiddleNameOrInitial.trim();
	return new FullName(
		this.firstName(),
		middle.substring(0, 1).toUpperCase(),
		this.lastName()
	);
}
```
##### 當實體以參數傳入值物件
最好不要改變實體的狀態。

# 最低限度整合
當上游Bounded Context的物件流入下游的Bounded Context時，可以使用值物件將下游Bounded Context中的這個概念進行建模，利用不可變的值物件，將下游模型需要負責處理的屬性數量及承擔職責減至最低。

上游的「身份與存取情境」中有User, Role等實體，傳到「協作情境」時，使用Moderator物件建立為值物件。

# 以值物件表示標準類型
標準類型用來區分同事物之不同類型。
例如定義用標準類型來定義世界貨幣的幣值：AUD, CAD, JPY, USD 等，可以避免出現不存在的貨幣。

# 值物件的驗證測試
重點在於如何呈現用戶端對領域模型中的各種物件的使用情境，以及用戶端在使用時是如何看待這些物件。

測試不變性：建立一個複製的物件，在測試的開始與結束測試原始物件與複製物件的相等比較。

# 動手實作
`BusinessPriority`
考量到持久性機制，宣告為`Serializable`類別。

### 建構子
##### 1. 在參數清單中完整列出設定或衍生值物件狀態所需要的屬性
初始化都透過在這個建構子中呼叫私有setter方法，這叫「自我委派（self-delegation）」
##### 2. 將現有的值物件複製出一個新的值物件，又稱「複製建構子」
複製建構子隊單元測試來說尤為重要，為了測試不變性。

### 策略模式
避免在命名規則上同採「get」開頭的JavaBean命名規則，`getValuePercentage()`這種用法完全是出於技術面觀點，`valuePercentage()`的命名才是人類容易閱讀又留長的語言表達方式。

### 標準物件方法
equals
排除null空值、確保類別相同、比較所有屬性相等之後，我們就會說兩個整體值是相等的。

hashCode
與equals()方法具有同等效力。只要符合值相等性，產生的雜湊值也會是相等的。

toString

#### 流暢的Java命名在哪裡？
*p.304*
Java String中的查詢方法名稱都沒有加上「get」前綴詞，而是採用更流暢的命名方式如：
```
charAt(), comparTo(), concat(), contains(), endsWith(), indexOf(), length(), replace(), startsWith(), substring()
```

# 值物件的保存
### 避免資料模型外洩的不良影響
不應該因持久化技術上的影響而不使用值物件來建模。資料模型應為輔助。

### ORM與單一值物件
將值物件的屬性個別存入其父實體所在列的不同欄位中。
property 可能是物件成員
attribute 數值成員
*p.331*

### 使用ORM將多個值物件序列化為單一欄位
把像是List, Set的資料（包含0個 1個 多個），利用Hibernate物件關聯對應，將整個物件集合序列化為純文字表示再存入一個欄位中。
可能的缺點：
##### 資料欄寬問題
以MySQL InnoDB引擎為例，VARCHAR的最大藍寬上限為65536字元數，單一資料列也有65536位于的限制。
Oracle資料庫的VARCHAR2/NVARCHAR2藍寬限制是4000，因此必須確保有足夠的欄位以便儲存整個實體。
##### 必須查詢
SQL查詢語法無法針對集合內的個別值物件元素的屬性進行查詢。
##### 需要使用者自訂類別
必須在Hibernate中設定一個使用者自訂類別，才能夠管理集合的序列化與反序列化。

### 利用資料庫實體與ORM保存多個值物件
如果找到更適合的持久性方案，就應該優先將領域概念建模為值類別，永遠不要考慮資料庫實體。
建立一個抽象類別，它擁有id。繼承他的值物件看不到這個id，但是Hibernate可以。
替換集合時要小心初心孤兒值物件，Hibernate Collection clear()可以清除。

### 利用資料表連結與ORM保存多個值物件
這種對應事單純地將集合中的值物件元素，報存到一個單獨的資料表中，再以父實體領域物件的資料庫識別值當作外部索引鍵來使用。
這種方法的好處在於，無需為了連結而在值類別內硬加上一個隱藏的代理鍵值。
缺點：
- 需要透過join查詢
- 使用Set作為集合時，值類別中的任何屬性值都不可為null空值
- 對應的值類別本身不能內含任何集合

### ORM與enum狀態物件
*p.322*