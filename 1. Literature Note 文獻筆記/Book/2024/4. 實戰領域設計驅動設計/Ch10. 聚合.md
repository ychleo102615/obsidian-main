---
tags: 
date: 2025-01-01
time: 21:49
---
乍看之下，聚合只是將實體與值物件以仔細規劃的的一致性邊界給組合在一起。但聚合是射擊模式中最難理解的一環。

## 將聚合運用於Scrum核心領域
書中的範例示範了兩種做法：

### 大群聚合
```java
public class Product extends ConcurrencySafeEntity {
	private Set<BacklogItem> backlogItems;
	private String description;
	private String name;
	private ProductId productId;
	private Set<Release> releases;
	private Set<Sprint> sprints;
	private TenantId tenantId;
	...
}
```
在多個用戶同時使用的時候會有問題。
如果只能一個一個請求處理，而每處理一個請求、其他使用者的請求都會被拒絕，實在是完全無法接受。

### 多個聚合
```java
public class Product {

	public void planBacklogItem(
		String aSummary, String aCategory,
		BacklogItemType aType, StoryPoints aStoryPoints) {
		...
	}

	public void scheduleRelease(
		String aName, String aDescription,
		Date aBegins, Date anEnds) {
		...
	}

	public void scheduleSprint(
		String aName, String aGoals,
		Date aBegins, Date anEnds) {
		...
	}
}
```
這些方法都屬於CQS理論中的命令類方法，也就是將新元素加到集合中、變更Product狀態，因此回傳void。

```java
public class Product {

	public BacklogItem planBacklogItem(
		String aSummary, String aCategory,
		BacklogItemType aType, StoryPoints aStoryPoints) {
		...
	}

	public Release scheduleRelease(
		String aName, String aDescription,
		Date aBegins, Date anEnds) {
		...
	}

	public Sprint scheduleSprint(
		String aName, String aGoals,
		Date aBegins, Date anEnds) {
		...
	}
}
```
重構過後，變為查詢類方法，並版眼工廠的角色；換句話說，每個方法都會建立出一個新的聚合實例，並回傳該實例的參照。

```java
public class ProductBacklogItemService ... {
	@Transactional
	public void planProductBacklogItem(
		String aTenantId, String aProductId, String Summary, String Category,
		String aBacklogItemType, String aStoryPoints) {

	Product product =
		productRepository.productofId(
			new TenantId (aTenantId),
			new ProductId(aProductId));

	BacklogItem plannedBacklogItem = 
		product.planBacklogItem(
			aSummary, aCategory,
			BacklogItemType.valueOf(aBacklogItemType),
			StoryPoints. valueof(aStoryPoints));
	backlogItemRepository.add(plannedBacklogItem);
}
```

這樣無論多少使用者同時請求，都能安然處理妥當。
但隨著時間過去，這種聚合會變得難以控制而不可收拾。


## 原則：在一致性邊界內建模真正的不變量

**不變量**（invariant又稱定則或稱不變條件）指的是必須維持一致性的業務規則。
其中一種就是常見的「交易階段一致性」，即變更的立即性、以及作業的不可分割性。
另外還有「最終一致性」。

一致性的邊界，將內部所有內容共同組合成了一套顧並不變的業務規則，任何操作都不能違背這條規則；至於變界以外的遺切是務，則都與此聚合無關。
換局話說，可以將「聚合」和「交易一致性邊界」視為相同的概念。

當交易階段提交出去時，邊界內的一切都必須保持一致。所謂妥善設計的聚合就是，不關出於何種業務理由對聚合做了任何變更，在同一個交易階段中，聚合的不變量都是一致的。
此外，在設計聚合時也必須將對交易階段的分析一併考慮進去。

設計使用者介面時，使用者的每次請求應該只針對一個聚合實例執行一道命令。如果使用者請求的內容執行太多命令，那麼應用程式就會被迫要一口氣修改多個不同的實例了。

聚合這個設計模式的核心念，不在於物件之間的關聯，而是在於一致性邊界。

## 原則：設計小聚合
採用大群聚合還會造成什麼影響？  即使交易階段正常，還是會影響效能及可擴展性。

這樣錯誤設計的根本原因出在便是錯的不變量，以激為了貪圖方便的群聚組合設計，結果導致交易階段、效能與可擴展性都出了問題。

最好的大小程度，應該以一個聚合跟實體（Root Entity）加上最低限度的屬性與值類別的屬性就好。

盡量將聚合內部建模為值物件是有很大好處的，例如，根據你選用的持久性機制，值物件可以跟隨聚合跟實體一同被序列化並儲存起來。但如果是實體就必須分開儲存、追蹤。
採用實體的成本明顯比較高。

文中舉了一個專案為例子，系統中70%的聚合，都是僅由一個包含紹述值物件屬性的聚合跟實體組成，其餘30%頂多只有兩道三個實體。

小群聚合不僅效能好，可擴展性家，也符合交易階段的管理需求，不容易在提交時出現衝突。

### 不要無條件採納使用案例

每當面對一個新的使用案例，都代表有可能會重構聚合。
團隊需要抱持著懷疑的態度來看待使用情境的描述，並隨時提出質疑，尤其是當遵循著這些描述卻導致了不合適的設計結果。

新的使用案例會具體說明最終一致性以及可接受格更新延遲來應對。


## 原則：以識別值存取其他聚合
在設計聚合時，我們會一望用物件組合的結構來進行「遍歷物件關聯」。但這並非此設計模式的用意。
一個聚合可以持有對其他聚合跟的參照，但這不代表被參照的聚合物件也被踏入同樣的一致性原則邊界內。
有什麼方法是既能保有必要的物件關年，又能避免交易階段的錯誤或不適當的設計，還可以讓模型具備好的效能與可擴展性？

### 透過識別值整合聚合
這種時候我們就應該優先使用外部聚合的全域唯一識別值作為參照，而不是直接持有對物件的參照（或稱「指標」）。

```java
public class BacklogItem extends ConcurrencySafeEntity {
	private ProductId productId;
}
```
透過這種非預先仔入物件的參照方式所建立的聚合，自然體積較小，也省去載入時間和記憶體的佔用。

### 遍歷模型的方式
在聚合內部用Repository來查找其他聚合，這種技巧稱為**離線模式領域模型**（Disconnected Domain Model 又稱失聯領域模型），相當於延遲載入的一種形式。
另一種做法是，在觸發聚合行為之前，先夠過Repository或領域服務來查找這些有依賴關係的物件。可以讓用戶端的應用程式負責這件工作，在把物件分配給聚合。
如果是非常付的依賴關係或領域高度相關的情況，將聚合放在領域服務處理或許是最好的方法。
無論如何，都不允許在單一請求中修改多個聚合。

這麼做的缺點在於，會使得組裝並呈現出使用這介面是圖變得更困難。會需要多個Repository。

### 可擴展性與分散性
由於聚合現在是以唯一識別值作為參照，因此持久性狀態就有很大的彈性空間，能夠有效應對龐大系統的需求。
透過允許對聚合資料儲存持續重新分割，就能實現近乎無限的可擴佔性。

分散式系統中的交易階段並非不可分割，不同的系統會將多個聚合狀態調整以達到最終一致性。


## 原則：在邊界外部使用最終一致性

「任何跨越Aggregate的規則將「不要求」每時每刻都保持最新狀態。透過事件處理、批次處理或其他更新機制，這些依賴會在一定的時間內被解決」

有一種實用的做法能提供最終一致性：由執行命令的聚合對一個或多個非同步訂閱方發布領域事件。

這些訂閱方會各自一識別值曲和聚合實例，並根據他執行業務行為，在各自的交易階段遵照個前面所述的聚合原則，每一個交易階段修改一個聚合實例的狀態。

若用戶端發生並行爭用，只要訂閱方不回報執行成功，此修改就可以再重試一次（重發一次事件），直到達到一致性或是重試次數上限。

要採用交易階段的一致性還是最終一致性，可以查看使用案例然後自問，這個情境中，是否應該由執行了業務行為的使用者來維持資料一致性，是就採用交易階段一致性；反之，這是其他使用者或系統該做的，採用最終一致性就好。
有這樣的認知不僅讓我們更容易做出決策，還能進一步加深對領域的了解，挖掘出系統的中真正的不變量。


## 原則總有例外

在某些合理情況，單一交易階段作業也會變更多個聚合實例的狀態。

### 為了使用者方便
例如，為了讓使用者能夠一次批量形式定義多件事物之間的共用屬性。
e.g. 團隊成員想要一口氣建立多個待辦清單香木，此時使用者介面會允許在單一區塊上填寫所有共通屬性，面去重複的操作，然後再個別輸入每個待辦清單上個個別屬性，最後再一次性地興建上去。

一次建立一個與一次大量建立多個聚合並無差異，這種情況下允許有例外。

### 技術面的障礙
為了落實最終一致性，我們勢必得藉助某種程度的輔助或處理功能，像是訊息交換機制、計時器、背景執行緒等。萬一專案為採用這些機制，可能就會陷入大群聚合設計中，被迫遵循不可分割的單一交易階段原則。

如果在又物流城中，一名使用者永遠只會用到一組特定的聚合實例而已，那在單一交易階段中修改多個聚合實例似乎也是合理的。，因為這樣才能避免違反不變量以及交易階段的矛盾衝突。

### 全域交易
另一種可能的情況，受限於技術或企業政策的影響，導致我們必須採用全域交易、兩階段提交方式。

### 為了查詢效能