---
tags: []
date: 2024-12-10
time: 23:14
---

> [!NOTE]
> 有時，物件不是一個事物。

領域中的服務是為了完成特定領域任務而存在的一種「無狀態操作」。
當某項操作感覺不適合用聚合或值物件的方法時，通常就是使用領域模型服務的最好指標。

## 辨認何者是領域服務（要先知道什麼不是領域服務）

我們聽到「服務」時，會直覺想到一個能夠提供遠端用戶與腹瀉桶互動的大型物件，基本上這就是在描述[[Ch4. 架構#服務導向架構 Service-Oriented Architecture SOA]]中的「服務」。
這種服務強調的是以系統層面的「遠端程序呼叫（remote procedure call, RPC）」或是「訊息導向的中介軟體（message-oriented middleware, MoM）」。

但這些都不是領域服務。
也不是「應用服務（Application Service）」。我們不會把業務邏輯放在應用服務中。而是把業務邏輯放在領域服務中。
**應用服務通常是領域模型的自然用戶端，所以也是領域服務的直接用戶端**。

在什麼情況下，一項操作會不屬於實體或值物件呢？包括但不限於：
- 執行某個重要的業務流程
- 將領域物件從一種組成形式轉換成另一種組成形式
- 以多個領域物件作為輸入進行計算，產生出一個值物件
「計算」或許算在「重要業務流程」之下，這種業務流程十分常見，且常需要兩個以上不同聚合作為輸入。

## 確認對領域服務的需求
不要過度使用，否則可能會造成貧血領域模型的問題。

[[Ch5. 實體#探索實體與屬性]] 這邊有提到租戶授權使用者的情境。
- 租戶不該承擔與使用者相關的職責（處理密碼）
- 使用者不應處理與加密相關的概念
與領域相關的知識根本就不該洩漏到用戶端。

```java
DomainRegistry.authenticationService()
.authenticate(aTenantId, aUsername, aPassword);
```

## 領域服務建模
決定一個領域服務是否需要分離介面（Separated Interface, Fowler）
```java
public interface AuthenticationService {
	public UserDescriptor authenticate(
		TenantId aTenantId,
		String aUsername,
		String aPassword
	);
}
```
這個介面放置在與身份相關的聚合所在的模組中。
實作此介面類別的位置則要是情況而定。可能會將這種偏向技術解決方案的實作類別放在領域模型之外，像是基礎設施層的模組中。
# WTF 可以這樣分開職責的嗎

考慮到不同的租戶可能用不同的安全控管標準與需求，所以保留多種實作的彈性空間是有必要的。

#### 實作類別的命名原則
注重模組化目標的人，自然會將介面與實作類別歸在不同的套件中，例：把`EncrytptionService`介面歸在領域模型中，而將`MD5EncryptionService`歸在基礎設施層。
這樣就沒有必要把「Impl」後綴作為命名原則。



## 測試領域服務
測試應該反映出領域的使用方式。
測試先行不是絕對必要的，這樣做可能會限制了正確的建模關注點。


