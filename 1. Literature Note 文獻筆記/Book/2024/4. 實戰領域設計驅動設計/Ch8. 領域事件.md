---
tags: []
date: 2024-12-15
time: 17:50
---
## 領域事件的時機與原因
領域事件本身就是一種完整的領域模型，用於代表在這領域中所發生的某件事。

## 事件建模
事件若是經由聚合的命令而產生，則通常是用該命令的名稱來命名事件，因為事件的發生來自命令，將命令加到事件名稱中正好用以陳述發生時的情況。

命令操作：`BacklogItem#commitTo(Sprint aSprint)`
事件結果：`BacklogItemCommitted`

事件的名稱應該反映過去發生的事件，不是現在正在發生，而是已經發生了。

應該具備什麼屬性？
首先是時間戳記。
```java
public interface DomainEvent {
	public Date occuredOn();
}
```

接下來需要加入其他具代表意義的屬性，用以呈現事件的內容，這樣才能再現事件。
一般來說，會包括造成事件的聚合實例或足以辨識出該聚合實例之識別值。

```java
public class BacklogItemCommitted implements DomainEvent {
	private Date occuredOn;
	private BacklogItemId backlogItemId;
	private SprintId committedToSpriteId;
	private TenantId tenantId;
}
```
這邊id都是值物件，參考[[Ch5. 實體#探索實體與屬性]]

Sprint透過六角架構中的應用服務來更新交易。

在對事件加上行為能力之前，如同值物件，確保這些事件無副作用，不會改變狀態、保護物件的不可變性。


### 結合聚合的特性
如果事件的產生不設計模型中聚合實例，此時我們可以將事件建模為一種聚合，保存於該事件的Repository中。這個Repository不可刪除該事件。

這類事件依然具備不可變性，但可能會被夾上唯一識別值（或以事件具備的屬性組合為唯一識別）。
用戶端可以透過互叫一個領域服務來產生事件。

### 識別值
當屬性組合不足以進行區分，才需要對事件指定一個唯一識別值。
發佈領域事件時，訊息基礎設施再轉發事件時就可能需要唯一識別值，因為某些時候可能出現單一訊息發佈多次的情況；訊息基礎設施確認訊息成功送出之前，訊息發送器遇到障礙，就會發生這種情況。

對接收端來說，需要檢查這些訊息是否曾經接收過，並忽略重複接收的訊號。


如果事件奔身被建模並保存於Repository，才有需要再事件中加上equals(), hashCode()等方法。

## 由領域模型發布事件

任何作為中介軟體 middleware 的訊息基礎設施，都不應知道領域模型的存在。我們應避免他們產生耦合關係。

一個有效的做法是觀察者模式，可以在不與領域模型外部元件產生耦合的情況下發布領域事件。

### 發布者
最常見的使用方式是由聚合產生事件並發布出去。發布者位於某個模組內，但並非業務領域的某個概念，而是為聚合提供了一個可以對事件訂閱方發出通知的簡單功能。

### 訂閱者
一般是應用服務或是領域服務來向領域事件註冊訂閱者。

##### 當心Event Handler的影響
不要再收到事件通知的處理中修改另一個聚合實例，這會破壞單一交易階段僅能修改單一聚合實例的原則。（參考第十章聚合）

事件是領域層級的概念，不僅限於某一個Bounded Context之內，因此事件發布的規範合約應該是企業層級甚至更高層級的範疇。

## 發布事件給遠端Bounded Context
通知遠端的方法，最著要還是透過某種訊息機制，而且需要企業層級的訊息機制。

中介軟體
如Active MQ, RabbitMQ, Akka, NServiceBus, MassTransit

在不同Bounded Context之間採用這類訊息機制時，必須確保最終一致性才行，這點不容置喙。

### 訊息基礎設施的一致性
有兩件事必須隨時保持一致：領域模型所使用的持久性儲存區，以及訊息基礎設施用於轉發事件的持久性儲存區。
如何確保一致？

1. 共用同樣的持久性儲存區。優點在於效能高，缺點在於有些人偏好把這兩塊分開
2. 讓兩者受到一個全域的XA交易階段（兩階段提交）管理。成本高且效能差。
3. 在相同儲存區中，建立一個特殊的儲存區域來保存事件，也就是Event Store。

### 自主服務與系統
我們應避免在內部使用遠端程序呼叫（RPC）。

只要領域事件的設計是正確的，幾乎不會發生將整個物件作為事件狀態傳送的情況。

### 延遲容忍
我們要思考的是多長的延遲是可以接受的，而多長的延遲會導致問題。這由領域決定。
大多數情況下，從幾秒到幾天都是可以接受的。

對自主服務來說，服務本身及服務所使用的訊息基礎設施，都需要具備高可用度與高擴展性，這樣才能滿足企業的非功能性需求。

## Event Store
為每個Bounded Context安排一個存放區來保存所有的領域事件。
1. 將Event Store配合訊息基礎設施，當作發布領域事件的訊息佇列使用
2. 使用相同的Event Store提供用戶端一個REST介面進行查詢，以此實作事件通知機制
3. 查看模型在執行每條命令後的執行結果歷史紀錄
4. 利用這些資料進行業務上的趨勢、預測、分析作業
5. 事件重建


## 轉發庫存事件的架構風格

### 以RESTful資源形式發送通知
在遵循發布、訂閱模式基本原則的系統環境中，也就是一個發布方與多個對相同事件感興趣的訂閱方，採用REST形式的事件通知是最好方案。
反之，如果是佇列性質的訊息機制，那麼REST就不是個好主意了。

- 可讓多個用戶端透過一個公開URI存取同樣的事件通知
- 但需要特定順序，從多個發布方拉取事件的話，不適合用REST

## 動手實作