---
tags: 
date: 2024-12-07
time: 14:07
---
實體是一個唯一的東西，並且能夠在長時間內不斷改變，我們可以對實體進行多次修改，改變幅度甚至會導致他與原本的狀態大不相同。但根據其識別值，他還是同一個物件。

實體所具備的唯一性與可變更性，正是其與「值物件Value Object」最大的差異。

# 唯一識別值
### 由使用者提供的識別值
要注意防錯機制。雖不適合高流量的領域，但若識別值需具備高可讀性，這是很好的做法。

### 由應用程式產生的識別值
`java.util.UUID`
識別值最好以自訂的值物件來存放會比較好。

對於聚合根的識別值，作者偏好以Repository來建立

### 由持久性機制產生的識別值
缺點是效能，靠資料庫產生識別值可能比應用程式生成要慢得多。

### 由另一個Bounded Context提供的識別值
這個方式複雜在需要同步操作，不管是本地影響外部，或是本地要訂閱外部系統發布的領域事件。

### 識別值生成的時機點
早期生成識別值：識別值的產生和指定發生在實體被持久儲存之前。
晚期生成識別值：識別值的產生和指定發生在實體被持久儲存之後。

如果要在領域事件中正確提供識別值，必須採用早期生成機制。
晚期生成還有個缺點：同時有兩個新物件時，無法比較。

#### 代理識別
如Hibernate之類的ORM工具會以自己的方式來處理物件的識別值。但是他與領域專屬的識別值是兩回事。
代理識別並不屬於領域模型的一部分，所以需要對外隱藏起來。
有一種避免影和擴大的方法是採用分層超級型別（Layer Supertype）的設計模式。

### 識別值的穩定性
識別值在大多數情況下，不應該被修改。


# 探索實體與實體固有的特性

### 探索實體與屬性
身份與存取情境的User建模。
- 使用者（User）是隸屬於租戶下的單位，必且由租戶控管
	- 租戶可以透過邀請讓多個使用者註冊
	- 租戶可能是啟用或停用的狀態
- 使用者必須獲得**授權**才能使用系統
	- 但只有啟用中的租戶才能授權
- 使用者包含使用者的個人資訊，如姓名與聯絡資訊等
- 使用者的個人資訊只能由使用者本人或管理員**變更**
- 使用者個安全憑證（即密碼）是可以**變更**的

**變更**代表存在至少一個實體。
**授權**這個關鍵字強烈暗示團隊必須提供某種搜尋比對相關的解決方案。

*p.240*
租戶識別不是一個實體，只是某種值物件。這個識別時要用特殊的資料型別，還是用簡單的String字串值就好呢？
這個識別值可以用在很多地方，可以設置在各個Bounded Context中的所有其他實體上。這種情況下使用「強型別」（string typing）可以帶來好處，只要定義一個TenantId值物件，開發團隊就能確保所有訂閱戶擁有的實體都帶有正確的識別值


### 找出重要的實體行為
租戶可能是啟用或停用的狀態。
第一直覺可能是一個boolean值。但這樣一個屬性可能不夠有效表達出「啟用」的意圖。

多個setter方法會使意圖變得模糊，也會讓發佈單一領域事件複雜化；因為**一個邏輯命令，應該對應產出一個有意義的領域事件**。 

```java
public class Tenant extends Entity {
	public void activate() {
	}
	public void deactivate() {
	}
}
```

身份授權不僅是要找出username, password配對的User，還需要一個更高層級的協調者（coordinator），而領域服務應運而生：**AuthenticationService**。[[Ch7. 領域服務#確認對領域服務的需求]]

使用者有可能是人或是系統。設計`Principal`介面，讓`Person`, `System`各自實作。

### 角色與職責
多角色的領域物件
每個介面都會禦侮騎實作的類別一個角色，如果類別沒有實作任何介面，那麼叫色就是由自身定義。
設計介面的用意就在於，決定哪些可以給用戶端知悉使用，哪些不行。

### 建立實體
使用早期生成識別值機制，建構子的參數中至少要包含唯一識別值。
如果有可能透過其他方式（名稱、關鍵字）查詢實體，也要把這些額外查詢納入建構子的參數中。
實體中具有一個不變量，要求物件不能處於null狀態的話，那麼就需要透過建構子提供狀態。

### 驗證
*p.258*
#### 對屬性的驗證
自我封裝：所有對此欄位的存取，即使是從類別內部，都要透過取器方法來完成。
優點：1. 他允許在實例變數上增加一層抽象層；2. 可以輕鬆存取物件中持有的任意數量屬性
提供一種簡單的驗證。

契約是設計：允許我們指定前置條件、後置條件、元件的不變量。
這裡的關注點是用前置條件，使用防禦性語句來作為驗證：
```java
private void setAddress(String anAdress) {
	if (anAddress == null) {
		throw new IllegalArgumentException(
			"The address may not be set to null.");
	}
	// ...  其他驗證
	this.address = anAddress;
}
```

#### 對物件整體的驗證

驗證整個實體需要對實體的整體狀態進行存許，但不要把驗證流程邏輯直接嵌入實體中。驗證會比領域物件本身發生更多變動，更何況這會使領域物件承擔過多的職責。

```java
public abstract class Entity {
	...
	public void validate(
	ValidationNotificationHandler aHandler) {
	}
}
```
把validate方法寫在自身類別當中，並不代表是由實體自己來執行驗證，只是讓提體決定採用何種驗證器，而不是讓用戶端決定。

#### 對物件組合的驗證
用一個領域服務來負責驗證。領域服務可以透過Respsitory存取需要驗證的聚合實例，然後對聚合中的每一個實例單獨進行驗證，或是與其他實例結合在一起進行驗證。

有時候需要等待時機才進行驗證（用領域事件）。

### 追蹤變更
使用領域事件與EventStore。