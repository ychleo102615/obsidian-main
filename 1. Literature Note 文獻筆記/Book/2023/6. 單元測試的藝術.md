## Ch. 1 單元測試的基礎

### 1.1 逐步定義單元測試

#### 工作單元
從呼叫系統的一個公開方法，到產生一個測試可見的[[#ExpectedBehavior|最終結果]]，在這期間這個系統所發生的行為統稱為一個「工作單元」。「最終結果」指的不是需要自行檢查系統內部狀態才能得到的資訊，而是公共API和行為就能知道的。可能有[[#ExpectedBehavior|三種最終的結果]]。

你所建立的工作單元越大，那麼他的最終結果對使用這API的使用者可見度就越高，那測試會更容易維護。

#### 單元測試是呼叫一個工作單元，驗證具體的最終結果。
#### 單元測試的範圍，小至一個方法，大至多個類別。

沒搞清楚單元測試是什麼就亂寫，還不如不要寫，省去維護的時間。

### 1.2 優秀單元測試的特質

- 簡單又快速的寫（你才願意寫）
- 簡單的用（誰都可以按個按鈕就執行）
- 可自動化
- 速度快（你才不會懶得跑它）
- 多次執行，結果總是一致
- 獨立於其他測試
- 結果是清楚的
- 好維護
- 完全掌控被測試者？
#unit_test_problem

### 1.3 整合測試

#### 整合測試是測試一個工作單元，但沒有對此單元有完全的控制（它還依賴其他真實物件如：時間、網路、資料庫、執行緒）。

整合測試的一個特質，就是它需要準備相關環境，無法馬上直接開始。

### 1.4 什麼是優秀的單元測試

沒有邏輯屬性的程式碼（例如單純的setter, getter）， 通常屬於工作單元的一部份，所以沒有必要單獨針對測試。

### 1.6 測試驅動開發（TDD）

1. 撰寫一個會失敗的測試，以證明測試會正常運行
2. 撰寫符合預期的程式碼，以通過測試
3. 重構

#### 重構
再不改變功能的前提下，修改程式碼，改可讀性、可維護性。
重新命名就是重構。extract method是重構。

_______________

## Ch. 2 第一個單元測試框架

### 2.1 單元測試框架

#### 測試框架提供了哪些東西
p.26
- 輕鬆撰寫結構化的測試
- 執行一個或全部單元測試（一個測試執行器）
- 確認測試執行結果

#### xUnit
單元測試框架的統稱，x為代表該語言的前綴（如CppUnit, JUnit, NUnit）

### 2.3 NUnit的第一個步驟

p.31

#### 基本規則

##### 專案名稱
新增測試專案：[ProjectUnderTest].UnitTests

##### 類別
對應被測試專案中的一個類別，新增類別：[ClassName].Tests

##### 工作單元（一個方法or幾個方法or幾個類別）
對每個工作單元，新增一個測試方法：
[UnitOfWorkName] __ [ScenarioUnderTest] __ [ExpectedBehavior]
```
e.g.
public void IsValidLogFileName_BadExtension_ReturnsFalse()
public void IsValidLogFileName_GoodExtensionLowercase_ReturnsTrue()

[TestCase("badfile.foo", false)]
[TestCase("goodfile.slf", true)]
public void IsValidLogFileName_WhenCalled_ChangesWasLastFileNameValid(string file, bool expected)
```

##### UnitOfWorkName
被測試的方法、一組方法或一組類別

##### Scenario
測試進行的假設條件。可已拿來描述傳給公開方法的參數、測試執行時的初始狀態...等。
e.g. 系統記憶體不足、無此使用者

##### ExpectedBehavior
可能有三種行為：回傳的結果（回傳值或是例外）、系統狀態的變化、呼叫外部第三方系統的服務。

### 2.4 撰寫第一個測試程式
通常包含三個行為：
1. 準備
2. 操作
3. 驗證

#### Assert
不要使用assert方法的msg功能，應用測試名稱說明結果。

### 測試程式風格
名稱可以很長，它應該可以當作一個句子來讀；使用底線區分訊息；準備物件、操作物件、驗證階段的程式碼之階保持空白行。
可參考第八章

### 2.5 使用參數來重構測試
被測試程式碼重構時，測試程式碼可能也要跟著修復，這是很浪費時間的事。
此方式可以避免把值寫死。（對編譯語言應該是很麻煩的事）

### 2.6 更多的NUnit特性

##### setup & teardown
注意：setup使用的越多，測試程式的可讀性就越差。p.42

setup可以改用工廠方法代替：
```
private static MemCalculator MakeCalc()
{
	return new MemCalculator();
}
```
在單元測試專案中，幾乎**永遠不會**用到teardown方法。如果你相依了其他檔案系統或資料庫的話，你在寫**整合測試**。
唯一用到的情況是在測試之間處理靜態變數和單例元件。

### 2.7 測試系統狀態的改變，而非驗證回傳值

首先確認被測試的「工作單元」是什麼。
系統狀態的<mark style="background: #FF5582A6;">變數名稱</mark>不應作為測試方法名稱的前綴，而應該是操作物件的<mark style="background: #FFB86CA6;">方法名稱</mark>。

-------------


## Ch. 3 透過虛設常式解決依賴問題

**控制外部依賴的行為。**

### 3.1 虛設常式簡介
##### 是在系統中產生一個可控制的替代物件，來取代一個外部相依物件（或協作者）。

#### 外部依賴
指在系統中的一個物件，會與被測試程式碼之間互動，但你無法掌握這個物件。（常見的是檔案系統、執行緒、記憶體、時間等，見[[#1.3 整合測試|整合測試]]）

### 3.2, 3.3
LogAnalyzer這個物件依賴於檔案系統。我們可以在這兩者之間插入一個中介層:`IExtensionManager`，先實現出依賴反轉。
```
-- before
LogAnalyzer -> FileSystem

// after
LogAnalyzer -> <interface>IExtensionManager <- FileExtensionManager
```
而這時候就可以使用Stub來解除依賴關係。
```
-- using Stub
LogAnalyzer ──> <interface>IExtensionManager <──┬── FileExtensionManager
                                                └── StubExtensionManager
```
這個技巧稱之為**接縫(seam)**。

### 3.4 重構設計以提升程式碼的可測試性

#### 接縫
是指程式碼中可以抽換不同功能的地方。這是透過Open-Closed Principle來完成的。

### 解除依賴的兩種重構方式
#unit_test_problem 應該稱之為依賴注入兩個步驟？ A像是依賴注入的事前準備，B則是依賴注入的方式。
##### A型重構
將具象類別改為介面(interfaces)或是委派(delegates)來實作。
擷取介面以便替換底層實作內容。
##### B型重構
將委派或介面的**偽實作**注入至目標物件中。

##### Fake前綴字
FakeExtensionManager，而不是StubExtensionManager or MockExtensionManager，是因為現在**還不想決定它是模擬物件還是虛設常式**。
使用Mock, Stub前綴時，我們會預期它有不同的特定行為。
Mock會去verify它。

### 替換為假物件的方式

#### 3.4.3 建構函式注入 
#### 3.4.5 透過屬性get set 注入假物件 
#### 3.4.6 在呼叫方法前才注入假物件
##### 1. 使用工廠類別
```java
class ExtensionManagerFactory {

	private IExtensionManager customManager = null;
 
	public IExtensionManager Create() {
		If (curstomManager != null)
			return customManager;
		Return new FileExtensionManager();
	}
 
	publid void SetManager(IExtensionManager mgr) {
		customManager = mgr;
	}
}
```
參考工廠方法、抽象工廠設計模式

##### 2. 在發布版本中隱藏接縫
編譯標記 3.6.2 p.89

##### 3. 不同的中間層深度層級
第一層：在被測試程式中偽造一個成員
第二層：在工廠類別中偽造一個成員
第三層：偽造假工廠類別
深度越深，對被測試程式碼的控制能力就越大，但也越難以理解。

##### 4. 繼承被測試物件並覆寫工廠方法
「擷取與覆寫」(Extract and Override)
這可能是作者最推薦的作法，程式碼不會為了可測試性而改變。
使用場景：需要模擬被測試類別由外部取得或回傳的輸入值時。
```java
class BetAreaPresenter
BetAreaPresenter:_createArea()
	...
end

class TestBetAreaPresenter:BetAreaPresenter 
TestBetAreaPresenter:_createArea()
	...
	return stub;
end
```

### 結論
利用「**接縫**」及「**擷取與覆寫**」來處理依賴問題

--------------

## Ch. 4 使用模擬物件驗證互動

測試工作單元的[[#ExpectedBehavior|第三種結果]]：與相依物件之間的互動。

### 4.1 基於值、狀態與互動的測試

#### 互動測試
是針對一個物件如何向其他物件發送訊息（呼叫方法）的測試。

互動測試應該是測試的最後一個選擇，因為它會導致事情變得複雜。
但有時候互動就是工作單元的最終結果，例如呼叫三方的log元件。你需要測試這個<mark style="background: #FFB8EBA6; font-weight:bold;">動作</mark>本身。

### 模擬物件
系統中的假物件，可以用來測試是否如預期般地被呼叫，使單元測試成功或是失敗。每個測試裡最多<mark style="background: #FFB86CA6;">只會有一個模擬物件</mark> [[#4.5 每個測試只用一個模擬物件|4.5]]。p.96

### 4.2 模擬物件與虛設常式物件的差異

首先，測試**驗證的對象**是不同的。

#### 虛設常式物件
驗證「被測試類別」本身。虛設常式物件只是輔助，目的是讓程式可以動、不會壞掉而已。

### 模擬物件
驗證與「模擬物件」的互動是否符合預期。

### 4.3 手刻模擬物件的簡單範例
模擬物件比虛設常式物件多做一件事：<mark style="background: #FFB8EBA6; font-weight:bold;">它會記錄所有互動</mark>。

注意：驗證的功能不是寫在模擬物件裡的。
原因：
1. 你希望這個模擬物件是可以被複用的
2. 驗證的動作不該被封裝在裡面。

### 4.4 同時使用模擬物件和虛設常式物件
如果你的程式有兩個外部相依，可以使用一個模擬物件和一個虛設常式物件。
重要的問題是，一個測試裡，可以使用多少個模擬物件和虛設常式物件？

### 4.5 每個測試只用一個模擬物件

#### 過度指定(overspecification)
是指過度指定在再測試中應該要發生事情的行為。

測得太多，只會導致難以維護。

### 4.6 假物件鏈：用虛設常式物件來產生模擬物件或其他虛設常式物件


### 4.7 手刻模擬物件和虛設常式物件的問題
撰寫與驗證都很複雜，又難以重用


[[2024-07-08|2024-07-08, 18:05]]
## Ch. 5 隔離模擬框架

### 5.6.5 過度指定的測試
盡量避免使用模擬物件。沒有太多的互動測試驗整語句，會讓測試更好讀、更好測試。
**模擬物件不要使用超過5%**。
互動測試是一把雙面刃；過多會使你忽略全局；過少會錯過物件之間的重要互動。

### 5.7 小結
盡量選擇測試回傳值
或系統狀態改變的測試（相對於互動測試），減少對內部實作的假設。
一不小心，模擬物件會讓測試變得難以維護跟閱讀。

## Ch. 8 好的單元測試的支柱

應具三特色：可信賴的、可維護的、可讀性
### 8.1 撰寫可信任的測試

#### 8.1.1 決定何時刪除或修改測試
1. 產品bug: 不需調整測試（發現產品bug本來就是測試的主要目的）
2. 測試bug: 
	1. 修復測試中的bug
	2. 確保測試失敗時會**真的失敗**
	3. 確保該通過時真的會通過
3. 語意或API更改
	1. 如果被測試的產品程式碼API不斷更改，工作量就會變大。使用工廠方法（e.g. `MakeDefaultAnalyzer`），工作量可以變得少一點
4. 矛盾、無效測試
		發現客戶需求的問題
5. 重構
6. 刪除重複的測試
		重複測試的缺點多於優點

#### 8.1.2 避免測試中帶著邏輯
例子：「讓這個方法透過迴圈，產生隨機亂數當作輸入，這樣就能找到更多的bug！」
這其實是**整合測試**。因為他們對待測試的物件只有很少的控制能力，結果的真實性不可被完全信任。

**不該有**：
1. switch, if, else
2. foreach, for, while
3. 難以閱讀、理解，複雜
4. 難以重現（亂數、多執行緒）

每個邏輯，都會讓程式碼更難閱讀。

#### 8.1.3 每次只測試一個關注點
一個關注點是一個工作單元的[[#ExpectedBehavior|最終結果]]

如果同時測試多個東西：
	1. 名字會變得抽象、通用、模糊。
	2. 拋出錯誤後，之後的測試就不會執行到

#### 8.1.4 分開單元、整合測試
#### 8.1.5 用程式碼審查（code review）確保程式碼覆蓋率

#### 增加新測試
1. 註解需被測試的程式碼片段
2. 執行所有測試
3. 通過：代表測試少了，因為我們期望它失敗
4. 新增測試，並且此測試會出錯
5. 移除註解
6. 預期通過測試
7. 沒通過的話，代表測試有bug或是測試了錯誤的東西


[[2024-07-03|2024-07-03, 09:15]]
### 8.2 撰寫可維護的測試

> [!NOTE] 
> 對於所有程式碼而言，時間在你認為的程式功能和它的實際功能之間增加了一個中間層。

只測試公開契約（public contract）、刪除重複的測試、測試隔離的實踐
#### 8.2.1 測試私有或保護的方法
- 想要測試一個方法，可能就是因為方法對呼叫端來說有某種已知的行爲或契約的效用
	- 公開：契約正式對外開放
	- 私有：這個方法只是構成公開契約中一連串動作的一部分
#### 8.2.2 去除重複的程式碼
用工廠方法或是Setup方法

#### 8.2.3 具可維護性的設計來使用 Setup 方法
濫用的例子
- 在setup方法中初始化只有某些測試方法用得到的物件
- 過於冗長難懂
- 在setup方法中準備模擬物件和假物件
停止使用setup方法

#### 8.2.4 實作測試隔離
一個測試不應知道其他測試的存在

#### 8.2.5 避免對不同的關注點進行多次驗證
當一驗證語句出錯時，同個測試中可能還有其他的驗證語句。你有可能不關心其他結果（只要一個出錯、其他也大概會出錯），但也有可能希望其他的驗證結果（驗證的功能彼此獨立，這樣更能鎖定出錯的位置）。

> [!NOTE] 為什麼所有的驗證語句都需要被執行到？
> 作者曾以為驗證只有一個失敗，導致在錯誤的地方找bug原因。如果檢查了其他驗證是否有被執行，可能會幫助他發現bug應該是在另一個地方。

- 每個驗證都要建立一個單獨的測試
- 使用參數化測試
- 把驗證程式碼放在try-catch區塊中（**請不要使用**，改用參數化測試）

#### 8.2.6 物件比較
- 想驗證一個狀態的多個方面，可以建立一個用來比較的物件，設定需要的屬性，然後使用一個驗證。
- 覆寫ToString方法，使輸出更清楚

#### 8.2.7 避免過度指定
##### 1. 指定驗證被測試物件的純內部行為
測試只測試物件的內部狀態，屬於過度指定。因為他是內部的，以後的實作內容可能還會改變。
單元測試只應測試公開契約、公開功能
##### 2. 需要虛設物件時，使用模擬物件
測試方法應該讓被測試方法執行自己內部的演算法邏輯，驗證其結果值，這樣測試才不會過於脆弱。
如果被測試方法，增加了一個內部的呼叫，或是改變了呼叫方法的參數，測試就會失敗。
測試不應該關心內部方法的呼叫，或是有沒有發生呼叫的行為。


> [!NOTE] slot1練習
> 以目前TestSettleService，書建議不要驗證「在`SettleService`中，對`plateView:playDropAnimation()`」這樣的呼叫，因為假如plateView重構了，譬如動畫需要分段呼叫、設置初始狀態、或是參數改變了，那這樣現在這個驗證就會失敗。
> 不應該擔心plateView的方法有沒有被呼叫到。
> 但我目前想不到更好的測試方式。

##### 3. 不必要的順序或是過度精準的參數匹配器
string.Contains 可能優於 string.Equals
驗證一個成員是否在集合中的某個位置，不如驗證一個集合是否包含預期的成員

### 8.3 撰寫可讀性高的測試
#### 8.3.1 單元測試的命名
[[#工作單元（一個方法or幾個方法or幾個類別）|參考2.3基本規則]]
應包含三部分
1. 被測試方法名稱
2. 測試情境
		我們給了什麼條件、參數
3. 預期行為

#### 8.3.2 變數命名
和產品程式碼的變數命名一樣重要，甚至更重要。
#### 8.3.3 有意義的驗證
驗證資訊，也就是輸出
1. 不要重複測試框架的控制命令輸出的資訊
2. 不要重複測試名稱裡面包含的資訊
3. 沒有有用資訊時，就什麼都別說
4. 提供該發生與不該發生什麼的資訊，可能的話提供時間點

#### 8.3.4 驗證和操作的分離
不要擠在同一行

#### 8.3.5 setup & teardown
少用。
每個測試多用輔助方法（工廠方法），提高可讀性，知道要準備什麼物件，不需要到很多地方去檢查程式碼寫了什麼。