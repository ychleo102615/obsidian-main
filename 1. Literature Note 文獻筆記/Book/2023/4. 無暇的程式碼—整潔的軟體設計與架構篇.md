
問題 tag:  #cleanArch_problem 

https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html


# Ch. 5 物件導向程式設計

### OO是什麼？是透過使用多型，來獲得控制依賴方向的能力。

# Ch. 7 SRP 單一職責原則
```
一個模組應該只對唯一的一個角色負責
```

# Ch. 10 ISP 介面隔離原則
#### 不要讓程式碼依賴於它不需要的功能。

#  Ch. 13 元件內聚性 p.89
[中文詳細說明](https://ithelp.ithome.com.tw/articles/10254888?sc=rss.qu)
[英文](https://fagnerbrack.com/why-do-you-need-to-know-package-cohesion-fundamentals-8a3510cba2c1)
[paper](https://drive.google.com/file/d/0BwhCYaYDn8EgOGM2ZGFhNmYtNmE4ZS00OGY5LWFkZTYtMjE0ZGNjODQ0MjEx/view?resourcekey=0-7i-jVGjVYvezk1_2CttrFw)

## REP 再使用性-發布等價原則 The Reuse/Release Equivalence Principle
```
再使用性的細緻度就是發佈的細緻度
The granule of **reuse** is the granule of **release**. Only components that are released through a tracking system can be effectively reused. The granule is the package.
```

聚集「應該」一起發佈的類別、模組至同一個元件內，所以你可以去追蹤他們的變化。
所謂的「應該」可以說是，這些類別不放在一起的話，元件會壞掉。所以這些類別也應共享相同的版本號。
這個原則聽起來很難懂，但其實應該很廢話，畢竟你不把這些元件放在一起的話，元件就會壞掉了。

因為我們可以利用版本追蹤發佈，這增加了元件的再使用性（它是可靠的）。
簡單來說，把應該一起發佈的檔案（類別），包在同一個資料夾（package）裡面。使用這個package的人不用擔心這個package之外的事。

網路上找到幾個不錯的說明：[參考1](https://dev.to/naomidennis/package-cohesion-reuse-release-equivalence-principle-3d28), [參考2](https://ericbackhage.net/clean-code/the-reuse-release-equivalence-principle/)
* 不要搞混「<mark style="background: #FF5582A6;">重複使用</mark>」與「<mark style="background: #FFB8EBA6;">再使用</mark>」，再使用指的應該是：原本使用的程式碼（依賴的）變動之後，能否如往常一樣

## <mark style="background: #FFF3A3A6;">傾向使元件變更大</mark>

## CCP 共同封閉原則 The Common Closure Principle
```
將那些會因著相同理由、再相同時間發生變化的類別，收集到相同的元件之中。
將那些在不同時間、因著不同理由發生變化的類別，分割到不同的元件之中。
The classes in a package should be closed together against the same kinds of changes. A change that affects a package affects all the classes in that package.
```
## <mark style="background: #FFF3A3A6;">傾向使元件變更大</mark>

## CRP 共同重複使用原則 The Common Reuse Principle
```
不要強迫元件的使用者依賴他們不需要使用的東西
The classes in a package are reused together. If you reuse one of the classes in a package, you reuse them all.
```
元件中若有你不需要的類別的話，就請把它從這個元件中移除掉。
## <mark style="background: #ABF7F7A6;">傾向使元件變更小</mark>

# Ch. 14 元件耦合性 p.95
## ADP 無環依賴原則 (Acylic Dependencies Principle)
元件的依賴結構中不能出現環

## SDP 穩定依賴原則 (Stable Dependencies Principle)
依賴穩定的元件，

計算穩定度的度量：
```
// FO: Fan out, 元件內部依賴元件外部的類別數量
// FI: Fan in, 元件外部依賴元件內部的類別數量
// I: Instability, 不穩定度

I = FO / (FO + FI)
```

## SAP 穩定抽象原則 (Stable Abstraction Principle)
我們希望高層設計穩定但是可以被擴展 (OCP)，**抽象類別**符合此特性。 

抽象度：
```
// Na: Number of abstract, interface classes
// Nc: Number of classes
// A: Abstraction

A = Na / Nc
```

A-I 座標圖

# Ch.19 策略和層級
層級代表的是：策略與「輸入」「輸出」的距離

# Ch. 20 業務規則 p.157

## Business Rule 業務規則
不論是用手算還是電腦算，都不會影響到業務規則。
## Entity 實體
- 關鍵業務資料
- 關鍵業務規則
## Use-case 使用案例
```
e.g. application-specific 應用程式特定的業務規則
```
使用案例包含指定如何以及何時呼叫Entity的關鍵業務規則。使用案例控制著Entity的使用方式。

Entity是高層級，使用案例是低層級，因為使用案例是特定於單一應用程式的，因此更接近系統的輸出輸出。

# Ch. 22 整潔的架構 p.167

## 依賴規則 (Dependency Rule)
[作者blog](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
架構圖：p.169

## 原始碼依賴關係只能指向內部，朝向更高層級的策略。

# Ch. 26 主元件
Main元件是最終的細節、最低層次的策略、最髒的元件。
Main是應用程式的plugin。

# Ch. 27 服務：偉大與微小 p.199
服務不是架構上的重要元素。
系統的架構是由該系統內繪製的邊界，以及跨越這些邊界的依賴來定義的，假架構不是由元素通訊和執行的物理機制所定義。

物理機制：我想這邊指的，所簡單的例子就是UI，他是一個服務，但如果你讓UI去決定邊界架構的話，就是很違反[[4. 無暇的程式碼—整潔的軟體設計與架構篇#依賴規則 (Dependency Rule) | 依賴規則 ]]的。

服務：功能的意思？
#cleanArch_problem 微服務是指什麼？p.199

# Ch. 28 測試邊界 p.207
## 測試API
- 測試可以使用這個api來驗證所有的「業務規則」。
- api應具有能力：避開安全約束、繞過昂貴的資源（如資料庫）並強制系統進入特定的可測試狀態。
- 這個api將是使用者介面使用的一組互動者(interactors)和介面轉接器(interface adapters)的超集合。

# Ch. 29 整潔的嵌入式架構
預期硬體是會改變的，做好隔離韌體與軟體的架構。
HAL: Hardware Abstraction Layer
```
Hardware/Firmware//HAL//Software
```
#cleanArch_problem  什麼是off-target測試？遠離目標硬體進行測試

# Ch. 32 框架是細節
### 不要與框架結婚（對該框架做出巨大的長期承諾）
### 但如C++的STL，還有Java的標準函式庫等，不太可能不一起用。




# Extra
## 範例程式碼
[clean architecture example](https://github.com/mattia-battiston/clean-architecture-example)
