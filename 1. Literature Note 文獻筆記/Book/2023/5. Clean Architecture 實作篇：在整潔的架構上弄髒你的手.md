---
tags:
date: 2023-03-13-週一
time: 14:58
note: 這其實是日後補加的閱讀開始日期（參考trello卡片）
---

## Ch. 1 階層式<mark style="background: #FFB86CA6;">架構</mark>的問題點
#### 階層式<mark style="background: #FFB86CA6;">架構</mark>
p.2
```
Web   | Domain | Persistence
網頁層 | 領域層  | 儲存層
```

[[2025-10-29|2025-10-29 Wed, 23:43]]
我們之所以建立這些原則，就是為了管理業務，使客戶能夠更容易與之互動。
而建模的對象則是行為（behavior），不是狀態（state）。
**行為才是導致狀態改變的原因，並且是業務的驅動力。**

把「ORM 架構」與「階層式架構」結合起來，很容易落入把「業務規則」與「儲存層觀點」混淆在一起的陷阱，導致緊密耦合。

## Ch. 3 程式<mark style="background: #FFB8EBA6;">結構</mark>
套件：package

### 為什麼不要以「[[5. Clean Architecture 實作篇：在整潔的架構上弄髒你的手#階層式架構 |架構層]]」作為套件（檔案）<mark style="background: #FFB8EBA6;">結構</mark>
1. 需要新增功能時，每個套件（資料夾）下都要改動，容易混亂
2. 看不出使用案例。服務的進入點要自己猜測。

### 以功能為套件<mark style="background: #FFB8EBA6;">結構</mark>
這麼做看得出程式碼的動機與意圖，是「會尖叫的架構」。但是就無法看出<mark style="background: #FFB86CA6;">架構</mark>了。

### 以<mark style="background: #FFB86CA6;">架構</mark>元素作為套件<mark style="background: #FFB8EBA6;">結構</mark>
```
bounded-context
	domain
	application
		in
		out
	adapter
		Service
		port
			in
			out
```

### 依賴注入的影響
p.34 
會有一個中立元件(neutral component)，負責處理所有架構層的依賴注入需求。架構中大多數的類別，都會由此元件來負責實例化(instaniating)。

[[2025-11-06|2025-11-06 Thu, 00:07]]
書中有提到我最近偶而會想到的問題，就是檔案結構應該要以「架構層」為結構，還是以「功能」為結構。
作者沒有給一個絕對答案，倒是提出了用 bounded context 作為頂部分界，內部基本上還是以「架構層」分類，但是遠不會那麼複雜。

另外看到這個章節，即使作者是懂 DDD 的，他對持久層的示範處理沒有像 DDD 那樣把介面擺在領域層，還是。
但是前面示範階層式架構時也還是有領域介面讓持久層實作。

## Ch. 4 使用案例實作

### 何謂使用案例：
1. 獲取輸入資料
2. 驗證業務規則
3. 操作模型狀態
4. 回傳輸出結果

### 不同的使用案例、不同的輸入（輸出）模型
p.48, 53
就算長得很類似，只要有一點不一樣，就不要重複使用，這產生了不必要的耦合，日後也可能會產生疑問。

### 業務規則驗證
輸入驗證是在測「語法」，格式、欄位等。
業務規則驗證是在測「語意」，是邏輯、程序、狀態上的問題。

### 唯獨使用案例的問題
有點像是使用案例的低位版：「查詢服務」(query service)
符合「命令與查詢分離」(Command-Query Seperation CQS)
是否可以偷吃步？

## Ch. 5 網頁層轉接器
即時性強的網頁服務，轉接器或許可以同時兼具「輸入轉接器」、「輸出轉接器」的身份。

[[2023-08-21|2023-08-21-週一, 14:56]]
#### 實務上轉接器跟使用案例之間多加一個port是蠻「多餘」的。但是這一層的用意其實是在於建立外部與核心溝通的「規格」。這樣的簡明性對之後要維護的人是很重要的。

[[pkds]]有參考這章來實作。
### 分割開來的控制器
過多總比不及好。
盡量使用「與使用案例相關的名稱」來命名方法、類別。
保持各自的模型。

## Ch. 6 儲存層轉接器

### 儲存層轉接器的職責
儲存層轉接器會從轉接埠獲取輸入。輸入模型可能會是領域實體，或是特定資料庫作業的相關物件。
#cleanArch_problem  這裡的輸入模型就結構上是放在application.port.out，有點誤會。它是**對儲存層轉接器輸入**沒錯，但從整體的角度來看，我覺得應該是「輸出模型」才對。

```
應用層   ｜   轉接層
------------------------
輸入模型 ---> JPA實體
			 ORM對應物件
			 純文字SQL語法			
```

### 分割開來的轉接埠介面
圖6.2是不好的示範。
如果把對資料庫的作業，全部聚集在同一個轉接埠介面的話，這會產生對「實際用不到的方法」的依賴，違反了[[4. 無暇的程式碼—整潔的軟體設計與架構篇#Ch. 10 ISP 介面隔離原則|ISP]]。

#### 大多時候轉接埠內就只有一個方法需要模擬。

### 分割開來的儲存層轉接器
按照「領域類別(domain class)」劃分，自然就會根據不同的領域邊界，將不同的儲存層功能劃分好。
再細分，根據不同工具來實現轉接埠。（JPA, SQL）

### [[Bounded Context（有界情境）]] p.76
在不同的情境之下，應使用各自專屬的轉接器(Adapter)

### 資料庫交易問題 p.84

#dirtyhand_problem
transaction似乎是database上特有的一個功能，保護你寫入失敗時，還可以回退(rollback)。
但是adapter不會知道交易階段的「頭尾」在哪裏。

書中提供的簡單解決方法，說的誇張一點的話是「讓Spring框架污染application層」。
否則可以用 AOP(aspect-oriented programming)，例如AspectJ。這部分還沒有研究。

網路上其他人的討論：
[How do you use tranactions in the Clean Architecture](https://stackoverflow.com/questions/50871171/how-do-you-use-transactions-in-the-clean-architecture),
[Which layer should the transaction management be on?](https://github.com/mattia-battiston/clean-architecture-example/issues/1)
golang的例子：[網址](https://blog.devgenius.io/go-golang-clean-architecture-repositories-vs-transactions-9b3b7c953463)

## Ch. 7 架構測試

### 測試金字塔

```
系統測試    高成本、少量       Λ
整合測試                    / \
單元測試    低成本、大量.    /   \
```
要是測試的成本越高，就越不應該以這類測試作為高測試覆蓋率的工具。

本書為後端架構，不會討論點對點測試(end-to-end tests)。p.90

### *單元測試*
實例化一個類別的物件，逐一測試其介面。依賴關係使用mock的方式取代。

#### 使用案例單元測試
##### BDD (behavior-driven development)
##### GWT (given-when-then)

##### 無狀態(stateless)的使用案例服務測試
無法驗證狀態，只能去驗證依賴的對象是否有被呼叫到。這代表測試項目是**不穩定的**。
[[2023-08-21|2023-08-21-週一, 18:05]]
**我們不應去驗證所有的行為，只需測試最重要的行為就好**
否則測試項目需要連帶修改的話，會減損測試的價值。


### *整合測試*
在多個單元間建立一個關聯網，測試整張網是否如其運作。
#### 網頁轉接器的整合測試
範例中的`@WebMvcTest`會觸發Spring框架，連帶實例化相關的物件。

### *系統測試*
在系統測試中，會啟動完整的應用程式，以某種使用案例作為測試項目，然後透過API介面發送請求，驗證**所有的架構**曾是否都如預期般運作。

使用DSL(Domain-Specific Language)提高可讀性。
系統測試可能代表使用者、透過使用者的觀點來驗證應用程式。

### 測試策略
1. 實作領域實體時 -> 單元測試
2. 實作使用案例時 -> 單元測試
3. 實作轉接器時     -> 整合測試
4. 針對最重要的應用程式使用情境 -> 系統測試

## Ch. 8 架構之間的對應策略

### 不對應策略(No Mapping)
p.107
優點：都長一樣，不用做轉譯
缺點：領域模型的類別很有可能因「網頁層、儲存層、應用程式層」的特殊需求而遭到修改，進而違反[[4. 無暇的程式碼—整潔的軟體設計與架構篇#Ch. 7 SRP 單一職責原則|SRP 單一職責原則]]。

### 雙向對應策略(Two-Way Mapping)
優點：整潔
缺點：
	1. 往往會產生大量的重複程式碼
	2. 領域模型容易受到外層架構影響，但其只應因領域邏輯而變動。

結論：視情況判斷適合的做法，而且將來還是有可能需要改變

### 全對應策略(Full Mapping)
在架構之間不是採用領域模型作為溝通方式，而是隨著不同的作業，使用不同的模型。
```
範例程式碼中的：SendMoneyCommand
```

### 單相對應策略(One-Way Mapping)
使用狀態介面(state interface)，各層皆需實作此介面。


## Ch. 9 應用程式組裝
簡單來說就是[[4. 無暇的程式碼—整潔的軟體設計與架構篇#Ch. 26 主元件|主元件(main)]]。
Java有Spring這個框架可以協助你組裝。

## Ch. 10 強化架構中的邊界

存取修飾子(visibility modifier)
```
public, protected, private
package-private 預設的無修飾子(default)
```

此章主要在介紹Java本身的語言特性、編譯、建置上的技巧或工具，來使你的架構更安全、更沒有違反依賴方向的機會。


## Ch. 11 理性看待偷吃步

#### [[#不同的使用案例、不同的輸入（輸出）模型|在使用案例之間共用模型]]
如果使用案例之間確實有著共同的需求，那共用模型或許是可以接受的。

#### [[#不對應策略(No Mapping)|把領域實體當成輸出或輸入模型]]
如果只是新增或修改模型的資料就罷了，但若在使用案例牽扯到更複雜領域邏輯的工作的話，就應該採用專用的「輸入輸出模型」

#### 省略輸入轉接埠
輸出轉接埠有依賴反轉的作用，但其實輸入轉接埠在實際使用上，是可以被省略掉（直接呼叫use-case service就好了）。
但是輸入轉接埠有導航的作用，並且讓控制流很精確。
如果只有一個輸入轉接器的話，即使省略轉接埠，應該也不難看懂程式碼。

#### 省略應用服務
通常會出現在CURD類型使用案例。
這會使轉接器去實作使用案例，倘若使用案例變得複雜（不是單純的CRUD了），這會導致領域邏輯四散各處、難以維護。

## Ch. 12 選擇你的架構風格

### 如果領域程式碼不是應用程式中的核心地位，那就不一定要遵循這類架構設計。


### 補充
看完之後有稍微在網路上找一些有沒有先端框架的範例或說明

Unity 簡單說明：[https://genki-sano.medium.com/simplified-clean-architecture-design-pattern-for-unity-967931583c47](https://genki-sano.medium.com/simplified-clean-architecture-design-pattern-for-unity-967931583c47)

對應及詳細說明：[https://betterprogramming.pub/the-clean-architecture-beginners-guide-e4b7058c1165](https://betterprogramming.pub/the-clean-architecture-beginners-guide-e4b7058c1165)

具體前端範例：[https://bespoyasov.me/blog/clean-architecture-on-frontend/](https://bespoyasov.me/blog/clean-architecture-on-frontend/)

簡化架構：[https://dev.to/itshugo/a-different-approach-to-frontend-architecture-38d4](https://dev.to/itshugo/a-different-approach-to-frontend-architecture-38d4)

[[2024-12-07|2024-12-07, 00:13]]
[《Clean Architecture實作篇：在整潔的架構上弄髒你的手》程式碼分析](https://teddy-chen-tw.blogspot.com/2022/07/clean-architecture_19.html)